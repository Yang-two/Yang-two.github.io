<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>PX4串口通信</title>
      <link href="/11.PX4%E4%B8%B2%E5%8F%A3%E9%80%9A%E4%BF%A1/"/>
      <url>/11.PX4%E4%B8%B2%E5%8F%A3%E9%80%9A%E4%BF%A1/</url>
      
        <content type="html"><![CDATA[<h1>PX4串口通信</h1><h1>一、硬件准备</h1><p><strong>1.飞控型号</strong>：支持PX41.14.1的硬件（Matek H73-wing）。<br><strong>2.串口接口：</strong> 选择飞控的UART端口（PX4有TELEM1、TELEM2、GPS1等），根据硬件手册及代码确认引脚定义。<br><strong>3.连接设备：</strong> 电脑（串口调试助手）。</p><p><strong>4.连接方式：</strong> 串口转USB。</p><hr><h1>二、PX4串口设置</h1><ul><li><strong>1.PX4串口</strong></li></ul><p>在H7系列主控中，串口通常启用1，2，3，4，6，7，8。由于移植PX4固件，后续配置中关闭串口1 ，所以存在2，3，4，6，7，8。分别对应：</p><table><thead><tr><th>UART(STM32H7)</th><th>Device(NuttX)</th></tr></thead><tbody><tr><td>USART2</td><td>/dev/ttyS0</td></tr><tr><td>USART3</td><td>/dev/ttyS1</td></tr><tr><td>UART4</td><td>/dev/ttyS2</td></tr><tr><td>USART6</td><td>/dev/ttyS3</td></tr><tr><td>UART7</td><td>/dev/ttyS4</td></tr><tr><td>UART8</td><td>/dev/ttyS5</td></tr></tbody></table><ul><li><strong>2.MATEK H743-WING映射</strong></li></ul><p><img src="../images/%5CPX4_Serial_Communication/image_GTp3G2ykSg.png" alt=""></p><p>定义自定义wing.px4board文件：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">CONFIG_BOARD_SERIAL_GPS1=<span class="string">&quot;/dev/ttyS0&quot;</span></span><br><span class="line">CONFIG_BOARD_SERIAL_TEL1=<span class="string">&quot;/dev/ttyS4&quot;</span></span><br><span class="line">CONFIG_BOARD_SERIAL_TEL2=<span class="string">&quot;/dev/ttyS5&quot;</span></span><br><span class="line">CONFIG_BOARD_SERIAL_TEL3=<span class="string">&quot;/dev/ttyS2&quot;</span></span><br><span class="line">CONFIG_BOARD_SERIAL_TEL4=<span class="string">&quot;/dev/ttyS3&quot;</span></span><br><span class="line">CONFIG_MODULES_RW_UART=y wing.px4board</span><br></pre></td></tr></table></figure><h1>二、PX4固件驱动开发</h1><p><strong>1.添加串口功能</strong>：</p><p>-在modules下添加rw_uart文件。</p><p><img src="../images/%5CPX4_Serial_Communication/image_wXBIuvRLbz.png" alt=""></p><p>-包括CMakeLists.txt;Kconfig和rw_uart.c文件</p><p>-在编写完所有程序后，需要make matek_h743_wing boardconfig 使能rw_uart模组。</p><p>-CMakeLists.txt文件如下：添加rw_uart模组</p><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment">############################################################################</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># rw_uart</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">############################################################################</span></span><br><span class="line">px4_add_module(</span><br><span class="line">    MODULE modules__rw_uart</span><br><span class="line">    MAIN rw_uart</span><br><span class="line">    STACK_MAIN <span class="number">2000</span></span><br><span class="line">    SRCS</span><br><span class="line">        rw_uart.c</span><br><span class="line">    DEPENDS</span><br><span class="line">)</span><br><span class="line"> CMakeLists.txt</span><br></pre></td></tr></table></figure><p>参数说明:</p><table><thead><tr><th>参数</th><th>值/内容</th><th>说明</th></tr></thead><tbody><tr><td>`MODULE`</td><td>modules\ __ rw_uart</td><td>模块在构建系统中的路径标识符</td></tr><tr><td>`MAIN`</td><td>rw\_uart</td><td>指定模块的主函数入口名称</td></tr><tr><td>`STACK_MAIN`</td><td>2000</td><td>为主函数分配的任务堆栈大小（单位：字节）</td></tr><tr><td>`SRCS`</td><td>rw\_uart.c</td><td>模块的源代码文件列表</td></tr><tr><td>`DEPENDS`</td><td>(空)</td><td>模块依赖的其他组件/库（当前未指定依赖项）</td></tr></tbody></table><p>-Kconfig文件如下：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">menuconfig MODULES_RW_UART</span><br><span class="line">  bool &quot;rw_uart&quot;</span><br><span class="line">  default n</span><br><span class="line">  ---help---</span><br><span class="line">    Enable support for rw_uart Kconfig</span><br></pre></td></tr></table></figure><p>2.<strong>编写串口收发代码：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;termios.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;drivers/drv_hrt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;systemlib/err.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;systemlib/mavlink_log.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;px4_platform_common/px4_config.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;px4_platform_common/tasks.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;px4_platform_common/posix.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;drivers/drv_hrt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;uORB/topics/sensor_accel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;uORB/topics/sensor_gyro.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;uORB/uORB.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> thread_should_exit = <span class="literal">false</span>;        <span class="comment">/**&lt; px4_uorb_subs exit flag */</span></span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> thread_running = <span class="literal">false</span>;            <span class="comment">/**&lt; px4_uorb_subs status flag */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> rw_uart_task;                        <span class="comment">/**&lt; Handle of px4_uorb_subs task / thread */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">uart_init</span><span class="params">(<span class="type">char</span> * uart_name)</span></span>;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">set_uart_baudrate</span><span class="params">(<span class="type">const</span> <span class="type">int</span> fd, <span class="type">unsigned</span> <span class="type">int</span> baud)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * daemon management function.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">__EXPORT <span class="type">int</span> <span class="title">rw_uart_main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Mainloop of daemon.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">rw_uart_thread_main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Print the correct usage.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">usage</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *reason)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">usage</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *reason)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (reason) &#123;</span><br><span class="line">        <span class="built_in">warnx</span>(<span class="string">&quot;%s\n&quot;</span>, reason);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">warnx</span>(<span class="string">&quot;usage: px4_uorb_adver &#123;start|stop|status&#125; [-p &lt;additional params&gt;]\n\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">set_uart_baudrate</span><span class="params">(<span class="type">const</span> <span class="type">int</span> fd, <span class="type">unsigned</span> <span class="type">int</span> baud)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> speed;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (baud) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">9600</span>:   speed = B9600;   <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">19200</span>:  speed = B19200;  <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">38400</span>:  speed = B38400;  <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">57600</span>:  speed = B57600;  <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">115200</span>: speed = B115200; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">warnx</span>(<span class="string">&quot;ERR: baudrate: %d\n&quot;</span>, baud);</span><br><span class="line">            <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">termios</span> uart_config;</span><br><span class="line">    <span class="type">int</span> termios_state;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">tcgetattr</span>(fd, &amp;uart_config); <span class="comment">// 获取终端参数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清除ONLCR标志，防止换行转换</span></span><br><span class="line">    uart_config.c_oflag &amp;= ~ONLCR;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置无校验，一个停止位，数据位8</span></span><br><span class="line">    uart_config.c_cflag &amp;= ~(CSTOPB | PARENB);  <span class="comment">// 1停止位，且无校验</span></span><br><span class="line">    uart_config.c_cflag |= CS8;  <span class="comment">// 数据位8</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((termios_state = <span class="built_in">cfsetispeed</span>(&amp;uart_config, speed)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">warnx</span>(<span class="string">&quot;ERR: %d (cfsetispeed)\n&quot;</span>, termios_state);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((termios_state = <span class="built_in">cfsetospeed</span>(&amp;uart_config, speed)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">warnx</span>(<span class="string">&quot;ERR: %d (cfsetospeed)\n&quot;</span>, termios_state);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置终端参数</span></span><br><span class="line">    <span class="keyword">if</span> ((termios_state = <span class="built_in">tcsetattr</span>(fd, TCSANOW, &amp;uart_config)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">warnx</span>(<span class="string">&quot;ERR: %d (tcsetattr)\n&quot;</span>, termios_state);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">uart_init</span><span class="params">(<span class="type">char</span> * uart_name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> serial_fd = <span class="built_in">open</span>(uart_name, O_RDWR | O_NOCTTY);</span><br><span class="line">    <span class="keyword">if</span> (serial_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">err</span>(<span class="number">1</span>, <span class="string">&quot;failed to open port: %s&quot;</span>, uart_name);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;failed to open port: %s\n&quot;</span>, uart_name);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Open the %d\n&quot;</span>, serial_fd);</span><br><span class="line">    <span class="keyword">return</span> serial_fd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">消息发布进程，会不断的接收自定义消息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">rw_uart_main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">usage</span>(<span class="string">&quot;missing command&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;start&quot;</span>)) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (thread_running) &#123;</span><br><span class="line">            <span class="built_in">warnx</span>(<span class="string">&quot;px4_uorb_subs already running\n&quot;</span>);</span><br><span class="line">            <span class="comment">/* this is not an error */</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        thread_should_exit = <span class="literal">false</span>;<span class="comment">//定义一个守护进程</span></span><br><span class="line">        rw_uart_task = <span class="built_in">px4_task_spawn_cmd</span>(<span class="string">&quot;rw_uart&quot;</span>,</span><br><span class="line">            SCHED_DEFAULT,</span><br><span class="line">            SCHED_PRIORITY_DEFAULT,<span class="comment">//调度优先级</span></span><br><span class="line">            <span class="number">2000</span>,<span class="comment">//堆栈分配大小</span></span><br><span class="line">            rw_uart_thread_main,</span><br><span class="line">            (argv) ? (<span class="type">char</span> *<span class="type">const</span> *)&amp;argv[<span class="number">2</span>] : (<span class="type">char</span> *<span class="type">const</span> *)<span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;stop&quot;</span>)) &#123;</span><br><span class="line">        thread_should_exit = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;status&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (thread_running) &#123;</span><br><span class="line">            <span class="built_in">warnx</span>(<span class="string">&quot;\trunning\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">warnx</span>(<span class="string">&quot;\tnot started\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">usage</span>(<span class="string">&quot;unrecognized command&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">rw_uart_thread_main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="type">int</span> uart_read = <span class="built_in">uart_init</span>(<span class="string">&quot;/dev/ttyS2&quot;</span>);</span><br><span class="line">     <span class="keyword">if</span> (<span class="literal">false</span> == uart_read)</span><br><span class="line">         <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">     <span class="keyword">if</span> (<span class="literal">false</span> == <span class="built_in">set_uart_baudrate</span>(uart_read, <span class="number">57600</span>)) &#123;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;[JXF]set_uart_baudrate is failed\n&quot;</span>);</span><br><span class="line">         <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;[JXF]uart init is successful\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">     thread_running = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 定义要发送的数据</span></span><br><span class="line">     <span class="type">char</span> buffer_1[] = <span class="string">&quot;XYT&quot;</span>;  <span class="comment">// 发送字符 &#x27;XYT&#x27;</span></span><br><span class="line">     <span class="type">char</span> buffer_2 = <span class="string">&#x27;\n&#x27;</span>;  <span class="comment">// 换行符</span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">while</span> (!thread_should_exit)</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="comment">// 确认发送的数据</span></span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;Sending data: %s\n&quot;</span>, buffer_1);  <span class="comment">// 输出发送的字符</span></span><br><span class="line"></span><br><span class="line">         <span class="comment">// 发送 &quot;XYT&quot;</span></span><br><span class="line">         <span class="built_in">write</span>(uart_read, &amp;buffer_1, <span class="built_in">strlen</span>(buffer_1));</span><br><span class="line">         <span class="built_in">usleep</span>(<span class="number">50000</span>);  <span class="comment">// 增加延迟至50ms</span></span><br><span class="line"></span><br><span class="line">         <span class="comment">// 发送换行符</span></span><br><span class="line">         <span class="built_in">write</span>(uart_read, &amp;buffer_2, <span class="built_in">sizeof</span>(buffer_2));</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;rw_uart TX-test: running!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 延迟1秒后继续发送</span></span><br><span class="line">         <span class="built_in">usleep</span>(<span class="number">1000000</span>);  <span class="comment">// 1秒延迟</span></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="built_in">warnx</span>(<span class="string">&quot;[rw_uart] exiting.\n&quot;</span>);</span><br><span class="line">     thread_running = <span class="literal">false</span>;</span><br><span class="line">     <span class="type">int</span> fd = <span class="built_in">close</span>(uart_read);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;close status: %d\n&quot;</span>, fd);</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125; rw_uart.c</span><br></pre></td></tr></table></figure><p>3.<strong>映射串口设备</strong>：</p><p>-对于需要修改默认串口映射的硬件（如代码中/dev/ttyS2），即串口4。</p><p>-代码中波特率为57600，数据位8位，停止位1位，无奇偶校验。</p><p>-连接：蓝线为TXD连接RXD；绿线为RXD连接TXD，图片容易产生误导。</p><p><img src="../images/PX4_Serial_Communication/image_kHDiko4cOG.png" alt=""></p><hr><h1>三、测试与验证</h1><ol><li><p><strong>硬件连接检查</strong>：</p><ul><li>使用万用表确认TX/RX/GND引脚连接正确，避免电平不匹配（如3.3V与5V设备）。</li></ul></li><li><p><strong>串口助手测试</strong>：</p><ul><li>在PC端使用串口调试工具发送测试指令，观察飞控响应。</li></ul></li><li><p><strong>结果分析</strong>：对于字符串能够正确发送电脑。</p><p><img src="../images/%5CPX4_Serial_Communication/image_KpMTeeHH4h.png" alt=""></p></li></ol><hr><h1>四、注意事项</h1><ol><li><strong>固件兼容性</strong>：PX4 1.14.1的API可能与旧版本存在差异，建议参考官方文档更新代码。提示出现参数错误，可升级QGC。</li><li><strong>权限问题</strong>：Linux系统下需确保用户对<code>/dev/ttyS*</code>设备有读写权限（可配置udev规则）。</li><li><strong>抗干扰设计</strong>：长距离通信时建议增加校验位或使用RS485转换模块。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> PX4 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机载通信</title>
      <link href="/14.%E6%9C%BA%E8%BD%BD%E9%80%9A%E4%BF%A1/"/>
      <url>/14.%E6%9C%BA%E8%BD%BD%E9%80%9A%E4%BF%A1/</url>
      
        <content type="html"><![CDATA[<h1>机载通信</h1><p>1.通过主控发送IMU等数据，到RDK X5的接受。结果：</p><p><img src="../images/Airborne_Communications/image_9CMq0O7H8C.png" alt=""></p><p>2.双边通信：</p><p>机载电脑发送RDK5</p><p><img src="../images/Airborne_Communications/image_d4DTSr2EOz.png" alt=""></p>]]></content>
      
      
      
        <tags>
            
            <tag> RDKX5 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RDKX5</title>
      <link href="/13.RDKX5/"/>
      <url>/13.RDKX5/</url>
      
        <content type="html"><![CDATA[<h1 id="RDKX5"><a href="#RDKX5" class="headerlink" title="RDKX5"></a>RDKX5</h1><h1 id="一、使用串口"><a href="#一、使用串口" class="headerlink" title="一、使用串口"></a>一、使用串口</h1><p>RDK X5 在 40PIN 上默认使能 UART1，物理管脚号 8 和 10，IO电压 3.3V。</p><h3 id="接入-USB串口转接板"><a href="#接入-USB串口转接板" class="headerlink" title="接入 USB串口转接板"></a>接入 USB串口转接板</h3><p>开发板USB Type A接口(接口7)，支持USB串口转接板功能，可自动检测USB串口转接板接入并创建设备节点<code>/dev/ttyUSB*</code>或者<code>/dev/ttyACM*</code>（星号代表0开始的数字）。</p><p><img src="../imageS/RDKX5/image_lv6TnZw30v.png"></p><h1 id="二、测试过程"><a href="#二、测试过程" class="headerlink" title="二、测试过程"></a>二、测试过程</h1><p>运行 python3 &#x2F;app&#x2F;40pin_samples&#x2F;test_serial.py<br>从打印的串口设备（其中 &#x2F;dev&#x2F;ttyS0 是系统调试口，不建议对它进行测试，除非你完全明白它的作用）中选择总线号和片选号作为输入选项，例如 RDK X3 选择测试 &#x2F;dev&#x2F;ttyS3，RDK X5 选择测试 &#x2F;dev&#x2F;ttyS1，RDK Ultra 选择测试 &#x2F;dev&#x2F;ttyS2 按回车键确认，并输入波特率参数：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="type">List</span> of enabled UART:</span><br><span class="line">/dev/ttyS0  /dev/ttyS1  /dev/ttyS3  /dev/ttyUSB0</span><br><span class="line">​</span><br><span class="line">请输出需要测试的串口设备名:/dev/ttyS3</span><br><span class="line">请输入波特率(<span class="number">9600</span>,<span class="number">19200</span>,<span class="number">38400</span>,<span class="number">57600</span>,<span class="number">115200</span>,<span class="number">921600</span>):<span class="number">921600</span></span><br><span class="line">Serial&lt;<span class="built_in">id</span>=<span class="number">0x7f819dcac0</span>, <span class="built_in">open</span>=<span class="literal">True</span>&gt;(port=<span class="string">&#x27;/dev/ttyS3&#x27;</span>, baudrate=<span class="number">921600</span>, bytesize=<span class="number">8</span>, parity=<span class="string">&#x27;N&#x27;</span>, stopbits=<span class="number">1</span>, timeout=<span class="number">1</span>, xonxoff=<span class="literal">False</span>, rtscts=<span class="literal">False</span>, dsrdtr=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><ul><li>程序正确运行起来后会持续打印<code>Send: AA55</code>和<code>Recv: AA55</code>：</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Starting demo now! Press CTRL+C to exit</span><br><span class="line">Send:  AA55</span><br><span class="line">Recv:  AA55</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="三、测试完整代码"><a href="#三、测试完整代码" class="headerlink" title="三、测试完整代码"></a>三、测试完整代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> signal</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">​</span><br><span class="line"><span class="comment"># 导入python串口库</span></span><br><span class="line"><span class="keyword">import</span> serial</span><br><span class="line"><span class="keyword">import</span> serial.tools.list_ports</span><br><span class="line">​</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">signal_handler</span>(<span class="params">signal, frame</span>):</span><br><span class="line">    sys.exit(<span class="number">0</span>)</span><br><span class="line">​</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">serialTest</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;List of enabled UART:&quot;</span>)</span><br><span class="line">    os.system(<span class="string">&#x27;ls /dev/tty[a-zA-Z]*&#x27;</span>)</span><br><span class="line">    uart_dev= <span class="built_in">input</span>(<span class="string">&quot;请输出需要测试的串口设备名:&quot;</span>)</span><br><span class="line">​</span><br><span class="line">    baudrate = <span class="built_in">input</span>(<span class="string">&quot;请输入波特率(9600,19200,38400,57600,115200,921600):&quot;</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        ser = serial.Serial(uart_dev, <span class="built_in">int</span>(baudrate), timeout=<span class="number">1</span>) <span class="comment"># 1s timeout</span></span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;open serial failed!\n&quot;</span>)</span><br><span class="line">​</span><br><span class="line">    <span class="built_in">print</span>(ser)</span><br><span class="line">​</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Starting demo now! Press CTRL+C to exit&quot;</span>)</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        test_data = <span class="string">&quot;AA55&quot;</span></span><br><span class="line">        write_num = ser.write(test_data.encode(<span class="string">&#x27;UTF-8&#x27;</span>))</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Send: &quot;</span>, test_data)</span><br><span class="line">​</span><br><span class="line">        received_data = ser.read(write_num).decode(<span class="string">&#x27;UTF-8&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Recv: &quot;</span>, received_data)</span><br><span class="line">​</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">​</span><br><span class="line">    ser.close()</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">​</span><br><span class="line">​</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    signal.signal(signal.SIGINT, signal_handler)</span><br><span class="line">    <span class="keyword">if</span> serialTest() != <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Serial test failed!&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Serial test success!&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="四、开机自启动"><a href="#四、开机自启动" class="headerlink" title="四、开机自启动"></a>四、开机自启动</h1><p><a href="https://www.yahboom.com/public/upload/upload-html/1729668000/%E5%BC%80%E6%9C%BA%E8%87%AA%E5%90%AF%E5%8A%A8%E9%85%8D%E7%BD%AE.html#%E7%A8%8B%E5%BA%8F%E5%BC%80%E6%9C%BA%E8%87%AA%E5%90%AF%E5%8A%A8" title="程序开机自启动">程序开机自启动</a><a href="https://www.yahboom.com/public/upload/upload-html/1729668000/%E5%BC%80%E6%9C%BA%E8%87%AA%E5%90%AF%E5%8A%A8%E9%85%8D%E7%BD%AE.html#1-%E8%AE%BE%E7%BD%AE%E8%87%AA%E5%90%AF%E5%8A%A8service" title="1. 设置自启动Service">1. 设置自启动Service</a><a href="https://www.yahboom.com/public/upload/upload-html/1729668000/%E5%BC%80%E6%9C%BA%E8%87%AA%E5%90%AF%E5%8A%A8%E9%85%8D%E7%BD%AE.html#2-%E6%B7%BB%E5%8A%A0%E5%88%B0rclocal%E6%9C%8D%E5%8A%A1" title="2. 添加到rc.local服务">2. 添加到rc.local服务</a></p><h2 id="1-设置自启动Service"><a href="#1-设置自启动Service" class="headerlink" title="1. 设置自启动Service"></a>1. 设置自启动Service</h2><ol><li><p>创建启动脚本</p><p>使用任何文本编辑器，在<code>/etc/init.d</code>目录下创建一个新的启动脚本，假设命名为<code>your_script_name</code>，以下是示例脚本的参考内容：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### BEGIN INIT INFO</span></span><br><span class="line"><span class="comment"># Provides:          your_service_name</span></span><br><span class="line"><span class="comment"># Required-Start:    $all</span></span><br><span class="line"><span class="comment"># Required-Stop:     </span></span><br><span class="line"><span class="comment"># Default-Start:     2 3 4 5</span></span><br><span class="line"><span class="comment"># Default-Stop:      0 1 6</span></span><br><span class="line"><span class="comment"># Short-Description: Start your_service_name at boot time</span></span><br><span class="line"><span class="comment"># Description:       Enable service provided by your_service_name</span></span><br><span class="line"><span class="comment">### END INIT INFO</span></span><br><span class="line">​</span><br><span class="line">/path/to/your/program &amp;</span><br><span class="line">​</span><br><span class="line"><span class="built_in">exit</span> 0</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>设置启动脚本具有可执行权限</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> <span class="built_in">chmod</span> +x /etc/init.d/your_script_name</span><br></pre></td></tr></table></figure></li><li><p>使用update-rc.d命令将脚本添加到系统的启动项中</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> update-rc.d your_script_name defaults</span><br></pre></td></tr></table></figure></li><li><p>使用systemctl命令启用自启动</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl <span class="built_in">enable</span> your_script_name</span><br></pre></td></tr></table></figure></li><li><p>重启开发板验证自启动服务程序是否运行正常</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl status your_script_name.service</span><br></pre></td></tr></table></figure><h2 id="2-添加到rc-local服务"><a href="#2-添加到rc-local服务" class="headerlink" title="2. 添加到rc.local服务"></a>2. 添加到rc.local服务</h2><p>rc.local是一个系统服务，用于在系统启动时自动执行一些脚本或命令。这个服务在系统启动时会被自动调用，并在系统启动完成后执行一些用户指定的脚本或命令，以便在系统启动时进行自定义配置或操作。</p><p>在早期的Linux发行版中，rc.local是系统启动过程中默认运行的最后一个服务。随着systemd的普及，rc.local被视为遗留的系统服务。</p><p>通过在<code>sudo vim /etc/rc.local</code>文件末尾添加启动命令的方式实现，例如：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash -e</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># rc.local</span></span><br><span class="line"><span class="comment">#re</span></span><br><span class="line"><span class="comment"># This script is executed at the end of each multiuser runlevel.</span></span><br><span class="line"><span class="comment"># Make sure that the script will &quot;exit 0&quot; on success or any other</span></span><br><span class="line"><span class="comment"># value on error.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># In order to enable or disable this script just change the execution</span></span><br><span class="line"><span class="comment"># bits.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># By default this script does nothing.</span></span><br><span class="line">​</span><br><span class="line"><span class="comment"># Insert what you need</span></span><br><span class="line">​</span><br><span class="line"><span class="built_in">exit</span> 0</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> RDKX5 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PX4IMU等数据处理</title>
      <link href="/12.PX4IMU%E7%AD%89%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"/>
      <url>/12.PX4IMU%E7%AD%89%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="PX4IMU等数据处理"><a href="#PX4IMU等数据处理" class="headerlink" title="PX4IMU等数据处理"></a>PX4IMU等数据处理</h1><h1 id="1-前置条件-x20"><a href="#1-前置条件-x20" class="headerlink" title="1.前置条件 &#x20;"></a>1.前置条件 &#x20;</h1><p>-已搭建PX4开发环境（基于Ubuntu&#x2F;NuttX） &#x20;<br>-熟悉uORB消息系统架构 &#x20;<br>-使用C++开发模块</p><h1 id="2-uORB消息类型2-1IMU数据"><a href="#2-uORB消息类型2-1IMU数据" class="headerlink" title="2.uORB消息类型2.1IMU数据"></a>2.uORB消息类型<br>2.1IMU数据</h1><p>-<strong>主消息</strong>：<code>sensor_combined</code>（包含加速度计+陀螺仪原始数据）<br>-独立消息：<br>-<code>sensor_accel</code>（三轴加速度计原始数据）<br>-<code>sensor_gyro</code>（三轴陀螺仪原始数据）</p><p>-<code>vehicle_attitude </code>EKF2 的 vehicle_attitude 数据，四元数</p><h2 id="2-2GPS数据"><a href="#2-2GPS数据" class="headerlink" title="2.2GPS数据"></a>2.2GPS数据</h2><p>-<strong>主消息</strong>：<code>vehicle_gps_position </code>-包含字段：<br>-经纬度（<code>lat</code>&#x2F;<code>lon</code>）<br>-海拔高度（<code>alt</code>）<br>-定位状态（<code>fix_type</code>）<br>-卫星数（<code>satellites_used</code>）</p><h2 id="2-3消息"><a href="#2-3消息" class="headerlink" title="2.3消息"></a>2.3消息</h2><p>-src&#x2F;lib&#x2F;drivers&#x2F;accelerometer&#x2F;PX4Accelerometer.cpp</p><p>-这段代码是 PX4 固件中 PX4Accelerometer 类的实现，负责处理加速度计的数据，包括数据的旋转、缩放、发布以及 FIFO（先进先出）缓存的处理。</p><p>-在 PX4 飞控系统中，<code>sensor_accel.h</code>和<code>sensor_gyro.h</code>定义了加速度计和陀螺仪传感器的数据结构和相关话题（topics）。这些数据通过 uORB 消息传递机制在系统中发布和订阅，供其他模块使用。</p><h1 id="3-订阅实现步骤"><a href="#3-订阅实现步骤" class="headerlink" title="3.订阅实现步骤"></a>3.订阅实现步骤</h1><h1 id="3-1头文件"><a href="#3-1头文件" class="headerlink" title="3.1头文件"></a>3.1头文件</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;termios.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;drivers/drv_hrt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;systemlib/err.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;systemlib/mavlink_log.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;px4_platform_common/px4_config.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;px4_platform_common/tasks.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;px4_platform_common/posix.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;drivers/drv_hrt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;uORB/topics/sensor_accel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;uORB/topics/sensor_gyro.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;uORB/topics/sensor_combined.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;uORB/topics/vehicle_attitude.h&gt;</span> <span class="comment">// EKF2 处理后的数据</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;uORB/uORB.h&gt;</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="3-2初始化订阅"><a href="#3-2初始化订阅" class="headerlink" title="3.2初始化订阅"></a>3.2初始化订阅</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//订阅加速度计和陀螺仪数据</span></span><br><span class="line"><span class="type">int</span> sensor_accel_sub = <span class="built_in">orb_subscribe</span>(<span class="built_in">ORB_ID</span>(sensor_accel));</span><br><span class="line"><span class="type">int</span> sensor_gyro_sub = <span class="built_in">orb_subscribe</span>(<span class="built_in">ORB_ID</span>(sensor_gyro));</span><br><span class="line"><span class="type">int</span> sensor_combined_sub = <span class="built_in">orb_subscribe</span>(<span class="built_in">ORB_ID</span>(sensor_combined));      <span class="comment">// IMU 完整数据</span></span><br><span class="line"><span class="type">int</span> vehicle_attitude_sub = <span class="built_in">orb_subscribe</span>(<span class="built_in">ORB_ID</span>(vehicle_attitude));    <span class="comment">// EKF2 姿态数据</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="3-3完整串口发送代码"><a href="#3-3完整串口发送代码" class="headerlink" title="3.3完整串口发送代码"></a>3.3完整串口发送代码</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">rw_uart_thread_main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 初始化串口，使用 PX4 提供的接口</span></span><br><span class="line">    <span class="type">int</span> uart_read = uart_init(<span class="string">&quot;/dev/ttyS2&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">false</span> == uart_read)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">false</span> == set_uart_baudrate(uart_read, <span class="number">57600</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[JXF]set_uart_baudrate is failed\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[JXF]uart init is successful\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    thread_running = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 订阅 sensor_accel 和 sensor_gyro 话题</span></span><br><span class="line">    <span class="type">int</span> sensor_accel_sub = orb_subscribe(ORB_ID(sensor_accel));</span><br><span class="line">    <span class="type">int</span> sensor_gyro_sub = orb_subscribe(ORB_ID(sensor_gyro));</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sensor_accel_s</span> <span class="title">sensor_accel_data</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sensor_gyro_s</span> <span class="title">sensor_gyro_data</span>;</span></span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">128</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!thread_should_exit) &#123;</span><br><span class="line">        <span class="comment">// 获取 sensor_accel 数据</span></span><br><span class="line">        <span class="keyword">if</span> (orb_copy(ORB_ID(sensor_accel), sensor_accel_sub, &amp;sensor_accel_data) == PX4_OK) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;sensor_accel:\ttimestamp: %&quot;</span> PRIu64 <span class="string">&quot; temperature: %.2f x: %.2f y: %.2f z: %.2f\n&quot;</span>,</span><br><span class="line">                   sensor_accel_data.timestamp, (<span class="type">double</span>)sensor_accel_data.temperature,</span><br><span class="line">                   (<span class="type">double</span>)sensor_accel_data.x, (<span class="type">double</span>)sensor_accel_data.y, (<span class="type">double</span>)sensor_accel_data.z);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">snprintf</span>(buffer, <span class="keyword">sizeof</span>(buffer), <span class="string">&quot;sensor_accel: timestamp: %&quot;</span> PRIu64 <span class="string">&quot; temp: %.2f x: %.2f y: %.2f z: %.2f\n&quot;</span>,</span><br><span class="line">                     sensor_accel_data.timestamp, (<span class="type">double</span>)sensor_accel_data.temperature,</span><br><span class="line">                     (<span class="type">double</span>)sensor_accel_data.x, (<span class="type">double</span>)sensor_accel_data.y, (<span class="type">double</span>)sensor_accel_data.z);</span><br><span class="line"></span><br><span class="line">            write(uart_read, buffer, <span class="built_in">strlen</span>(buffer));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取 sensor_gyro 数据</span></span><br><span class="line">        <span class="keyword">if</span> (orb_copy(ORB_ID(sensor_gyro), sensor_gyro_sub, &amp;sensor_gyro_data) == PX4_OK) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;sensor_gyro:\ttimestamp: %&quot;</span> PRIu64 <span class="string">&quot; temperature: %.2f x: %.2f y: %.2f z: %.2f\n&quot;</span>,</span><br><span class="line">                   sensor_gyro_data.timestamp, (<span class="type">double</span>)sensor_gyro_data.temperature,</span><br><span class="line">                   (<span class="type">double</span>)sensor_gyro_data.x, (<span class="type">double</span>)sensor_gyro_data.y, (<span class="type">double</span>)sensor_gyro_data.z);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">snprintf</span>(buffer, <span class="keyword">sizeof</span>(buffer), <span class="string">&quot;sensor_gyro: timestamp: %&quot;</span> PRIu64 <span class="string">&quot; temp: %.2f x: %.2f y: %.2f z: %.2f\n&quot;</span>,</span><br><span class="line">                     sensor_gyro_data.timestamp, (<span class="type">double</span>)sensor_gyro_data.temperature,</span><br><span class="line">                     (<span class="type">double</span>)sensor_gyro_data.x, (<span class="type">double</span>)sensor_gyro_data.y, (<span class="type">double</span>)sensor_gyro_data.z);</span><br><span class="line"></span><br><span class="line">            write(uart_read, buffer, <span class="built_in">strlen</span>(buffer));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        usleep(<span class="number">50000</span>); <span class="comment">// 50ms 延迟</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    PX4_WARN(<span class="string">&quot;[rw_uart] exiting.&quot;</span>);</span><br><span class="line">    thread_running = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    close(uart_read);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;UART close status: %d\n&quot;</span>, uart_read);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> main</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;termios.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;drivers/drv_hrt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;systemlib/err.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;systemlib/mavlink_log.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;px4_platform_common/px4_config.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;px4_platform_common/tasks.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;px4_platform_common/posix.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;drivers/drv_hrt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;uORB/topics/sensor_accel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;uORB/topics/sensor_gyro.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;uORB/topics/sensor_combined.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;uORB/topics/vehicle_attitude.h&gt;</span> <span class="comment">// EKF2 处理后的数据</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;uORB/uORB.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> thread_should_exit = <span class="literal">false</span>;        <span class="comment">/**&lt; px4_uorb_subs exit flag */</span></span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> thread_running = <span class="literal">false</span>;            <span class="comment">/**&lt; px4_uorb_subs status flag */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> rw_uart_task;                        <span class="comment">/**&lt; Handle of px4_uorb_subs task / thread */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">uart_init</span><span class="params">(<span class="type">char</span> * uart_name)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">set_uart_baudrate</span><span class="params">(<span class="type">const</span> <span class="type">int</span> fd, <span class="type">unsigned</span> <span class="type">int</span> baud)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * daemon management function.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">__EXPORT <span class="type">int</span> <span class="title function_">rw_uart_main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Mainloop of daemon.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">rw_uart_thread_main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Print the correct usage.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">usage</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *reason)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">usage</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *reason)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (reason) &#123;</span><br><span class="line">        warnx(<span class="string">&quot;%s\n&quot;</span>, reason);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    warnx(<span class="string">&quot;usage: px4_uorb_adver &#123;start|stop|status&#125; [-p &lt;additional params&gt;]\n\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">set_uart_baudrate</span><span class="params">(<span class="type">const</span> <span class="type">int</span> fd, <span class="type">unsigned</span> <span class="type">int</span> baud)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> speed;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (baud) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">9600</span>:   speed = B9600;   <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">19200</span>:  speed = B19200;  <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">38400</span>:  speed = B38400;  <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">57600</span>:  speed = B57600;  <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">115200</span>: speed = B115200; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            warnx(<span class="string">&quot;ERR: baudrate: %d\n&quot;</span>, baud);</span><br><span class="line">            <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">termios</span> <span class="title">uart_config</span>;</span></span><br><span class="line">    <span class="type">int</span> termios_state;</span><br><span class="line"></span><br><span class="line">    tcgetattr(fd, &amp;uart_config); <span class="comment">// 获取终端参数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清除ONLCR标志，防止换行转换</span></span><br><span class="line">    uart_config.c_oflag &amp;= ~ONLCR;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置无校验，一个停止位，数据位8</span></span><br><span class="line">    uart_config.c_cflag &amp;= ~(CSTOPB | PARENB);  <span class="comment">// 1停止位，且无校验</span></span><br><span class="line">    uart_config.c_cflag |= CS8;  <span class="comment">// 数据位8</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((termios_state = cfsetispeed(&amp;uart_config, speed)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        warnx(<span class="string">&quot;ERR: %d (cfsetispeed)\n&quot;</span>, termios_state);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((termios_state = cfsetospeed(&amp;uart_config, speed)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        warnx(<span class="string">&quot;ERR: %d (cfsetospeed)\n&quot;</span>, termios_state);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置终端参数</span></span><br><span class="line">    <span class="keyword">if</span> ((termios_state = tcsetattr(fd, TCSANOW, &amp;uart_config)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        warnx(<span class="string">&quot;ERR: %d (tcsetattr)\n&quot;</span>, termios_state);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">uart_init</span><span class="params">(<span class="type">char</span> * uart_name)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> serial_fd = open(uart_name, O_RDWR | O_NOCTTY);</span><br><span class="line">    <span class="keyword">if</span> (serial_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        err(<span class="number">1</span>, <span class="string">&quot;failed to open port: %s&quot;</span>, uart_name);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;failed to open port: %s\n&quot;</span>, uart_name);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Open the %d\n&quot;</span>, serial_fd);</span><br><span class="line">    <span class="keyword">return</span> serial_fd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">消息发布进程，会不断的接收自定义消息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">rw_uart_main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        usage(<span class="string">&quot;missing command&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;start&quot;</span>)) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (thread_running) &#123;</span><br><span class="line">            warnx(<span class="string">&quot;px4_uorb_subs already running\n&quot;</span>);</span><br><span class="line">            <span class="comment">/* this is not an error */</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        thread_should_exit = <span class="literal">false</span>;<span class="comment">//定义一个守护进程</span></span><br><span class="line">        rw_uart_task = px4_task_spawn_cmd(<span class="string">&quot;rw_uart&quot;</span>,</span><br><span class="line">            SCHED_DEFAULT,</span><br><span class="line">            SCHED_PRIORITY_DEFAULT,<span class="comment">//调度优先级</span></span><br><span class="line">            <span class="number">2000</span>,<span class="comment">//堆栈分配大小</span></span><br><span class="line">            rw_uart_thread_main,</span><br><span class="line">            (argv) ? (<span class="type">char</span> *<span class="type">const</span> *)&amp;argv[<span class="number">2</span>] : (<span class="type">char</span> *<span class="type">const</span> *)<span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;stop&quot;</span>)) &#123;</span><br><span class="line">        thread_should_exit = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;status&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (thread_running) &#123;</span><br><span class="line">            warnx(<span class="string">&quot;\trunning\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            warnx(<span class="string">&quot;\tnot started\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    usage(<span class="string">&quot;unrecognized command&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">rw_uart_thread_main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 初始化串口，使用 PX4 提供的接口</span></span><br><span class="line">    <span class="type">int</span> uart_read = uart_init(<span class="string">&quot;/dev/ttyS2&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">false</span> == uart_read)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">false</span> == set_uart_baudrate(uart_read, <span class="number">57600</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[JXF]set_uart_baudrate is failed\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[JXF]uart init is successful\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    thread_running = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 订阅话题</span></span><br><span class="line"><span class="type">int</span> sensor_accel_sub = orb_subscribe(ORB_ID(sensor_accel));</span><br><span class="line"><span class="type">int</span> sensor_gyro_sub = orb_subscribe(ORB_ID(sensor_gyro));</span><br><span class="line"><span class="type">int</span> sensor_combined_sub = orb_subscribe(ORB_ID(sensor_combined));      <span class="comment">// IMU 完整数据</span></span><br><span class="line"><span class="type">int</span> vehicle_attitude_sub = orb_subscribe(ORB_ID(vehicle_attitude));    <span class="comment">// EKF2 姿态数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sensor_accel_s</span> <span class="title">sensor_accel_data</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sensor_gyro_s</span> <span class="title">sensor_gyro_data</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sensor_combined_s</span> <span class="title">sensor_combined_data</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vehicle_attitude_s</span> <span class="title">vehicle_attitude_data</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> buffer[<span class="number">256</span>]; <span class="comment">// 缓冲区</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!thread_should_exit) &#123;</span><br><span class="line">    <span class="comment">// 获取 sensor_accel 数据</span></span><br><span class="line">    <span class="keyword">if</span> (orb_copy(ORB_ID(sensor_accel), sensor_accel_sub, &amp;sensor_accel_data) == PX4_OK) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;sensor_accel: x: %.2f y: %.2f z: %.2f\n&quot;</span>,</span><br><span class="line">               (<span class="type">double</span>)sensor_accel_data.x, (<span class="type">double</span>)sensor_accel_data.y, (<span class="type">double</span>)sensor_accel_data.z);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">snprintf</span>(buffer, <span class="keyword">sizeof</span>(buffer), <span class="string">&quot;sensor_accel: x: %.2f y: %.2f z: %.2f\n&quot;</span>,</span><br><span class="line">                 (<span class="type">double</span>)sensor_accel_data.x, (<span class="type">double</span>)sensor_accel_data.y, (<span class="type">double</span>)sensor_accel_data.z);</span><br><span class="line">        write(uart_read, buffer, <span class="built_in">strlen</span>(buffer));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 sensor_gyro 数据</span></span><br><span class="line">    <span class="keyword">if</span> (orb_copy(ORB_ID(sensor_gyro), sensor_gyro_sub, &amp;sensor_gyro_data) == PX4_OK) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;sensor_gyro: x: %.2f y: %.2f z: %.2f\n&quot;</span>,</span><br><span class="line">               (<span class="type">double</span>)sensor_gyro_data.x, (<span class="type">double</span>)sensor_gyro_data.y, (<span class="type">double</span>)sensor_gyro_data.z);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">snprintf</span>(buffer, <span class="keyword">sizeof</span>(buffer), <span class="string">&quot;sensor_gyro: x: %.2f y: %.2f z: %.2f\n&quot;</span>,</span><br><span class="line">                 (<span class="type">double</span>)sensor_gyro_data.x, (<span class="type">double</span>)sensor_gyro_data.y, (<span class="type">double</span>)sensor_gyro_data.z);</span><br><span class="line">        write(uart_read, buffer, <span class="built_in">strlen</span>(buffer));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 sensor_combined 数据</span></span><br><span class="line">    <span class="keyword">if</span> (orb_copy(ORB_ID(sensor_combined), sensor_combined_sub, &amp;sensor_combined_data) == PX4_OK) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;sensor_combined: accel: %.2f %.2f %.2f gyro: %.2f %.2f %.2f\n&quot;</span>,</span><br><span class="line">               (<span class="type">double</span>)sensor_combined_data.accelerometer_m_s2[<span class="number">0</span>],</span><br><span class="line">               (<span class="type">double</span>)sensor_combined_data.accelerometer_m_s2[<span class="number">1</span>],</span><br><span class="line">               (<span class="type">double</span>)sensor_combined_data.accelerometer_m_s2[<span class="number">2</span>],</span><br><span class="line">               (<span class="type">double</span>)sensor_combined_data.gyro_rad[<span class="number">0</span>],</span><br><span class="line">               (<span class="type">double</span>)sensor_combined_data.gyro_rad[<span class="number">1</span>],</span><br><span class="line">               (<span class="type">double</span>)sensor_combined_data.gyro_rad[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">snprintf</span>(buffer, <span class="keyword">sizeof</span>(buffer), <span class="string">&quot;sensor_combined: accel: %.2f %.2f %.2f gyro: %.2f %.2f %.2f\n&quot;</span>,</span><br><span class="line">                 (<span class="type">double</span>)sensor_combined_data.accelerometer_m_s2[<span class="number">0</span>],</span><br><span class="line">                 (<span class="type">double</span>)sensor_combined_data.accelerometer_m_s2[<span class="number">1</span>],</span><br><span class="line">                 (<span class="type">double</span>)sensor_combined_data.accelerometer_m_s2[<span class="number">2</span>],</span><br><span class="line">                 (<span class="type">double</span>)sensor_combined_data.gyro_rad[<span class="number">0</span>],</span><br><span class="line">                 (<span class="type">double</span>)sensor_combined_data.gyro_rad[<span class="number">1</span>],</span><br><span class="line">                 (<span class="type">double</span>)sensor_combined_data.gyro_rad[<span class="number">2</span>]);</span><br><span class="line">        write(uart_read, buffer, <span class="built_in">strlen</span>(buffer));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 vehicle_attitude 数据（移除 timestamp，输出四元数 q）</span></span><br><span class="line">    <span class="keyword">if</span> (orb_copy(ORB_ID(vehicle_attitude), vehicle_attitude_sub, &amp;vehicle_attitude_data) == PX4_OK) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;vehicle_attitude: q: %.2f %.2f %.2f %.2f\n&quot;</span>,</span><br><span class="line">               (<span class="type">double</span>)vehicle_attitude_data.q[<span class="number">0</span>],</span><br><span class="line">               (<span class="type">double</span>)vehicle_attitude_data.q[<span class="number">1</span>],</span><br><span class="line">               (<span class="type">double</span>)vehicle_attitude_data.q[<span class="number">2</span>],</span><br><span class="line">               (<span class="type">double</span>)vehicle_attitude_data.q[<span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">snprintf</span>(buffer, <span class="keyword">sizeof</span>(buffer), <span class="string">&quot;vehicle_attitude: q: %.2f %.2f %.2f %.2f\n&quot;</span>,</span><br><span class="line">                 (<span class="type">double</span>)vehicle_attitude_data.q[<span class="number">0</span>],</span><br><span class="line">                 (<span class="type">double</span>)vehicle_attitude_data.q[<span class="number">1</span>],</span><br><span class="line">                 (<span class="type">double</span>)vehicle_attitude_data.q[<span class="number">2</span>],</span><br><span class="line">                 (<span class="type">double</span>)vehicle_attitude_data.q[<span class="number">3</span>]);</span><br><span class="line">        write(uart_read, buffer, <span class="built_in">strlen</span>(buffer));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    usleep(<span class="number">50000</span>); <span class="comment">// 50ms 延迟</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    PX4_WARN(<span class="string">&quot;[rw_uart] exiting.&quot;</span>);</span><br><span class="line">    thread_running = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    close(uart_read);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;UART close status: %d\n&quot;</span>, uart_read);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> rw-uart.c</span><br></pre></td></tr></table></figure><h2 id="3-4结果："><a href="#3-4结果：" class="headerlink" title="3.4结果："></a>3.4结果：</h2><p><img src="../images/PX4IMU_and_other_data_processing/image_nPUQZ91VhZ.png"></p><h1 id="PX4-源码中对二次开发比较重要的代码模块"><a href="#PX4-源码中对二次开发比较重要的代码模块" class="headerlink" title="PX4 源码中对二次开发比较重要的代码模块"></a>PX4 源码中对二次开发比较重要的代码模块</h1><p><a href="https://docs.px4.io/main/zh/msg_docs/VehicleAttitude.html" title="VehicleAttitude （UORB 消息） |PX4 指南 （main）">VehicleAttitude （UORB 消息） |PX4 指南 （main）</a></p><hr><h4 id="1-Commander"><a href="#1-Commander" class="headerlink" title="1. Commander"></a><strong>1. Commander</strong></h4><ul><li><p><strong>功能</strong> &#x20;</p><p>Commander 模块主要处理 PX4 的常用命令，例如：</p><ul><li>传感器校准</li><li>模式切换</li><li>加锁&#x2F;解锁</li><li>起飞&#x2F;降落</li><li>紧急断电等。</li></ul></li><li><p><strong>输入主题</strong> &#x20;</p><p><code>vehicle_command</code>：接收外部命令。</p></li><li><p><strong>输出主题</strong> &#x20;</p><p>根据不同的命令 ID，将命令分解为其他主题并发布出去，供其他模块响应。</p></li><li><p><strong>使用方式</strong> &#x20;</p><p>如果需要使用 Commander 模块的功能，可以在自己的程序代码中直接发布主题 <code>vehicle_command</code>。</p></li></ul><hr><h4 id="2-EKF2-Extended-Kalman-Filter-2"><a href="#2-EKF2-Extended-Kalman-Filter-2" class="headerlink" title="2. EKF2 (Extended Kalman Filter 2)"></a><strong>2. EKF2 (Extended Kalman Filter 2)</strong></h4><ul><li><p><strong>功能</strong> &#x20;</p><p>EKF2 模块负责传感器数据融合，包括 GPS、加速度计、指南针等数据的处理。</p></li><li><p><strong>输入参数</strong> &#x20;</p><p>输入由 PX4 的硬件驱动模块提供，开发者无需关心具体的输入主题。</p></li><li><p><strong>输出主题</strong> &#x20;</p><ul><li><code>vehicle_attitude</code>：当前飞控的姿态。</li><li><code>vehicle_local_position</code>：当前飞控的本地位置（NED 坐标系，以飞控启动时的初始点为原点）。</li><li><code>vehicle_global_position</code>：当前飞控的全球位置。</li></ul></li><li><p><strong>使用方式</strong> &#x20;</p><p>开发者可以直接订阅这些主题，EKF2 会保证数据的实时更新，无需关注具体硬件。</p></li></ul><hr><h4 id="3-MAVLink"><a href="#3-MAVLink" class="headerlink" title="3. MAVLink"></a><strong>3. MAVLink</strong></h4><ul><li><p><strong>功能</strong> &#x20;</p><p>MAVLink 模块负责 MAVLink 协议通信，解析来自飞控数传串口的数据，并将其分解为多个主题。</p></li><li><p><strong>输入</strong> &#x20;</p><p>来自飞控数传串口的 MAVLink 数据包。</p></li><li><p><strong>输出</strong> &#x20;</p><p>将 MAVLink 数据包解封后生成的主题。</p></li><li><p><strong>特点</strong> &#x20;</p><p>MAVLink 是 PX4 中最上层的模块之一，也是分析飞控的重点模块。</p></li></ul><hr><h4 id="4-MC-ATT-CONTROL-Multicopter-Attitude-Control"><a href="#4-MC-ATT-CONTROL-Multicopter-Attitude-Control" class="headerlink" title="4. MC_ATT_CONTROL (Multicopter Attitude Control)"></a><strong>4. MC_ATT_CONTROL (Multicopter Attitude Control)</strong></h4><ul><li><p><strong>功能</strong> &#x20;</p><p>MC_ATT_CONTROL 模块负责多旋翼飞行器的姿态控制。</p></li><li><p><strong>输入主题</strong> &#x20;</p><ul><li><code>vehicle_attitude_setpoint</code>：期望姿态信息。</li></ul></li><li><p><strong>输出主题</strong> &#x20;</p><ul><li><code>actuator_controls_0</code>：主混控器控制输出。</li><li>其他混控器控制组（<code>actuator_controls_1</code> 至 <code>actuator_controls_7</code>），分别对应 8 个混控器控制组。</li></ul></li><li><p><strong>混控器作用</strong> &#x20;</p><p>将期望姿态信息（roll, pitch, yaw）映射到实际的电机转速或舵机角度。</p></li><li><p><strong>注意事项</strong> &#x20;</p><p>不建议直接发布 <code>vehicle_attitude_setpoint</code> 主题，因为 PX4 中对此主题有完整的响应链。如果直接发布，可能导致与其他模块的冲突，进而影响飞行器稳定性。</p></li></ul><hr><h4 id="5-MC-POS-CONTROL-Multicopter-Position-Control"><a href="#5-MC-POS-CONTROL-Multicopter-Position-Control" class="headerlink" title="5. MC_POS_CONTROL (Multicopter Position Control)"></a><strong>5. MC_POS_CONTROL (Multicopter Position Control)</strong></h4><ul><li><p><strong>功能</strong> &#x20;</p><p>MC_POS_CONTROL 模块负责多旋翼飞行器的位置控制。</p></li><li><p><strong>输入主题</strong> &#x20;</p><ul><li><code>manual_control_setpoint</code>：遥控器的当前输入值（如油门打到 100%，对应的参数可能是 100）。</li><li><code>position_setpoint_triplet</code>：期望位置信息（本地坐标系 NED）。</li></ul></li><li><p><strong>输出主题</strong> &#x20;</p><ul><li><code>vehicle_attitude_setpoint</code>：作为 MC_ATT_CONTROL 模块的输入。</li></ul></li><li><p><strong>层级关系</strong> &#x20;</p><p>位置控制模块位于姿态控制模块之上，其输出作为姿态控制模块的输入。</p></li><li><p><strong>使用方式</strong> &#x20;</p><p>如果需要控制飞行器飞往某个位置，应发布主题 <code>position_setpoint_triplet</code>。此主题的来源包括：</p><ul><li>MAVLink 模块（地面站控制）。</li><li>Navigator 模块（AUTO 模式发起）。</li></ul></li><li><p><strong>注意事项</strong> &#x20;</p><p>不建议直接发布 <code>vehicle_attitude_setpoint</code>，以免与位置控制模块的输出冲突。</p></li></ul><hr><h4 id="6-Navigator"><a href="#6-Navigator" class="headerlink" title="6. Navigator"></a><strong>6. Navigator</strong></h4><ul><li><p><strong>功能</strong> &#x20;</p><p>Navigator 模块负责导航任务规划，例如 AUTO 模式下的路径规划和任务执行。</p></li><li><p><strong>输入主题</strong> &#x20;</p><ul><li>来自 MAVLink 或其他模块的任务指令。</li></ul></li><li><p><strong>输出主题</strong> &#x20;</p><ul><li><code>position_setpoint_triplet</code>：期望位置信息。</li></ul></li><li><p><strong>特点</strong> &#x20;</p><p>Navigator 模块是 AUTO 模式的核心模块，负责生成飞行任务的路径点。</p></li></ul><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在 PX4 的二次开发中，了解这些模块的功能、输入输出主题以及它们之间的层级关系非常重要。以下是一些关键点：</p><ol><li><strong>Commander</strong>：用于处理飞控命令。</li><li><strong>EKF2</strong>：提供传感器数据融合后的姿态和位置信息。</li><li><strong>MAVLink</strong>：负责通信协议解析。</li><li><strong>MC_ATT_CONTROL</strong>：实现姿态控制，避免直接发布 <code>vehicle_attitude_setpoint</code>。</li><li><strong>MC_POS_CONTROL</strong>：实现位置控制，推荐通过发布 <code>position_setpoint_triplet</code> 控制飞行器位置。</li><li><strong>Navigator</strong>：负责 AUTO 模式的任务规划。</li></ol><p>开发者可以根据需求选择合适的模块进行扩展或修改，同时注意保持与 PX4 系统的整体兼容性。</p>]]></content>
      
      
      
        <tags>
            
            <tag> PX4 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PX4&#92;&amp;RDKX5数据传输</title>
      <link href="/10.PX4&amp;RDKX5%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93/"/>
      <url>/10.PX4&amp;RDKX5%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93/</url>
      
        <content type="html"><![CDATA[<h1>PX4&amp;RDKX5数据传输</h1><h1>一、背景</h1><p>随着无人机技术的快速发展，其在物流、农业、巡检、搜救等领域的应用日益广泛。然而，为了实现更加智能和高效的飞行控制，无人机需要具备强大的数据处理能力和实时决策能力。传统的飞控系统（如PX4）虽然能够高效地完成基本的飞行任务，但在面对复杂环境或需要高级算法支持的任务时，其计算资源和算法扩展性可能显得不足。</p><p>为了解决这一问题，将机载电脑与飞控主控通过串口通信进行协同工作成为一种有效的解决方案。具体而言，飞控主控（如运行PX4固件的Pixhawk系列控制器）负责实时采集传感器数据（如IMU惯性测量单元、气压计、GPS等），并通过串口将这些数据传输到机载电脑。机载电脑则利用其更强的计算能力，对数据进行处理和分析，例如通过强化学习算法优化飞行策略、生成控制信号，或者进行扰动分析以提高系统的鲁棒性。最后，机载电脑将处理后的结果传回飞控主控，由主控执行具体的控制指令。</p><p>这种架构的优势在于：  </p><ol><li><strong>分工明确</strong>：飞控主控专注于实时性和稳定性要求高的任务，而机载电脑则负责复杂的计算和算法优化。 </li><li><strong>灵活性高</strong>：机载电脑可以根据需求加载不同的算法模块（如深度学习、强化学习等），从而实现多样化的功能扩展。  </li><li><strong>性能提升</strong>：通过引入先进的算法，无人机可以在复杂环境中表现出更高的智能化水平和适应性。</li></ol><h1>二 、技术实现路线</h1><h4 id="1-飞控主控的数据采集">1. <strong>飞控主控的数据采集</strong></h4><p>飞控主控基于PX4开源固件运行，能够实时采集多种传感器数据，包括但不限于：</p><ul><li>IMU数据（加速度计、陀螺仪、磁力计）</li><li>GPS定位信息</li><li>电机转速与姿态信息</li></ul><p>这些数据通过PX4的MAVLink协议或自定义串口协议传输到机载电脑。MAVLink是一种轻量级的消息传递协议，广泛用于无人机通信，具有高效、可靠的特点。</p><h4 id="2-串口通信的实现">2. <strong>串口通信的实现</strong></h4><p>飞控主控与机载电脑之间的通信可以通过UART（通用异步收发传输器）串口实现。以下是实现步骤：</p><ul><li><strong>配置PX4串口输出</strong>：在PX4的参数设置中，启用串口通信模块，并选择需要传输的数据类型（如IMU、姿态等）。</li><li><strong>机载电脑接收数据</strong>：在机载电脑上编写程序（RDKX5使用Python），通过串口读取飞控发送的数据。</li><li><strong>数据解析</strong>：解析接收到的数据包，提取所需的传感器信息。</li></ul><h4 id="3-机载电脑的数据处理">3. <strong>机载电脑的数据处理</strong></h4><p>机载电脑接收到传感器数据后，可以进行以下处理：</p><ul><li><strong>状态估计</strong>：结合IMU数据和GPS信息，使用卡尔曼滤波或扩展卡尔曼滤波（EKF）估计无人机的状态（位置、速度、姿态等）。</li><li><strong>强化学习训练</strong>：利用强化学习算法（如深度确定性策略梯度DDPG或近端策略优化PPO），根据当前状态生成最优控制策略。</li><li><strong>扰动分析</strong>：通过对传感器数据的分析，识别外部扰动（如风力影响），并设计补偿策略。</li></ul><h4 id="4-控制信号回传">4. <strong>控制信号回传</strong></h4><p>机载电脑将处理后的控制信号（如期望的姿态角、推力值）或扰动补偿信息通过串口传回飞控主控。飞控主控根据接收到的指令调整电机输出，从而实现闭环控制。</p><p>二 、技术实现路线</p><h1>三、应用场景</h1><ol><li><p>**稳定的水面滑行控制与自主导航避障  **</p><p>在复杂环境中，无人机需要实时感知周围障碍物并规划安全路径。通过强化学习算法，机载电脑可以生成最优避障策略，并将控制信号传回飞控主控。</p></li><li><p><strong>抗风能力增强</strong>  </p><p>在强风条件下，无人机容易受到外界扰动的影响。机载电脑可以通过分析IMU数据，识别风力方向和强度，并生成补偿信号，帮助无人机保持稳定飞行。</p></li><li><p><strong>多机协同</strong>  </p><p>在多无人机编队任务中，每架无人机的机载电脑可以通过强化学习算法协调彼此的动作，同时将控制信号下发给各自的飞控主控，实现高效的协同作业。</p></li></ol><hr><h1>四、总结</h1><p>通过将PX4飞控主控与机载电脑结合，利用串口通信实现数据交互，可以充分发挥两者的优势：飞控主控提供稳定的底层控制，机载电脑则负责复杂的算法处理和决策优化。这种架构不仅提升了无人机的智能化水平，还为其在复杂任务中的应用提供了更大的可能性。未来，随着强化学习、深度学习等技术的进一步发展，这种协同工作模式将在无人机领域发挥更加重要的作用。</p><h1>五 、具体文档</h1><p><a href="../_posts/11.PX4%E4%B8%B2%E5%8F%A3%E9%80%9A%E4%BF%A1.md" title="PX4串口通信">PX4串口通信</a></p><p><a href="../_posts/12.PX4IMU%E7%AD%89%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86.md" title="PX4IMU等数据处理">PX4IMU等数据处理</a></p><p><a href="../_posts/13.RDKX5.md" title="RDKX5">RDKX5</a></p><p><a href="../_posts/14.%E6%9C%BA%E8%BD%BD%E9%80%9A%E4%BF%A1.md" title="机载通信">机载通信</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> UAV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>H743发送串口程序</title>
      <link href="/9.H743%E5%8F%91%E9%80%81%E4%B8%B2%E5%8F%A3%E7%A8%8B%E5%BA%8F/"/>
      <url>/9.H743%E5%8F%91%E9%80%81%E4%B8%B2%E5%8F%A3%E7%A8%8B%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="H743发送串口程序"><a href="#H743发送串口程序" class="headerlink" title="H743发送串口程序"></a>H743发送串口程序</h1><p>首先<a href="https://so.csdn.net/so/search?q=pixhawk&spm=1001.2101.3001.7020">pixhawk</a> 4上面有四个串口，一个给了GPS，一个是TELEM1 一个是TELEM2 ，根据PX4用户指南，一般TELEM1插wifi数传，TELEM2插板载计算机。</p><p>插wifi数传和插板载计算机所用的串口实际都是传mavlink消息，所以telem1口和telem2口都是设置的MAV参数</p><p>添加串口传感器，比如tfmini这种串口的传感器，就只剩下<a href="https://so.csdn.net/so/search?q=UART&spm=1001.2101.3001.7020">UART</a>&amp;I2C B（飞控板上打印的是这个）这个串口了，也叫TELEM4</p><p>查看H743板上串口说明：</p><h3 id="与GPS连线：-5V，GND，R2，T2"><a href="#与GPS连线：-5V，GND，R2，T2" class="headerlink" title="与GPS连线：+5V，GND，R2，T2"></a>与GPS连线：+5V，GND，R2，T2</h3><h3 id="与罗盘连线：SCL-CL1-SDA-DA1"><a href="#与罗盘连线：SCL-CL1-SDA-DA1" class="headerlink" title="与罗盘连线：SCL CL1,SDA DA1"></a>与罗盘连线：SCL CL1,SDA DA1</h3><h3 id="与数传连线：-5V，GND，RX6，TX6"><a href="#与数传连线：-5V，GND，RX6，TX6" class="headerlink" title="与数传连线：+5V，GND，RX6，TX6"></a>与数传连线：+5V，GND，RX6，TX6</h3><p>禁用串口1（USART1）</p><p><img src="../images/uart/uart1.png"></p><p>通过QGC验证串口的有效发送PC(ttyS3)</p><p><img src="../images/uart/uart4.png"></p><p>打印Hello,UART!</p><p><img src="../images/uart/uart3.png"></p><h1 id="RDX-X5发送串口程序"><a href="#RDX-X5发送串口程序" class="headerlink" title="RDX X5发送串口程序"></a>RDX X5发送串口程序</h1><p>通过USBA进行串口转接<img src="../images/uart/uart2.png"></p><ul><li>运行 <code>python3 /app/40pin_samples/test_serial.py</code></li><li>从打印的串口设备（其中 &#x2F;dev&#x2F;ttyS0 是系统调试口，不建议对它进行测试，除非你完全明白它的作用）中选择总线号和片选号作为输入选项，例如 RDK X3 选择测试 <code>/dev/ttyS3</code>，RDK X5 选择测试 <code>/dev/ttyS1</code>，RDK Ultra 选择测试 <code>/dev/ttyS2</code> 按回车键确认，并输入波特率参数：（新建的ttyUSB*）</li></ul><p><img src="../images/uart/uart8.png"></p><p><img src="../images/uart/uart7.png"></p><h2 id="通信"><a href="#通信" class="headerlink" title="通信"></a>通信</h2><p>RDK5未插入USB前：</p><p><img src="../images/uart/uart6.png"></p><p>RDK5插入USB串口后：<img src="../images/uart/uart5.png"></p><p>编写USB0发送代码程序，波特率为57600，并设置为开机自启。</p><h3 id="RDK5发送程序："><a href="#RDK5发送程序：" class="headerlink" title="RDK5发送程序："></a>RDK5发送程序：</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">\<span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> signal</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> serial</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">signal_handler</span>(<span class="params">signal, frame</span>):</span><br><span class="line"></span><br><span class="line">  sys.exit(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">serialTest</span>():</span><br><span class="line"></span><br><span class="line">  uart_dev = <span class="string">&#x27;/dev/ttyUSB0&#x27;</span>  <span class="comment"># 硬编码为串口设备 /dev/ttyUSB0</span></span><br><span class="line"></span><br><span class="line">  baudrate = <span class="number">57600</span>  <span class="comment"># 硬编码波特率为57600</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">f&quot;Attempting to open serial port <span class="subst">&#123;uart_dev&#125;</span> with baud rate <span class="subst">&#123;baudrate&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span>:</span><br><span class="line"></span><br><span class="line">​    ser = serial.Serial(uart_dev, baudrate, timeout=<span class="number">1</span>)  <span class="comment"># 1秒超时</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">except</span> serial.SerialException <span class="keyword">as</span> e:</span><br><span class="line"></span><br><span class="line">​    <span class="built_in">print</span>(<span class="string">f&quot;Failed to open serial port <span class="subst">&#123;uart_dev&#125;</span>: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">return</span> -<span class="number">1</span>  <span class="comment"># 打开串口失败</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">f&quot;Serial port <span class="subst">&#123;uart_dev&#125;</span> opened successfully&quot;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;Starting demo now! Press CTRL+C to exit&quot;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"></span><br><span class="line">​    test_data = <span class="string">&quot;AA55&quot;</span>  <span class="comment"># 要发送的数据</span></span><br><span class="line"></span><br><span class="line">​    <span class="keyword">try</span>:</span><br><span class="line"></span><br><span class="line">​      write_num = ser.write(test_data.encode(<span class="string">&#x27;UTF-8&#x27;</span>))  <span class="comment"># 发送数据</span></span><br><span class="line"></span><br><span class="line">​      <span class="built_in">print</span>(<span class="string">&quot;Send:&quot;</span>, test_data)</span><br><span class="line"></span><br><span class="line">​      \<span class="comment"># 读取返回的数据</span></span><br><span class="line"></span><br><span class="line">​      received_data = ser.read(write_num).decode(<span class="string">&#x27;UTF-8&#x27;</span>)</span><br><span class="line"></span><br><span class="line">​      <span class="built_in">print</span>(<span class="string">&quot;Recv:&quot;</span>, received_data)</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">except</span> serial.SerialException <span class="keyword">as</span> e:</span><br><span class="line"></span><br><span class="line">​      <span class="built_in">print</span>(<span class="string">f&quot;Serial communication error: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">​      <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">​    time.sleep(<span class="number">1</span>)  <span class="comment"># 每隔1秒发送一次</span></span><br><span class="line"></span><br><span class="line">  ser.close()  <span class="comment"># 关闭串口</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line"></span><br><span class="line">  signal.signal(signal.SIGINT, signal_handler)  <span class="comment"># 设置Ctrl+C退出时的处理函数</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> serialTest() != <span class="number">0</span>:</span><br><span class="line"></span><br><span class="line">​    <span class="built_in">print</span>(<span class="string">&quot;Serial test failed!&quot;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line"></span><br><span class="line">​    <span class="built_in">print</span>(<span class="string">&quot;Serial test success!&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="开机自启动设置："><a href="#开机自启动设置：" class="headerlink" title="开机自启动设置："></a>开机自启动设置：</h3><h4 id="步骤-1：安装-cron-包"><a href="#步骤-1：安装-cron-包" class="headerlink" title="步骤 1：安装 cron 包"></a>步骤 1：安装 <code>cron</code> 包</h4><ol><li><p>更新包列表：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt update</span><br></pre></td></tr></table></figure></li><li><p>安装 <code>cron</code> 包：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install cron</span><br></pre></td></tr></table></figure></li></ol><h4 id="步骤-2：启动-cron-服务"><a href="#步骤-2：启动-cron-服务" class="headerlink" title="步骤 2：启动 cron 服务"></a>步骤 2：启动 <code>cron</code> 服务</h4><p>安装完 <code>cron</code> 后，您需要确保 <code>cron</code> 服务正在运行：</p><ol><li><p>启动并启用 <code>cron</code> 服务：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl start cron</span><br><span class="line"><span class="built_in">sudo</span> systemctl <span class="built_in">enable</span> cron</span><br></pre></td></tr></table></figure></li><li><p>检查 <code>cron</code> 服务状态：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl status cron</span><br></pre></td></tr></table></figure><p>如果服务启动正常，您应该看到类似以下的输出：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">● cron.service - Regular background program processing daemon</span><br><span class="line">   Loaded: loaded (/lib/systemd/system/cron.service; enabled; vendor preset: enabled)</span><br><span class="line">   Active: active (running) since ...</span><br><span class="line">   ...</span><br></pre></td></tr></table></figure></li></ol><h4 id="步骤-3：再次编辑-crontab"><a href="#步骤-3：再次编辑-crontab" class="headerlink" title="步骤 3：再次编辑 crontab"></a>步骤 3：再次编辑 crontab</h4><p>现在，您应该能够使用 <code>crontab</code> 命令了：</p><ol><li><p>以 root 用户身份编辑 crontab：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> crontab -e</span><br></pre></td></tr></table></figure></li><li><p>然后按照之前的步骤，在 <code>crontab</code> 文件中添加：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@reboot /usr/bin/python3 /app/40pin_samples/my_serial.py</span><br></pre></td></tr></table></figure></li><li><p>保存并退出编辑器。</p></li></ol><h4 id="步骤-4：验证是否生效"><a href="#步骤-4：验证是否生效" class="headerlink" title="步骤 4：验证是否生效"></a>步骤 4：验证是否生效</h4><p>重新启动您的机器：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> reboot</span><br></pre></td></tr></table></figure><p>在系统重新启动后，您的脚本应该会自动运行。如果需要查看 <code>cron</code> 的执行日志，可以检查系统日志：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> journalctl -u cron</span><br></pre></td></tr></table></figure><p>这样，您的脚本就应该会在系统启动时自动执行了。</p><h4 id="步骤-1：确认脚本是否在-cron-作业中执行"><a href="#步骤-1：确认脚本是否在-cron-作业中执行" class="headerlink" title="步骤 1：确认脚本是否在 cron 作业中执行"></a>步骤 1：确认脚本是否在 <code>cron</code> 作业中执行</h4><p>首先，确认 <code>cron</code> 作业是否确实执行了您的脚本，您可以在 <code>cron</code> 作业中添加调试输出，帮助确认是否进入了执行阶段。</p><ol><li><p><strong>修改 <code>cron</code> 作业，添加调试信息：</strong></p><p>打开 <code>crontab</code> 编辑器并修改您的作业，在日志文件中添加更多的调试信息：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bash</span><br><span class="line"></span><br><span class="line"><span class="built_in">sudo</span> crontab -e</span><br></pre></td></tr></table></figure><p>将 <code>@reboot</code> 作业修改为以下内容：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bash</span><br><span class="line">@reboot <span class="built_in">echo</span> <span class="string">&quot;Cron job started at <span class="subst">$(date)</span>&quot;</span> &gt;&gt; /var/log/my_serial.log</span><br><span class="line">@reboot /usr/bin/python3 /app/40pin_samples/my_serial.py &gt;&gt; /var/log/my_serial.log 2&gt;&amp;1</span><br></pre></td></tr></table></figure><p>这会在每次重启后将当前时间（通过 <code>$(date)</code> 获取）添加到日志文件中，帮助您确认是否执行了 <code>cron</code> 作业。</p></li><li><p><strong>保存并退出 <code>crontab</code> 编辑器</strong>。</p></li><li><p><strong>重新启动系统</strong>：</p><p>执行以下命令重启系统并触发 <code>@reboot</code> 作业：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bash</span><br><span class="line"><span class="built_in">sudo</span> reboot</span><br></pre></td></tr></table></figure></li><li><p><strong>查看日志文件</strong>：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bash</span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">cat</span> /var/log/my_serial.log</span><br></pre></td></tr></table></figure><p>如果 <code>cron</code> 作业执行了，您应该能看到类似以下的内容：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">text</span><br><span class="line">Cron job started at Wed Jan  9 17:17:01 UTC 2025</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> UAV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>无人水空两用飞行器水中出水特性预测方法研究</title>
      <link href="/8.%E6%97%A0%E4%BA%BA%E6%B0%B4%E7%A9%BA%E4%B8%A4%E7%94%A8%E9%A3%9E%E8%A1%8C%E5%99%A8%E6%B0%B4%E4%B8%AD%E5%87%BA%E6%B0%B4%E7%89%B9%E6%80%A7%E9%A2%84%E6%B5%8B%E6%96%B9%E6%B3%95%E7%A0%94%E7%A9%B6/"/>
      <url>/8.%E6%97%A0%E4%BA%BA%E6%B0%B4%E7%A9%BA%E4%B8%A4%E7%94%A8%E9%A3%9E%E8%A1%8C%E5%99%A8%E6%B0%B4%E4%B8%AD%E5%87%BA%E6%B0%B4%E7%89%B9%E6%80%A7%E9%A2%84%E6%B5%8B%E6%96%B9%E6%B3%95%E7%A0%94%E7%A9%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="无人水空两用飞行器水中出水特性预测方法研究"><a href="#无人水空两用飞行器水中出水特性预测方法研究" class="headerlink" title="无人水空两用飞行器水中出水特性预测方法研究"></a>无人水空两用飞行器水中出水特性预测方法研究</h1><h3 id="论文分析与创新点"><a href="#论文分析与创新点" class="headerlink" title="论文分析与创新点"></a>论文分析与创新点</h3><p>这篇论文《无人水空两用飞行器水中出水特性预测方法研究》主要探讨了无人水空两用飞行器（UAUV）的水中出水过程，并提出了一种高效的预测方法。以下是论文的主要创新点和工作内容：</p><ol><li><p><strong>引入接力计算方法</strong>：论文提出了一种接力计算方法（RCM），用于模拟UAUV的出水和飞行过程。该方法结合了计算流体动力学（CFD）和动态模型，实现了从水-空气界面跨越到空气飞行的全过程模拟。这一方法解决了传统预测方法效率低的问题，能够在较短时间内完成复杂环境下的准确预测。</p></li><li><p><strong>捕获并描述附着水状态</strong>：首次引入了捕获UAUV附着水状态的方法，利用非线性自回归模型（NARX）描述附着水状态的变化。这一创新解决了现有数学模型和实验方法难以捕获附着水状态特征的问题，为进一步研究附着水对飞行器的影响提供了基础。</p></li><li><p><strong>高效气动系数识别方法</strong>：论文采用高斯过程回归模型（GPR）对气动系数进行了高效识别。通过CFD计算生成的数据集，建立了运动参数与气动力系数之间的关系，实现了无需详细研究气动模型结构就能准确描述复杂非线性关系的目标。</p></li><li><p><strong>验证与实验结合</strong>：通过实验池测试和CFD模拟结果进行对比验证，确保了接力计算方法的准确性和可靠性。这一验证过程展示了RCM在不同初始条件下预测UAUV出水和飞行过程的可行性和精确性。</p></li></ol><h3 id="主要工作内容"><a href="#主要工作内容" class="headerlink" title="主要工作内容"></a>主要工作内容</h3><ul><li>设计了带有可折叠翼的UAUV并进行了相关模拟研究。</li><li>通过CFD方法模拟UAUV跨越水-空气界面的瞬态力和运动状态。</li><li>利用动态模型计算UAUV出水后的飞行状态，并综合考虑高攻角、附着水、螺旋桨推力、翼展等多种因素。</li><li>提出了分离和捕获附着水状态的方法，并通过神经网络模型进行训练和预测。</li><li>进行了实验池测试，验证了模拟结果的准确性。</li></ul><h3 id="借鉴之处"><a href="#借鉴之处" class="headerlink" title="借鉴之处"></a>借鉴之处</h3><ul><li><strong>接力计算方法的应用</strong>：可将RCM应用于其他复杂环境下的跨介质运动模拟，提升计算效率和准确性。</li><li><strong>附着水状态捕获技术</strong>：这项技术可以推广应用到其他涉及流体附着现象的工程领域，如海洋工程和航空航天领域。</li><li><strong>高效气动系数识别方法</strong>：高斯过程回归模型的应用能够提高复杂非线性系统的建模精度，对于需要快速迭代设计的新型飞行器非常有用。</li></ul><h3 id="详细讨论表格"><a href="#详细讨论表格" class="headerlink" title="详细讨论表格"></a>详细讨论表格</h3><table><thead><tr><th>序号</th><th>论文标题</th><th>主要创新点</th><th>引用次数</th></tr></thead><tbody><tr><td>1</td><td><a href="https://doi.org/10.1016/j.oceaneng.2024.117403">无人水空两用飞行器水中出水特性预测方法研究 (Xiangren Sun et al., 2024)</a></td><td>提出接力计算方法，实现高效准确的水-空气跨越过程模拟；引入附着水状态捕获方法，采用NARX模型描述附着水状态变化。</td><td>-</td></tr></tbody></table><h4 id="用户还问了这些问题："><a href="#用户还问了这些问题：" class="headerlink" title="用户还问了这些问题："></a>用户还问了这些问题：</h4><ol><li>什么是高斯过程回归模型，它在气动系数识别中的作用是什么？</li><li>论文中提到的附着水状态捕获方法能否应用于其他类型的飞行器？</li><li>接力计算方法在其他跨介质运动模拟中的潜在应用有哪些？</li></ol><h3 id="论文分析与创新点-1"><a href="#论文分析与创新点-1" class="headerlink" title="论文分析与创新点"></a>论文分析与创新点</h3><p>这篇论文《基于三维流场瞬态CFD的倾转旋翼无人机动态建模与控制》主要探讨了倾转旋翼无人机（TRUAV）的动态建模和控制方法。以下是论文的主要创新点和工作内容：</p><h3 id="主要创新点"><a href="#主要创新点" class="headerlink" title="主要创新点"></a>主要创新点</h3><ol><li><p><strong>瞬态CFD数值模拟</strong>：论文首次应用了瞬态计算流体力学（CFD）数值模拟，详细分析了TRUAV在过渡模式下机身和旋翼的流场分布及其气动扰动。这种方法能够捕捉复杂的流场变化，提供了精确的气动参数，为动态建模提供了基础。</p></li><li><p><strong>动态建模</strong>：基于倾转角状态变化，建立了TRUAV的非稳态动力学模型。该模型考虑了旋翼滑流的影响，并分析了在机身和旋翼气动扰动下的三维流场分布。通过识别各个气动参数，完善了模型的精确性。</p></li><li><p><strong>级联PID控制策略</strong>：设计了一种级联PID控制策略，用于TRUAV的控制。仿真结果表明，该控制策略能够在最大滚转角为20度的情况下保持TRUAV的稳定性，为TRUAV的控制方法提供了有效的解决方案。</p></li></ol><h3 id="主要工作内容-1"><a href="#主要工作内容-1" class="headerlink" title="主要工作内容"></a>主要工作内容</h3><ul><li><strong>CFD数值模拟</strong>：通过瞬态CFD数值模拟，分析了TRUAV在不同倾转角下的流场分布及其气动扰动，获取了建模所需的气动参数。</li><li><strong>动力学模型建立</strong>：基于CFD模拟结果，建立了TRUAV的非稳态动力学模型，考虑了旋翼滑流和机身气动扰动的影响。</li><li><strong>控制策略设计</strong>：提出了级联PID控制策略，通过Matlab Simulink进行仿真验证，证明了控制策略的有效性。</li><li><strong>仿真与实验验证</strong>：进行了多种工况下的仿真与实验，验证了模型和控制策略的准确性和可靠性。</li></ul><h3 id="借鉴之处-1"><a href="#借鉴之处-1" class="headerlink" title="借鉴之处"></a>借鉴之处</h3><ol><li><strong>应用瞬态CFD方法</strong>：在涉及复杂流场变化的研究中，可以借鉴该论文的方法，使用瞬态CFD数值模拟来获取精确的气动参数。</li><li><strong>动态建模方法</strong>：该论文的动态建模方法考虑了多种气动扰动因素，提供了一个详细的建模框架，可以应用于其他类似复杂系统的建模研究中。</li><li><strong>级联PID控制策略</strong>：级联PID控制策略在保持系统稳定性方面表现出色，可以应用于其他需要精确控制的无人机或飞行器系统中。</li></ol><h3 id="详细讨论表格-1"><a href="#详细讨论表格-1" class="headerlink" title="详细讨论表格"></a>详细讨论表格</h3><table><thead><tr><th>序号</th><th>论文标题</th><th>主要创新点</th><th>引用次数</th></tr></thead><tbody><tr><td>1</td><td><a href="https://doi.org/10.3390/drones6110338">基于三维流场瞬态CFD的倾转旋翼无人机动态建模与控制 (Hongpeng Wang et al., 2022)</a></td><td>应用瞬态CFD数值模拟分析TRUAV的流场分布，建立基于倾转角状态变化的非稳态动力学模型，设计级联PID控制策略。</td><td>-</td></tr></tbody></table><h4 id="用户还问了这些问题：-1"><a href="#用户还问了这些问题：-1" class="headerlink" title="用户还问了这些问题："></a>用户还问了这些问题：</h4><ol><li>什么是瞬态CFD数值模拟，它在气动分析中的优势是什么？</li><li>级联PID控制策略与传统PID控制相比有哪些优势？</li><li>如何在实际应用中验证瞬态CFD模拟结果的准确性？</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> UAV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mission Planner使用</title>
      <link href="/6.Mission%20Planner/"/>
      <url>/6.Mission%20Planner/</url>
      
        <content type="html"><![CDATA[<h1 id="Mission-Planner使用"><a href="#Mission-Planner使用" class="headerlink" title="Mission Planner使用"></a>Mission Planner使用</h1><h3 id="界面："><a href="#界面：" class="headerlink" title="界面："></a>界面：</h3><ul><li>端口连接，使用数据线为115200波特率；使用数传时为57600波特率。</li></ul><h3 id="初始设置："><a href="#初始设置：" class="headerlink" title="初始设置："></a>初始设置：</h3><ul><li>安装固件；需要断开连接下加载。</li></ul><h3 id="遥控器校准设置："><a href="#遥控器校准设置：" class="headerlink" title="遥控器校准设置："></a>遥控器校准设置：</h3><ul><li><p>电调断电，移动遥控器所有拨杆，注意右摇杆，上拉减小，下拉增大；其他正常，如左油门通道，上拉增大，下拉减小，右拉增大，左拉减小。</p></li><li><p>检查第五通道对应遥控器哪个开关，第五通道一般对应飞行模式的切换。</p></li><li><p>校准完成后，油门摇杆处于最低位，其他摇杆处于中位。</p></li></ul><h3 id="电调校准设置："><a href="#电调校准设置：" class="headerlink" title="电调校准设置："></a>电调校准设置：</h3><ul><li>更换了遥控器，在校准遥控器后；更换了电调;更换了新飞控, 或者飞控参数还原后需要对电调油门进行校准。</li><li>电调校准步骤是以常用的BLHELI_S电调为例，其它品牌的电调差别不大，校准失败。把油门杆拉到最低，接上电源，正常开机后再拔掉电源，从步骤1重新开始:<ol><li>拆掉螺旋桨；</li><li>无人机不要接电池, 飞控不要接USB，打开遥控器开关，把油门摇杆推到最高;</li><li>无人机接上电池, 等待系统初始化、飞控上的灯会出现红、绿、蓝三色交替 闪烁循环模式。油门杆保持最高位置不要动;</li><li>拔掉无人机电池, 此时油门杆还是保持最高位置不要动;</li><li>再接上无人机电池 (继续出现红绿蓝交替闪烁) , 电机发出一阵音乐声后, 把遥控器油门杆拉到最低, 等1 秒后会电机再次发出一阵音乐声;</li><li>拔掉无人机电池电源线, 校准油门行程成功, 正常启动无人机后, 解锁无人机, 观察急速情况, 电机转速是否转速一致。</li></ol></li></ul><h3 id="磁罗盘校准设置："><a href="#磁罗盘校准设置：" class="headerlink" title="磁罗盘校准设置："></a>磁罗盘校准设置：</h3><ul><li><p>注意事项</p><ol><li>为了避免室内电器磁场干扰尽量去室外校准；</li><li>为了安全起见校准时务必摘掉螺旋桨。</li></ol></li><li><p>校准磁罗盘一共有两种触发方式</p><ol><li>直接通过遥控器摇杆来触发校准, 优点是不用连接地面站就可以校准, 操作简 单, 一般都用这种方式, 尤其是在外场飞行的时候;</li><li>采用无线数传方式通过地面站进行校准 (不建议通过USB线)，优点是可以在 地面站软件上看到实时校准状态（初始设置-指南针-start-六个面分别顺时针旋转一周）。</li></ol></li></ul><h3 id="飞行模式："><a href="#飞行模式：" class="headerlink" title="飞行模式："></a>飞行模式：</h3><ul><li><p>各项飞行模式：</p><ol><li>手动模式 (Manual)：这是一种基本模式，没有自动稳定。对于固定翼无人机，飞行员需要直接控制舵面来控制飞机的方向和高度。对于多轴飞行器，飞行员需要控制马达的速度来控制飞行器的姿态和高度。</li><li>圆周飞行模式 (Circle)：在此模式下，无人机会自动在一个直径为100米的圆圈上飞行，无需额外的飞行员输入。</li><li>自稳模式 (Stabilize)：此模式会自动稳定无人机的姿态，但是无人机的高度和位置需要飞行员手动控制。</li><li>训练模式 (Training)：此模式是为了帮助新的飞行员学习如何操控无人机而设计的。在此模式下，飞行员可以自由操控无人机，但如果飞行员放开所有的控制，无人机会自动回到水平姿态。</li><li>特技飞行模式 (Acro)：这是一种用于做空中特技的飞行模式，需要飞行员具备高水平的技巧。</li><li>FBWA模式 (Fly-By-Wire A)：此模式将会保持无人机的俯仰角度和横滚角度在设定的范围内。</li><li>FBWB模式 (Fly-By-Wire B)：此模式和FBWA类似，但它会额外保持无人机的高度。</li><li>巡航模式 (Cruise)：这是一种混合模式，它会保持无人机的高度和速度。</li><li>自动调参模式 (Autotune)：这是一种用于自动调节无人机控制参数的模式。</li><li>自动模式 (Auto)：在此模式下，无人机会按照预设的航点自动飞行。</li><li>返回起飞点模式 (Return-To-Launch, RTL)：在此模式下，无人机会自动返回起飞点。</li><li>漂移模式 (Loiter)：在此模式下，无人机会在当前位置打转，直到接收到新的指令。</li><li>自动起飞模式 (Takeoff)：无人机将自动起飞并攀升到指定的高度。</li><li>避让ADSB模式 (Avoid ADSB)：这个模式让无人机能够避免那些使用ADSB广播他们位置的其他飞行器。</li><li>导航模式 (Guided)：在此模式下，无人机会飞往你通过地面控制站指定的GPS位置。</li></ol></li><li><p>以下是四旋翼和垂直起降(VTOL)无人机设计的飞行模式：</p><ol><li>四轴稳定模式 (QStabilize)：这是四旋翼模式下的稳定模式。</li><li>四轴悬停模式 (QHover)：在此模式下，无人机会自动保持高度。</li><li>四轴漂移模式 (QLoiter)：类似于漂移模式，但是是在四旋翼模式下，无人机会在当前位置打转，直到接收到新的指令。</li><li>四轴着陆模式 (QLand)：无人机会自动在四旋翼模式下降落。</li><li>四轴返回起飞点模式 (QRTL)：这是在四旋翼模式下的返回起飞点模式。</li><li>四轴自动调参模式 (QAutotune)：这是在四旋翼模式下的自动调节参数模式。</li><li>四轴特技飞行模式 (QAcro)：这是四旋翼模式下的特技飞行模式。</li><li>利用热气流上升模式 (Thermal)：在此模式下，无人机会利用热气流来上升，这在滑翔机中特别有用。</li><li>漂移至四轴着陆模式 (Loiter to QLand)：无人机会在当前位置盘旋，然后在四旋翼模式下降落。</li><li>初始化模式 (Initialising)：这不是一个飞行模式，而是无人机启动和进行自我检查的阶段。</li></ol></li><li><p>常用的飞行模式，一般设置飞行模式的通道为1，4，6：</p></li></ul><ol><li><p>自稳模式 (Stabilize)</p><ul><li><p>自稳模式是使用最多、最基本的飞行模式。 </p></li><li><p>自稳模式不会依靠气压计定高和GPS定点。 自稳模式下，油门的大小直接控制电机的转速。 </p></li><li><p>自稳模式没有气压计和GPS的介入，外界环境不会对无人机造成过多的干扰。</p></li></ul></li><li><p>定高模式 (Althold) （对应大疆的无人机姿态模式）</p><ul><li><p>定高模式是通过计算飞控里气压计测量的气压值，经过算法处理，控制电机转 速来保持目前高度的稳定；</p></li><li><p>定高模式下油门摇杆中间有一个油门死区，油门动作幅度超过这个死区时，无 人机才会响应你的升降动作；</p></li><li><p>定高模式下油门大小对应无人机的爬上率;</p></li><li><p>定高模式下油门超过 ( 50 % ) ，无人机上升；油门越高，上升越快；低于50%，无 人机下降；油门越低，下降越快。处于 ( 50 % ) 时，保持当前高度不变；</p></li><li><p>在切换到自稳模式时，一定要注意随时调节油门大小，以免造成操作失误。</p></li></ul></li><li><p>悬停模式 (Loiter) (GPS模式)</p><ul><li>悬停模式是通过GPS定点+气压计定高的综合模式；</li><li>悬停模式需要在起飞前先让GPS定位（在室外空旷处，飞控LED指示灯变成绿 色）;</li><li>悬停模式下，油门超过 ( 50 % ) ，无人机起飞。油门摇杆回到50%，无人机悬停不 动。高于 ( 50 % ) ，缓慢升高，低于 ( 50 % ) ，缓慢下降。适合航拍等需要稳定飞行的 情况;</li><li>悬停模式下，新手操作使用比较容易，操作者也可以通过遥控器控制前后左右 等方向。</li></ul></li></ol><h3 id="飞行前检查和故障排除："><a href="#飞行前检查和故障排除：" class="headerlink" title="飞行前检查和故障排除："></a>飞行前检查和故障排除：</h3><ul><li><p>硬件检查：</p><ol><li>检查无人机上的各零部件和接线是否有松动；</li><li>检查机械结构和连接线材是否有损坏，包括螺旋桨;</li><li>检查螺丝是否有送松动，长时间运输和飞行可能会导致部分螺丝松动;</li><li>检查电机是否安装水平，摔过的无人机可能会造成电机座倾斜；</li><li>检查无人机电池是否满电，遥控器电池是否电量充足，起飞前建议都要充满电;</li><li>检查GPS支架是否竖起来，GPS方向是否和无人机机头一致； (如果有GPS)</li><li>在确保无人机可以正常起飞之前先不要安装螺旋桨；</li></ol></li><li><p>软件检查：</p><ol><li>检查飞控自检是否正常；</li><li>检查飞控指示灯是否闪烁正常，正常为蓝色闪烁；GPS定位后为绿色闪烁，如果出现黄色闪烁或者其他颜色，请查看地面站提示信息；</li><li>检查飞控姿态是否水平，如果不水平，请校准加速度计水平；</li><li>拨动遥控器第五通道检查飞行模式是否可以切换成功;</li><li>手持无人机垂直上下移动，检查爬升率和高度数据是否正常;</li><li>检查偏航角度 (无GPS时可以忽略)，指向正北时角度在0°附近，如果角度偏差大，请校准磁罗盘。</li></ol></li><li><p>解锁检查:左侧摇杆拨到右下角 3 秒无人机解锁，拨到左下角无人机上锁，解锁状态下10秒油门保持最低不动，无人机自动上锁。</p><ol><li>不装桨进行地面解锁和上锁测试是否正常；</li><li>自稳模式下解锁，推动油门检查电机转动随油门变化是否正常；</li><li>如果是第一次飞行，还需检查下电机转向是否正确;</li><li>定高模式下解锁，推动油门到 ( 50 % ) 以上，电机缓慢加速到全速旋转，定高模式 下，在没有安装螺旋桨时电机不会像自稳模式反应那么迅速。（因为飞控检测到 无人机高度并没有升高，所以飞控会让电机全速旋转起飞)</li></ol></li><li><p>故障排除：</p><ol><li>无法解锁: 首先检查遥控器是否打开，接收机是否亮灯，接收机模式是否正确 (紫色S.BUS，红色PWM)，接收机与遥控器是否对频，接收机信号线是否断路， 经常插拔可能会造成信号线损坏；解锁时检查地面站提示什么信息，是否是因为没有校准某些项目导致无法解锁;</li><li>起飞还未离地时严重往某个方向倒，甚至翻车: 检查电调信号线接到飞控的线序M1-M4，检查电机旋转方向，检查螺旋桨安装方向；</li><li>起飞后无人机在飞行中往某个方向偏的厉害: 检查姿态是否水平; 检查遥控器微调按钮是否不在中位。</li><li>电机旋转异常，解锁后有异响，转动卡顿: 检查电机内部是否有异物，因为电机内有磁铁，很容易吸附一些金属碎屑; 一些学生在进行拆装训练时，使用长螺丝固定电机，会把电机的线圈顶坏，电机转动也会出现卡顿现象;</li><li>定高模式下，高度不能很好的保持：检查螺旋桨是否有损坏缺口，飞控减震球是否有损坏，造成动平衡差，无人机震动大，震动过大会导致飞控加速度计Z轴噪声大，会影响到无人机定高。</li><li>部分电机不转: 检查电调信号线是否接好，电调是否校准过，试着把此路电调信号线接到正常的接口上测试。</li><li>飞行时无人机出现抖动现象：检查PID参数，可能因为PID参数过大导致。</li></ol></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> UAV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ardupilot开发</title>
      <link href="/7.ardupilot%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/"/>
      <url>/7.ardupilot%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/</url>
      
        <content type="html"><![CDATA[<h1 id="ardupilot开发"><a href="#ardupilot开发" class="headerlink" title="ardupilot开发"></a>ardupilot开发</h1><h2 id="固件选择"><a href="#固件选择" class="headerlink" title="固件选择"></a>固件选择</h2><p>ArduPilot是一个开源、无人驾驶的硬件和软件平台，广泛应用于多旋翼飞行器、固定翼飞机、陆地车辆和水面船只等。SpeedyBeeF405WING是一个特定型号的飞行控制器，它支持ArduPilot固件。</p><ul><li>ardupilot: SpeedyBeeF405WING-antennatracker：&#x3D;&#x3D;这是一个用于无线电天线跟踪的固件。&#x3D;&#x3D;</li><li>ardupilot: SpeedyBeeF405WING-bootloader：&#x3D;&#x3D;这是引导加载器，用于初始化硬件并加载主固件&#x3D;&#x3D;。</li><li>ardupilot: SpeedyBeeF405WING-copter：&#x3D;&#x3D;这是一个多旋翼飞行器的固件&#x3D;&#x3D;。</li><li>ardupilot: SpeedyBeeF405WING-heli：&#x3D;&#x3D;这是一个用于直升机的固件&#x3D;&#x3D;。</li><li>ardupilot: SpeedyBeeF405WING-plane：&#x3D;&#x3D;这是一个用于固定翼飞机的固件&#x3D;&#x3D;。</li><li>ardupilot: SpeedyBeeF405WING-rover：&#x3D;&#x3D;这是一个用于陆地车辆的固件&#x3D;&#x3D;。</li><li>ardupilot: SpeedyBeeF405WING-sub：&#x3D;&#x3D;这是一个用于水下潜艇或水面船只的固件&#x3D;&#x3D;。</li></ul><h2 id="代码框架"><a href="#代码框架" class="headerlink" title="代码框架"></a>代码框架</h2><h3 id="Core-libraries"><a href="#Core-libraries" class="headerlink" title="Core libraries:"></a><strong>Core libraries:</strong></h3><ul><li><a href="https://github.com/ArduPilot/ardupilot/tree/master/libraries/AP_AHRS">AP_AHRS</a> - attitude estimation using DCM or EKF&#x3D;&#x3D;（使用 DCM 或 EKF 进行态度估计）&#x3D;&#x3D;</li><li><a href="https://github.com/ArduPilot/ardupilot/tree/master/libraries/AP_Common">AP_Common</a> - core includes required by all sketches and libraries&#x3D;&#x3D;（ 所有示例程序和库所需的核心包含文件）&#x3D;&#x3D;</li><li><a href="https://github.com/ArduPilot/ardupilot/tree/master/libraries/AP_Math">AP_Math</a> - various math functions especially useful for vector manipulation&#x3D;&#x3D;（各种数学函数，特别适用于向量操作）&#x3D;&#x3D;</li><li><a href="https://github.com/ArduPilot/ardupilot/tree/master/libraries/AC_PID">AC_PID</a> - PID(Proportional-Integral-Derivative) controller library&#x3D;&#x3D;（PID（比例-积分-微分）控制器库）&#x3D;&#x3D;</li><li><a href="https://github.com/ArduPilot/ardupilot/tree/master/libraries/AP_InertialNav">AP_InertialNav</a> - inertial navigation library for blending accelerometer inputs with gps and baro data&#x3D;&#x3D;（混合加速度计输入与GPS和气压计数据的惯性导航库）&#x3D;&#x3D;</li><li><a href="https://github.com/ArduPilot/ardupilot/tree/master/libraries/AC_AttitudeControl">AC_AttitudeControl</a> - ArduCopter’s control library includes various functions of attitude, position control based on PID control.&#x3D;&#x3D;（ArduCopter的控制库，包括基于PID控制的姿态和位置控制的各种函数）&#x3D;&#x3D;</li><li><a href="https://github.com/ArduPilot/ardupilot/tree/master/libraries/AC_WPNav">AC_WPNav</a> - waypoint navigation library&#x3D;&#x3D;（航点导航库）&#x3D;&#x3D;</li><li><a href="https://github.com/ArduPilot/ardupilot/tree/master/libraries/AP_Motors">AP_Motors</a> - multicopter and traditional helicopter motor mixing&#x3D;&#x3D;（多旋翼和传统直升机电机混合控制）&#x3D;&#x3D;</li><li><a href="https://github.com/ArduPilot/ardupilot/tree/master/libraries/RC_Channel">RC_Channel</a> - a library to more convert pwm input&#x2F;output from APM_RC into internal units such as angles&#x3D;&#x3D;（将APM_RC的PWM输入&#x2F;输出转换为角度等内部单位的库）&#x3D;&#x3D;</li><li><a href="https://github.com/ArduPilot/ardupilot/tree/master/libraries/AP_HAL">AP_HAL</a>, <a href="https://github.com/ArduPilot/ardupilot/tree/master/libraries/AP_HAL_ChibiOS">AP_HAL_ChibiOS</a>, <a href="https://github.com/ArduPilot/ardupilot/tree/master/libraries/AP_HAL_Linux">AP_HAL_Linux</a> - libraries to implement the “Hardware abstraction layer” which presents an identical interface to the high level code so that it can more easily be ported to different boards.&#x3D;&#x3D;（实现”硬件抽象层”的库，提供与高级代码相同的接口，以便更轻松地将其移植到不同的板子上）&#x3D;&#x3D;</li></ul><h3 id="Sensor-libraries"><a href="#Sensor-libraries" class="headerlink" title="Sensor libraries:"></a><strong>Sensor libraries:</strong></h3><ul><li><a href="https://github.com/ArduPilot/ardupilot/tree/master/libraries/AP_InertialSensor">AP_InertialSensor</a> - reads gyro and accelerometer data, perform calibration and provides data in standard units (deg&#x2F;s, m&#x2F;s) to main code and other libraries（读取陀螺仪和加速度计数据，进行校准，并将数据以标准单位（deg&#x2F;s、m&#x2F;s）提供给主代码和其他库）</li><li><a href="https://github.com/ArduPilot/ardupilot/tree/master/libraries/AP_RangeFinder">AP_RangeFinder</a> - sonar and ir distance sensor interfaced library（超声波和红外距离传感器接口库）</li><li><a href="https://github.com/ArduPilot/ardupilot/tree/master/libraries/AP_Baro">AP_Baro</a> - barometer interface library（气压计接口库）</li><li><a href="https://github.com/ArduPilot/ardupilot/tree/master/libraries/AP_GPS">AP_GPS</a> - gps interface library（GPS接口库）</li><li><a href="https://github.com/ArduPilot/ardupilot/tree/master/libraries/AP_Compass">AP_Compass</a> - 3-axis compass interface library（三轴磁罗盘接口库）</li><li><a href="https://github.com/ArduPilot/ardupilot/tree/master/libraries/AP_OpticalFlow">AP_OpticalFlow</a> - optical flow sensor interface library（光流传感器接口库）</li></ul><h3 id="Other-libraries"><a href="#Other-libraries" class="headerlink" title="Other libraries:"></a><strong>Other libraries:</strong></h3><ul><li><a href="https://github.com/ArduPilot/ardupilot/tree/master/libraries/AP_Mount">AP_Mount</a>, <a href="https://github.com/ArduPilot/ardupilot/tree/master/libraries/AP_Camera">AP_Camera</a>, <a href="https://github.com/ArduPilot/ardupilot/tree/master/libraries/AP_Relay">AP_Relay</a> - camera mount control library, camera shutter control libraries（摄像机云台控制库，用于控制摄像机云台的运动和姿态；摄像机快门控制库，用于控制摄像机的快门操作；继电器控制库，用于控制继电器的开关操作）</li><li><a href="https://github.com/ArduPilot/ardupilot/tree/master/libraries/AP_Mission">AP_Mission</a> - stores&#x2F;retrieves mission commands from eeprom（任务存储&#x2F;检索库，用于将任务指令存储到EEPROM中并从EEPROM中检索任务指令）</li><li><a href="https://github.com/ArduPilot/ardupilot/tree/master/libraries/AP_Buffer">AP_Buffer</a> - a simple FIFO buffer for use with inertial navigation（简单的FIFO（先进先出）缓冲区库，用于与惯性导航系统配合使用）</li></ul><h3 id="The-hal-reference"><a href="#The-hal-reference" class="headerlink" title="The hal reference"></a>The hal reference</h3><p>The most commonly used hal functions are:</p><ul><li>hal.console-&gt;printf() to print strings （打印字符串）</li><li>AP_HAL::millis() and AP_HAL::micros() to get the time since boot</li><li>hal.scheduler-&gt;delay() and hal.scheduler-&gt;delay_microseconds() to sleep for a short time</li><li>hal.gpio-&gt;pinMode(), hal.gpio-&gt;read() and hal.gpio-&gt;write() for accessing GPIO pins</li><li>I2C access via hal.i2c</li><li>SPI access via hal.spi</li></ul><h2 id="传感器通信"><a href="#传感器通信" class="headerlink" title="传感器通信"></a>传感器通信</h2><h3 id="I2C"><a href="#I2C" class="headerlink" title="I2C"></a>I2C</h3><ul><li>one master, many slaves possible（一个主人，多个从属可能）</li><li>a relatively simple protocol which is good for communicating over short-distances (i.e. less than 1m).（一种相对简单的协议，适用于短距离（即小于1m）的通信）</li><li>bus runs at 100kHz or 400kHz but the data rate is relatively low compared to other protocols.（总线以100kHz或400kHz运行，但与其他协议相比，数据速率相对较低）</li><li>only 4 pins are required (VCC, GND, SDA, SCL)（仅需 4 个引脚（VCC、GND、SDA、SCL））</li></ul><h3 id="SPI"><a href="#SPI" class="headerlink" title="SPI"></a>SPI</h3><ul><li>one master, one slave（一个主人，一个从属）</li><li>20Mhz+ speed meaning it is very fast especially compared to I2C（20Mhz+ 速度意味着它非常快，尤其是与 I2C 相比）</li><li>only works over short distances (10cm)（仅适用于短距离（10厘米））</li><li>requires at least 5 pins (VCC, GND, SCLK, Master-Out-Slave-In, Master-In-Slave-Out) + 1 slave select pin per slave（至少需要 5 个引脚（VCC、GND、SCLK、MOSI、MISO）+ 每个从站 1 个从选择引脚）</li></ul><h3 id="Serial-UART"><a href="#Serial-UART" class="headerlink" title="Serial &#x2F; UART"></a>Serial &#x2F; UART</h3><ul><li>one master, one slave（一个主人，一个从属）</li><li>character based protocol good for communicating over longer distances compared to I2C and SPI (i.e. 1m)（与 I2C 和 SPI（即 1m）相比，基于字符的协议适合在更长的距离上进行通信）</li><li>relatively fast at 57Kbps ~ 1.5Mbps（相对较快，57Kbps ~ 1.5Mbps）</li><li>at least 4 pins required (VCC, GND, TX, RX), plus 2 optional pins (Clear-To-Send, Clear-To-Receive（至少需要 4 个引脚（VCC、GND、TX、RX），外加 2 个可选引脚（清除发送、清除接收））</li></ul><h3 id="CAN-bus-with-UAVCAN"><a href="#CAN-bus-with-UAVCAN" class="headerlink" title="CAN bus with UAVCAN"></a>CAN bus with UAVCAN</h3><ul><li>multimaster bus, any node can initiate transmission of data when they need to（多主站总线，任何节点都可以在需要时启动数据传输）</li><li>packet based protocol for very long distances（基于数据包的超长距离协议）</li><li>high speed, typically 1 Mb (however only 50% of the bus bitrate can really be used without major collisions)（高速，通常为 1 Mb（但是只有 50% 的总线比特率可以真正使用而不会发生重大碰撞））</li><li>at least 3 pins required (GND, CAN HI, CAN LO). Optionally VCC can be used to power nodes（至少需要 3 个引脚（GND、CH、CL）。可选 VCC 可用于为节点供电）</li><li>point-to-point topology. Star or stubs topolgy is not advised（点对点拓扑。不建议使用星形或存根拓扑）</li><li>termination is required at each end of the bus（总线两端都需要端接）</li></ul><h2 id="ArduPilot-线程"><a href="#ArduPilot-线程" class="headerlink" title="ArduPilot 线程"></a>ArduPilot 线程</h2><h3 id="任务的调度"><a href="#任务的调度" class="headerlink" title="任务的调度"></a>任务的调度</h3><ul><li>idle task - called when there is nothing else to run（空闲任务 - 在没有其他要运行的任务时调用）</li><li>init - used to start up the system（init - 用于启动系统）</li><li>px4io - handle the communication with the PX4IO co-processor（PX4IO - 处理与 PX4IO 协处理器的通信）</li><li>hpwork - handle thread based PX4 drivers (mainly I2C drivers)（hpwork - 处理基于线程的 PX4 驱动程序（主要是 I2C 驱动程序））</li><li>lpwork - handle thread based low priority work (eg. IO)（处理基于线程的低优先级工作（例如。IO））</li><li>fmuservo - handle talking to the auxiliary PWM outputs on the FMU（处理与 FMU 上的辅助 PWM 输出的通信）</li><li>uavcan - handle the uavcan CANBUS protocol（处理 uavcan CANBUS 协议）</li></ul><h3 id="AP-Scheduler系统"><a href="#AP-Scheduler系统" class="headerlink" title="AP_Scheduler系统"></a>AP_Scheduler系统</h3><p>AP_Scheduler库用于划分 时间在主车线程内，同时提供一些简单的 控制每个操作使用多少时间的机制（称为 AP_Scheduler中的“任务”）</p><p>它是一个表驱动的调度程序，每种类型都有一个 AP_Scheduler：：任务表</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> AP_Scheduler::Task scheduler_tasks[] PROGMEM = &#123;</span><br><span class="line"> &#123; ins_update, <span class="number">1</span>, <span class="number">1000</span> &#125;,</span><br><span class="line"> &#123; one_hz_print, <span class="number">50</span>, <span class="number">1000</span> &#125;,</span><br><span class="line"> &#123; five_second_call, <span class="number">250</span>, <span class="number">1800</span> &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">每个函数名称后的第一个数字是调用频率，在 由 ins.init（） 调用控制的单位。对于此示例，草图 ins.init（） 使用 RATE_50HZ，因此每个调度步骤为 <span class="number">20</span> 毫秒。这意味着 ins_update（） 调用每 <span class="number">20</span>ms 进行一次，one_hz_print（） 函数 每 <span class="number">50</span> 次调用一次（即每秒一次），并且 five_second_call（） 每 <span class="number">250</span> 次调用一次（即每 <span class="number">5</span> 秒/次）。</span><br></pre></td></tr></table></figure><h2 id="RC-Input-and-Output"><a href="#RC-Input-and-Output" class="headerlink" title="RC Input and Output"></a>RC Input and Output</h2><h3 id="AP-HAL-RCInput-object"><a href="#AP-HAL-RCInput-object" class="headerlink" title="AP_HAL RCInput object"></a>AP_HAL RCInput object</h3><p>首先要理解的是可作为 hal.rcin 使用的 AP_HAL RCInput 对象。它提供了对当前在板上接收到的通道值的低级访问。返回的值是以微秒为单位的 PWM 值。</p><p>前往 libraries&#x2F;AP_HAL&#x2F;examples&#x2F;RCInput&#x2F;RCInput.cpp 示例文件，尝试在您的开发板上运行该示例。试着移动遥控器上的摇杆，并检查输出中的值是否正确变化。</p><h3 id="AP-HAL-RCOutput-object"><a href="#AP-HAL-RCOutput-object" class="headerlink" title="AP_HAL RCOutput object"></a>AP_HAL RCOutput object</h3><p>AP_HAL RCOutput 对象（可作为 hal.rcout 使用）提供了对所有输出通道的低级控制。其实现方式非常依赖于具体的开发板，可能涉及芯片上的定时器编程、I2C 外设或通过协处理器（如 PX4IO 微控制器）进行输出。</p><p>前往 libraries&#x2F;AP_HAL&#x2F;examples&#x2F;RCOutput&#x2F;RCOutput.cpp 示例文件。您会看到该示例只是设置了所有通道，在几秒钟的时间内将舵机从最小值到最大值摆动。连接一些舵机到您的开发板上，然后进行测试，确保它对您而言可以正常工作。</p><h2 id="ArduPilot-File-Systems"><a href="#ArduPilot-File-Systems" class="headerlink" title="ArduPilot File Systems"></a>ArduPilot File Systems</h2><p>ArduPilot使用多个文件系统来使用外部SD卡或自动驾驶仪闪存存储和检索数据</p><p>外部SD卡： </p><p>APM：基目录 </p><p>LOGS：飞行日志存储在此处（请参阅Mission Planner中的下载和分析数据日志） </p><p>TERRAIN：地形数据存储在此处（请参阅地形跟随） </p><p>STRNG_BAK：每次启动时，参数数据都会备份到此处 scripts：LUA脚本存储在此处（请参阅Lua脚本）</p><h2 id="代码架构"><a href="#代码架构" class="headerlink" title="代码架构"></a>代码架构</h2><table><thead><tr><th>1.afs_copter.cpp&#x2F;afs_copter.h高级失效保护<br/>2.AP_Arming.cpp&#x2F;AP_Arming.h解锁<br/>3.AP_Rally.cpp&#x2F;AP_Rally.h集结地<br/>4.AP State.cpp状态转化<br/>5.APM Config_mavlink hil.h&#x2F;APM_Config.h配置信息<br/>6.ArduCopter.cpp顶层逻辑文件<br/>7.Attitude.cpp姿态控制<br/>8.autoyaw.cpp自动航线规划<br/>9.avoidance adsb.cpp&#x2F;avoidance adsb.h避障<br/>10.baro_ground_effect.cpp气压高度计地效<br/>11.capabilities.cpp初始化一些配置<br/>12.commands.cpp位置信息更新需求<br/>13.compassmot.cpp消除磁罗盘对电机的影响<br/>14.config.h配置信息 (勿修改)<br/>15Copter.cpp&#x2F;Copter.h顶层定义<br/>16.crash_check.cpp坠毁监测<br/>17.defines.h定义<br/>18.ekf check.cpp扩展卡尔曼滤波器检测<br/>19.esc calibration.cpp电调控制<br/>20.events.cpp事件<br/>21.failsafe.cpp失控保护<br/>22.fence.cpp地理围栏<br/>23.GCS Copter.h地面站与多旋翼通讯有关<br/>24.GCS_Mavlink.cpp&#x2F;GCS_Mavlink.h地面站通讯协议<br/>25.heli.cpp旋翼的变量和函数<br/>26.inertia.cpp获取惯性信息<br/>27.land_detector.cpp降落检测<br/>28.landing_gear.cpp起落架<br/>29.leds.cppLED灯控制<br/>30.Log.cpp日志<br/>31.make.inc放置头文件<br/>32.mode_acro_heil.cpp比率控制模式 (手动)<br/>33.mode_acro.cpp比率控制模式 (完全手动角速率&#x2F;手动油门)<br/>34.mode_althold.cpp定高模式<br/>35.mode_auto.cpp自动模式 (任务规划)<br/>36.mode_autoune.cpp自动模式 (自动调整俯仰和滚转)<br/>37.mode_avoid_adsb.cpp避障模式<br/>38.mode_brake.cpp制动模式 (没有驾驶员输入)<br/>39.mode_circle.cpp绕圈模式<br/>40.mode_drift.cpp漂移模式<br/>41.mode_flip.cpp翻转模式<br/>42.mode_flowhold.cpp跟随模式 (光流位置&#x2F;不带测距仪)<br/>43.mode_follow.cpp 跟随模式 (车辆或地面站)<br/>44.mode_guided_nogps.cpp引导模式 (无GPS)<br/>45.mode_guided.cpp引导模式<br/>46.mode_land.cpp着陆模式<br/>47.mode_loiter.cpp悬停模式<br/>48.mode_poshold.cpp位置保持模式 (类似loiter&#x2F;何控制偏航角度)<br/>49.mode_rtl.cpp返航模式 (发射点)<br/>50.mode_smart_rtl.cpp返航模式 (家)<br/>51.mode_sport.cpp运动模式<br/>52.mode_stablize_heil.cpp自稳模式<br/>53.mode_stablize.cpp自稳模式<br/>54.mode_throw.cpp抛飞模式 (无输入)<br/>55. mode. ( . \mathrm{pp} &#x2F; \mathrm{mode} ). h模式的基类和头文件<br/>56.motor_test.cpp电机测试<br/>57.motor.cpp电机控制<br/>58.navigation.cpp导航参数计算<br/>59.Parmeters.cpp&#x2F;Parmeters.h参数表<br/>60.position_vector.cpp向量位置坐标<br/>61.precision_landing.cpp精准着陆<br/>62.radio.cpp无线电<br/>63.sensors.cpp传感器控制<br/>64.setup.cpp 初始化设置<br/>65.swiches.cpp模式转换<br/>66.system.cpp系统<br/>67.takeoff.cpp起飞<br/>68.terrain.cpp地形<br/>69.toy_mode.cpp&#x2F;toy_mode.h玩具模式 (简单与用户交互)<br/>70.tuning.cppi调节参数<br/>71.UserCode.cpp用户自定义代码<br/>72.UserVariables.h用户自定义变量<br/>73.version.cpp&#x2F;version.h版本号</th></tr></thead></table><p> <strong>manual modes（手动模式）</strong></p><p><strong>autonomous modes(自稳模式)</strong></p><h2 id="Copter-Attitude-Control"><a href="#Copter-Attitude-Control" class="headerlink" title="Copter Attitude Control"></a>Copter Attitude Control</h2><p>姿态控制</p><p>The diagram below shows the code path followed from pilot input down to pwm output.</p><h2 id="Motors-Library"><a href="#Motors-Library" class="headerlink" title="Motors Library"></a>Motors Library</h2><p>在<code>AC_AttitudeControl_Multi::rate_controller_run()</code>方法中：</p><ul><li>该方法从姿态估计系统中获取最新的陀螺仪读数。</li><li>根据当前陀螺仪读数与目标角速度之间的差异，计算出滚转（roll）、俯仰（pitch）和偏航（yaw）指令。</li><li>然后，使用<code>_motors.set_roll()</code>、<code>_motors.set_pitch()</code>和<code>_motors.set_yaw()</code>方法将这些滚转、俯仰和偏航指令传递给电机库。</li></ul><p>在<code>AP_Motors_Class.h</code>文件中：</p><ul><li>定义了<code>set_roll()</code>、<code>set_pitch()</code>、<code>set_yaw()</code>和<code>set_throttle()</code>方法，用于设置滚转、俯仰、偏航和油门的输入值。</li><li>滚转、俯仰和偏航输入的范围是-1到+1，而油门输入的范围是0到+1。</li><li>电机库负责将这些高级输入转换为单独的电机和舵机输出。</li><li>限制标志存储在<code>AP_Motors_Class::limit</code>变量中，用于防止姿态控制器和油门控制器中的“积分项”积累过多。这些标志指示是否已达到滚转、俯仰、偏航和油门的限制。</li></ul><h1 id="APM固件二次开发"><a href="#APM固件二次开发" class="headerlink" title="APM固件二次开发"></a>APM固件二次开发</h1><h2 id="ardupliot代码框架"><a href="#ardupliot代码框架" class="headerlink" title="ardupliot代码框架"></a>ardupliot代码框架</h2><p>AntennaTracker、ArduCopter、ArduPlane、ArduSub：这些文件包含特定于飞行器类型的代码。</p><p>例如，ArduCopter负责处理多旋翼飞行器的代码，ArduPlane负责固定翼飞行器的代码，ArduSub负责潜水器的代码，而AntennaTracker则负责地面站天线追踪系统的代码。</p><ul><li>AC_AttitudeControl: 用于飞行器姿态控制的库。</li><li>AC_Autorotation: 用于处理直升机自旋降落（Autorotation）的库。</li><li>AC_AutoTune: 用于自动优化飞行器控制增益的自动调谐库。</li><li>AC_Avoidance: 用于避免与障碍物碰撞的避障库。</li><li>AC_CustomControl: 用于自定义控制的库。</li><li>AC_Fence: 地理围栏（Geofence）库，用于设置飞行区域的边界。</li><li>AC_InputManager: 输入管理库，处理和管理来自遥控器的输入信号。</li><li>AC_PID: PID控制库，实现了比例-积分-微分（PID）控制算法。</li><li>AC_PrecLand: 精确降落库，用于精确控制飞行器的降落。</li><li>AC_Sprayer: 喷雾器库，用于控制飞行器上的喷雾装置。</li><li>AC_WPNav: 路径导航库，用于管理飞行器的路径导航。</li><li>AP_AccelCal: 加速度计校准库，用于校准飞行器的加速度计。</li><li>AP_ADC: 模拟-数字转换器（ADC）库，用于处理飞行器上的模拟信号。</li><li>AP_ADSB: Automatic Dependent Surveillance-Broadcast（ADSB）库，用于处理飞行器的ADSB信号。</li><li>AP_AdvancedFailsafe: 高级故障保护库，用于处理飞行器的故障保护逻辑。</li><li>AP_AHRS: 姿态和航向参考系统（AHRS）库，利用各种传感器的数据计算飞行器的姿态和方位。</li><li>AP_Airspeed: 空速库，用于处理和管理飞行器的空速数据。</li><li>AP_AIS: Automatic Identification System（AIS）库，用于处理船舶的自动识别系统信号。</li><li>AP_Arming: 武装库，用于管理飞行器的启动和停止。</li><li>AP_Avoidance: 避障库，用于避免与障碍物碰撞。</li><li>AP_Baro: 气压计库，用于处理和管理飞行器的气压数据。</li><li>AP_BattMonitor: 电池监控库，用于监控飞行器的电池状态。</li><li>AP_Beacon: 信标库，用于处理和管理飞行器的信标数据。</li><li>AP_BLHeli: BLHeli电调库，用于控制支持BLHeli协议的电调。</li><li>AP_BoardConfig: 用于处理和管理飞行控制板配置的库。</li><li>AP_Button: 用于处理和管理飞行器上的按钮输入的库。</li><li>AP_Camera: 用于处理和管理飞行器上的相机的库。</li><li>AP_CANManager: Controller Area Network（CAN）管理器库，用于处理和管理CAN接口。</li><li>AP_CheckFirmware: 用于检查固件更新的库。</li><li>AP_Common: 提供通用功能和定义的库。</li><li>AP_Compass: 用于处理和管理飞行器上的磁罗盘数据的库。</li><li>AP_CSVReader: 用于读取CSV文件的库。</li><li>AP_CustomRotations: 用于管理自定义旋转的库。</li><li>AP_DAL: Data Abstraction Layer（DAL）库，提供数据抽象层服务。</li><li>AP_DDS: 提供Data Distribution Service（DDS）的库，它是一种实时数据分发服务。</li><li>AP_Declination: 用于计算地磁倾斜角的库。</li><li>AP_Devo_Telem: 用于处理和管理Devention协议遥测数据的库。</li><li>AP_DroneCAN: 提供DroneCAN功能的库，DroneCAN是一种无人机CAN协议。</li><li>AP_EFI: Electronic Fuel Injection（EFI）库，用于控制和管理电子燃油喷射系统。</li><li>AP_ESC_Telem: 提供电子速度控制器（ESC）遥测的库。</li><li>AP_ExternalAHRS: 用于处理外部AHRS设备的库。</li><li>AP_FETtecOneWire: 提供对FETtec OneWire ESC的支持的库。</li><li>AP_Filesystem: 提供文件系统操作的库。</li><li>AP_FlashStorage: 提供Flash存储操作的库。</li><li>AP_Follow: 提供”跟随我”功能的库。</li><li>AP_Frsky_Telem: 提供对FrSky遥测协议的支持的库。</li><li>AP_InternalError: 用于处理和报告内部错误的库。</li><li>AP_IOMCU: 输入&#x2F;输出微控制器单元的库，用于处理各种I&#x2F;O任务。</li><li>AP_IRLock: 用于处理红外锁定系统（通常用于精确着陆）的库。</li><li>AP_JSButton: 用于处理和管理飞行器上的按钮输入的库。</li><li>AP_KDECAN: 提供对KDE Direct UAS CAN总线ESC的支持的库。</li><li>AP_L1_Control: 提供L1航迹跟踪控制的库。</li><li>AP_Landing: 用于处理和管理飞行器的着陆过程的库。</li><li>AP_LandingGear: 用于控制和管理飞行器上的起落架的库。</li><li>AP_LeakDetector: 用于检测潜水航行器的漏水情况的库。</li><li>AP_Logger: 提供日志记录功能的库。</li><li>AP_LTM_Telem: 提供LTM遥测协议的支持的库。</li><li>AP_Math: 提供各种数学函数和算法的库。</li><li>AP_Menu: 提供菜单管理功能的库。</li><li>AP_Mission: 提供飞行任务管理功能的库。</li><li>AP_Module: 用于支持可加载模块的库。</li><li>AP_Motors: 提供电机控制功能的库。</li><li>AP_Mount: 提供对飞行器上装置（如照相机云台）的控制的库。</li><li>AP_MSP: 提供MultiWii Serial Protocol (MSP)的支持的库。</li><li>AP_NavEKF: 提供扩展卡尔曼滤波器（EKF）的库，用于态势估计。</li><li>AP_NavEKF2: 提供第二版扩展卡尔曼滤波器的库。</li><li>AP_NavEKF3: 提供第三版扩展卡尔曼滤波器的库。</li><li>AP_Navigation: 提供导航功能的库。</li><li>AP_NMEA_Output: 提供NMEA输出功能的库，通常用于与其他设备（如GPS或图形显示器）通信。</li><li>AP_Notify: 提供状态通知功能的库，例如LED灯或蜂鸣器。</li><li>AP_OLC: 提供在线竞争(Online Contest, OLC)飞行规划功能的库，常用于滑翔飞行。</li><li>AP_ONVIF: 提供ONVIF协议的支持的库，ONVIF是一种网络视频接口标准。</li><li>AP_OpenDronelD: 提供开放无人机识别系统的支持的库。</li><li>AP_OpticalFlow: 提供光流传感器的支持的库，光流传感器常用于无人机的定位和导航。</li><li>AP_OSD: 提供了On-Screen Display（屏幕显示）功能，用于将飞行数据显示在视频传输中。</li><li>AP_Parachute: 用于控制和操作无人机上的降落伞系统。</li><li>AP_Param: 提供了参数管理和配置功能，用于管理飞行控制器中的各种参数。</li><li>AP_PiccoloCAN: 用于与PiccoloCAN协议兼容的设备进行通信。</li><li>AP_Proximity: 提供了飞行器周围环境感知和障碍物检测的功能。</li><li>AP_Radio: 用于与无人机上的无线电通信设备进行通信和控制。</li><li>AP_Rally: 提供了航点集合和任务路径功能，用于无人机的航点导航。</li><li>AP_RAMTRON: 用于与RAMTRON系列设备进行通信和数据存储。</li><li>AP_RangeFinder: 用于与测距仪传感器进行通信和测量距离。</li><li>AP_RCMapper: 提供了遥控器通道映射和配置的功能。</li><li>AP_RCProtocol: 提供了与不同遥控器协议兼容的功能，用于接收和解码遥控器信号。</li><li>AP_RCTelemetry: 用于与遥控器进行双向的遥测数据交换。</li><li>AP_Relay: 提供了继电器控制和操作的功能。</li><li>AP_RobotisServo: 用于与Robotis系列舵机进行通信和控制。</li><li>AP_ROMFS: 提供了只读文件系统的功能，用于存储固件和其他只读数据。</li><li>AP_RPM: 用于测量和监控发动机的转速。</li><li>AP_RSSI: 用于测量和监控遥控信号强度。</li><li>AP_RTC: 提供了实时时钟的功能，用于精确的时间记录和时间相关的操作。</li><li>AP_SBusOut: 用于通过S.Bus协议向外部设备发送信号。</li><li>AP_Scheduler: 提供了任务调度和时间管理的功能。</li><li>AP_Scripting: 提供了脚本编程和执行的功能，用于自定义行为和逻辑。</li><li>AP_SerialLED: 用于控制和操作串口LED设备。</li><li>AP_SerialManager: 用于管理和控制串口通信。</li><li>AP_ServoRelayEvents: 提供了舵机和继电器事件触发的功能。</li><li>AP_SmartRTL: 提供了智能返航和自动返航功能。</li><li>AP_Soaring: 提供了滑翔和热气球飞行的功能。</li><li>AP_Stats: 提供了飞行数据统计和分析的功能。</li><li>AP_TECS: 提供了自动高度和速度控制的功能。</li><li>AP_TempCalibration: 用于温度校准和补偿。</li><li>AP_TemperatureSensor: 提供了温度传感器的功能和接口。</li><li>AP_Terrain: 提供了地形数据的获取和处理功能。</li><li>AP_Torqeedo: 用于与Torqeedo电动船驱动系统进行通信和控制。</li><li>AP_Tuning: 提供了飞行控制器参数调优和优化的功能。</li><li>AP_Vehicle: 提供了飞行器的基本控制和状态管理功能。</li><li>AP_VideoTX: 用于与视频传输设备进行通信和控制。</li><li>AP_VisualOdom: 提供了视觉里程计的功能，用于无人机的定位和导航。</li><li>AP_Volz_Protocol: 用于与Volz协议兼容的设备进行通信。</li><li>AP_WheelEncoder: 用于读取和处理轮式编码器的数据，用于无人车的定位和测速。</li><li>AP_Winch: 提供了绞盘控制和操作的功能。</li><li>AP_WindVane: 用于读取和处理风向传感器的数据。</li><li>APM_Control: APM代表ArduPilot Mega，提供了飞行控制器的基本控制功能。</li><li>AR_Motors: AR代表ArduRover，用于无人车电机控制和操作的功能。</li><li>AR_WPNav: AR代表ArduRover，WPNav代表航点导航，提供了无人车的航点导航功能。</li><li>doc: 包含文档、说明和帮助文件。</li><li>Filter: 提供了各种滤波算法，用于传感器数据的滤波和平滑。</li><li>GCS_MAVLink: GCS代表地面控制站，MAVLink是一种无人机通信协议，用于与地面控制站之间的通信和数据交换功能。</li><li>PID: 提供了PID控制器的实现，用于控制飞行器的稳定性和导航。</li><li>RC_Channel: 用于接收和处理遥控器通道数据。</li><li>SITL: SITL代表Software-In-The-Loop，提供了软件在环仿真的功能，用于在计算机上模拟飞行控制器的行为和环境。</li><li>SRV_Channel: 用于接收和处理伺服通道数据。</li></ul><h2 id="ArduPlane主函数"><a href="#ArduPlane主函数" class="headerlink" title="ArduPlane主函数"></a>ArduPlane主函数</h2><h3 id="任务列表"><a href="#任务列表" class="headerlink" title="任务列表"></a>任务列表</h3><p>SCHED_TASK(read_radio, 50, 100,  6) &#x2F;&#x2F;任务名，执行频率HZ，任务执行最大时间us，任务优先级（0-255，越低优先级越高）</p>]]></content>
      
      
      
        <tags>
            
            <tag> UAV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>无人水翼航行器运动的非线性建模</title>
      <link href="/5.%E6%97%A0%E4%BA%BA%E6%B0%B4%E7%BF%BC%E8%88%AA%E8%A1%8C%E5%99%A8%E8%BF%90%E5%8A%A8%E7%9A%84%E9%9D%9E%E7%BA%BF%E6%80%A7%E5%BB%BA%E6%A8%A1/"/>
      <url>/5.%E6%97%A0%E4%BA%BA%E6%B0%B4%E7%BF%BC%E8%88%AA%E8%A1%8C%E5%99%A8%E8%BF%90%E5%8A%A8%E7%9A%84%E9%9D%9E%E7%BA%BF%E6%80%A7%E5%BB%BA%E6%A8%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="无人水翼航行器运动的非线性建模"><a href="#无人水翼航行器运动的非线性建模" class="headerlink" title="无人水翼航行器运动的非线性建模"></a>无人水翼航行器运动的非线性建模</h1><h3 id="无人水翼航行器的结构和运动特点"><a href="#无人水翼航行器的结构和运动特点" class="headerlink" title="无人水翼航行器的结构和运动特点"></a>无人水翼航行器的结构和运动特点</h3><p>为了提高航行器快速性，应尽量提高推进器的推力和减小航行器航行的阻力。从 节能的角度考虑，减少航行器航行时的阻力是提高快速性的好办法。航行器阻力包括水阻力和空气阻力。由于空气阻力比航行器水阻力小得多，因此主要考虑航行器的水阻力，其中包括摩擦阻力、涡流阻力(形状阻力)和兴波阻力三个部分。涡流阻力和兴波阻力可以通过改善航行器的线型而得以改进。</p><p>水翼附着了一个可以通过控制系统调节的襟翼。在不同航速和海面状况的条 件下，通过调整襟翼可以实现对升力的控制。通过对水翼实施控制，从而产生与波浪干扰力相反的力，以抵消或减轻波浪的干扰所引起的水翼船垂荡和纵摇运动， 保证水翼船在风浪中平稳地航行。虽然各种水翼船实际控制系统的具体构成各有不同，但是大都具有与下图相类似的结构原理。</p><p><img src="../images/Hydrofoil/Hydrofoil2.png"></p><h3 id="无人水翼航行器的非线性运动数学模型"><a href="#无人水翼航行器的非线性运动数学模型" class="headerlink" title="无人水翼航行器的非线性运动数学模型"></a>无人水翼航行器的非线性运动数学模型</h3><p>高速水翼航行器的实际运动异常复杂，在一般情况下具有6个自由度，其中三个线性运动和三个转动运动 ，分别为：横荡 、 纵荡 、 垂荡和横摇 、纵摇 、艏 摇 。其中横荡 、纵荡 、垂荡分别为沿X，Y，Z轴的平直运动 ，横摇 、纵摇和艏摇分别为绕X，Y，Z轴的转动运动 ，运动名称定义见下表所示：</p><table><thead><tr><th align="center">运动</th><th align="center">坐标轴</th><th align="center">力与力矩</th><th align="center">速度&#x2F;角速度</th><th align="center">位置&#x2F;姿态</th></tr></thead><tbody><tr><td align="center">横荡（进退）</td><td align="center">沿 <em>x</em> 轴方向运动</td><td align="center">X</td><td align="center">u</td><td align="center">x</td></tr><tr><td align="center">纵荡（横移）</td><td align="center">沿 <em>y</em> 轴方向运动</td><td align="center">Y</td><td align="center">v</td><td align="center">y</td></tr><tr><td align="center">升沉（垂荡）</td><td align="center">沿 <em>z</em> 轴方向运动</td><td align="center">Z</td><td align="center">w</td><td align="center">z</td></tr><tr><td align="center">横摇</td><td align="center">旋转轴： <em>x</em> 轴</td><td align="center">K</td><td align="center">p</td><td align="center">$\varphi $</td></tr><tr><td align="center">纵揺</td><td align="center">旋转轴： <em>y</em> 轴</td><td align="center">M</td><td align="center">q</td><td align="center">$\theta $</td></tr><tr><td align="center">艏摇</td><td align="center">旋转轴： <em>z</em> 轴</td><td align="center">N</td><td align="center">r</td><td align="center">$ \psi$</td></tr></tbody></table><p>（1） 附体坐标系</p><p>附体坐标系$O_{b} $ $X_{b} $$Y_{b} $$Z_{b} $  (或称为“随船运动坐标系”):为了描述航行器航行过程中的姿态，需要定义一个与航行器固连，即随着航行器一 起运动的附体坐标系$O_{b} $ $X_{b} $$Y_{b} $$Z_{b} $。  它的原点$O_{b} $位于航行器重心，$O_{b} $ $X_{b} $轴在中纵剖面内平行于船体基线，指向船首； $O_{b} $ $Y_{b} $ 轴垂直于中纵剖面，指向右； $O_{b} $ $Z_{b} $ 轴在中纵剖面内垂直于船体基线， 指向龙骨。</p><p>（2） 空间坐标系</p><p>空间固定坐标系O’X’Y’Z’:  随航行器运动坐标系$O_{b} $ $X_{b} $$Y_{b} $$Z_{b} $是建立船舶质心运动模型的基本坐标系，不能反映航行器运动欧拉角的变化。为此需要建立一个固定在地面的固定坐标系O‘X’Y‘Z’, 其 中O‘Z’轴垂直向下，O’X ‘轴平行于水平面，坐标原点O ‘在t&#x3D;0 时刻与附体坐标系的原点$O_{b} $ 重合。<br>$$<br>m(\ddot{\xi} + v\dot{\theta}) &#x3D; -\sum_{i&#x3D;1}^{2} (F_{fi} + F_{fpi}) \cos\theta + mg \cos\theta<br>$$<br>$$<br>J_{yy} \ddot{\theta} &#x3D; Fd - M_f - \sum_{i&#x3D;1}^{2} (F_{fi} + F_{fpi}) d_i \cos\theta + \sum_{i&#x3D;1}^{2} (F_{fi} + F_{fpi}) d_i \sin\theta<br>$$</p><p>这个方程表示的是在$Y_{b} $ 轴上，航行器受到的力矩与它的角加速度之间的关系。$F_{fi} $ 为前后水翼( i &#x3D; 1 为前翼，i &#x3D; 2 为后翼) 所产生的力;$F_{fpi} $ 为襟翼所产生的力,后翼无襟翼，固定角度; $F_{Di} $ 为水翼所产生的阻力,水翼所产生的阻力及其力矩可以忽略; f 为连接杆在水中运动所产生的阻力; F 为电机推力。θ为纵摇角，ξ 为无人水翼航行器垂直于水平面升沉量。其中：</p><ul><li>$J_{yy}$是航行器绕$Y_{b} $ 轴的转动惯量;</li><li>$\ddot{\theta }$ 是航行器的纵摇加速度;</li><li>Fd是电机推力产生的力矩;</li><li>$M_{f}$是连接杆在水中运动产生的阻力产生的力矩,为fd;</li><li>$F_{fi}$是水翼产生的力;</li><li>$F_{fpi}$是襟翼产生的力;</li><li>$F_{Di}$是水翼产生的阻力，可以忽略;</li><li>d和$d_{i}$是相应力臂的长度。</li></ul><p>加入随机海浪，产生波动，$Z_{W}$ 和 $M_{W}$ 是随机海浪的力和力矩, $Z_{c}$ 和 $M_{\mathrm{c}}$ 是控制力和力矩。将部分参数展开表示后如下:<br>$$<br>m(\ddot{\xi} + V \dot{\theta}) &#x3D; -\sum_{i&#x3D;1}^{2} (F_{fi} + F_{fpi}) \cos\theta + mg \cos\theta + Z_w<br>$$<br>$$<br>J_{yy} \ddot{\theta} &#x3D; Fd - M_f - \sum_{i&#x3D;1}^{2} (F_{fi} + F_{fpi}) d_i \cos\theta + \sum_{i&#x3D;1}^{2} (F_{fi} + F_{fpi}) d_i \sin\theta + M_w<br>$$</p><p>将航行器的非线性数学模型改写成如下形式：<br>$$<br>Z(\ddot{\xi}, \dot{\xi}, \xi, \ddot{\theta}, \dot{\theta}, \theta) &#x3D; m(\ddot{\xi} + V \dot{\theta}) + \sum_{i&#x3D;1}^{2} (F_{fi} + F_{fpi}) \cos\theta - mg \cos\theta - Z_w &#x3D; 0<br>$$</p><p>$$<br>M(\ddot{\xi}, \dot{\xi}, \xi, \ddot{\theta}, \dot{\theta}, \theta) &#x3D; J_{yy} \ddot{\theta} - M_w + \sum_{i&#x3D;1}^{2} (F_{fi} + F_{fpi}) d_i \cos\theta - \sum_{i&#x3D;1}^{2} (F_{fi} + F_{fpi}) d_i \sin\theta - Fd + M_f &#x3D; 0<br>$$<br>对 $Z(\ddot{\xi}, \dot{\xi}, \xi, \ddot{\theta}, \dot{\theta}, \theta)$ 和 $M(\ddot{\xi}, \dot{\xi}, \xi, \ddot{\theta}, \dot{\theta}, \theta)$ 在平衡点$\ddot{\xi}<em>{d}, \dot{\xi}</em>{d}, \xi_{d}, \ddot{\theta}<em>{d}, \dot{\theta}</em>{d}, \theta_{d}$进行线性化。令 </p><p>$\ddot{\xi}<em>{\delta}&#x3D;\ddot{\xi}-\ddot{\xi}</em>{d}, \dot{\xi}<em>{\delta}&#x3D;\dot{\xi}-\dot{\xi}</em>{d}, \xi_{\delta}&#x3D;\xi-\xi_{d}, \ddot{\theta}<em>{\delta}&#x3D;\ddot{\theta}-\ddot{\theta}</em>{d}, \dot{\theta}<em>{\delta}&#x3D;\dot{\theta}-\dot{\theta}</em>{d}, \theta_{\delta}&#x3D;\theta-\theta_{d}$</p><p>则可以得到线性化后的方程可以表示为：</p><p>$$<br>Z_{\ddot{\xi}} \ddot{\xi}<em>\delta + Z</em>{\dot{\xi}} \dot{\xi}<em>\delta + Z</em>\xi \xi_\delta + Z_{\ddot{\theta}} \ddot{\theta}<em>\delta + Z</em>{\dot{\theta}} \dot{\theta}<em>\delta + Z</em>\theta \theta_\delta &#x3D; -Z_{fp-\alpha 1} \alpha_{fp1} - Z_{fp-\alpha 2} \alpha_{fp2} - Z_w<br>$$</p><p>$$<br>M_{\ddot{\xi}} \ddot{\xi}<em>\delta + M</em>{\dot{\xi}} \dot{\xi}<em>\delta + M</em>\xi \xi_\delta + M_{\ddot{\theta}} \ddot{\theta}<em>\delta + M</em>{\dot{\theta}} \dot{\theta}<em>\delta + M</em>\theta \theta_\delta &#x3D; -M_{fp-\alpha 1} \alpha_{fp1} - M_{fp-\alpha 2} \alpha_{fp2} - M_w<br>$$<br>其中 $\alpha_{f p 1}$ 和 $\alpha_{f p 2}$ 是襟翼控制角的变化量，即控制输入。 $Z_{w}$ 和 $M_{w}$ 是随机海浪的力和力矩。这是对于航行器的非线性数学模型在动态平衡点附近进行线性化后的结果。</p><p>\begin{array}{c}<br>Z_{\ddot{\xi}} \ddot{\xi}<em>{\delta}+Z</em>{\dot{\xi}} \dot{\xi}<em>{\delta}+Z</em>{\xi} \xi_{\delta}+Z_{\ddot{\theta}} \ddot{\theta}<em>{\delta}+Z</em>{\dot{\theta}} \dot{\theta}<em>{\delta}+Z</em>{\theta} \theta_{\delta}&#x3D;-Z_{f p-\alpha 1} \alpha_{f p 1}-Z_{f p-\alpha 2} \alpha_{f p 2}-Z_{w} \<br>M_{\ddot{\xi}} \ddot{\xi}<em>{\delta}+M</em>{\dot{\xi}} \dot{\xi}<em>{\delta}+M</em>{\xi} \xi_{\delta}+M_{\ddot{\theta}} \ddot{\theta}<em>{\delta}+M</em>{\dot{\theta}} \dot{\theta}<em>{\delta}+M</em>{\theta} \theta_{\delta}&#x3D;-M_{f p-\alpha 1} \alpha_{f p 1}-M_{f p-\alpha 2} \alpha_{f p 2}-M_{w}<br>\end{array}</p><h3 id="水翼所产生的作用力"><a href="#水翼所产生的作用力" class="headerlink" title="水翼所产生的作用力"></a>水翼所产生的作用力</h3><p>在航行器的非线性数学模型中与水翼有关的作用力有两个，分别是水翼所产 生的升力和惯性力，即$F_{fi}$&#x3D;$L_{fi}$+$F_{ai}$。</p><h4 id="水翼升力的计算"><a href="#水翼升力的计算" class="headerlink" title="水翼升力的计算"></a>水翼升力的计算</h4><p>水翼所产生的阻力及其力矩可以忽略，而仅考虑水翼所产生的升力$L_{fi}$, 故水翼的升力可表示为:<br>$$<br>L_{fi}&#x3D;1&#x2F;2\rho S_{i}V^{2} C_{Li}<br>$$<br>其中, $\rho$ 为流体的密度, $S_{i}$ 是水翼投影的面积, 可由 $S_{i}&#x3D;l_{i} \cdot b_{i}$ 求得, $l_{i}$ 是水翼的翼展, $b_{i}$ 是水翼的翼弦。<br>水翼的升力系数 $C_{L i}$ 有时会受到水翼浸于流体中的深度的影响, 也称作 “浅浸效应”。 由于全浸式水翼艇的水翼接近液面时, 水和大气交界会使水翼的特性, 即升力系数的斜 率 $d C_{L i} &#x2F; d \alpha_{i}$ 变小。<br>水翼升力系数的求法可以采用 $K . L$. Wadlin 提出的方法进行求解:<br>$$<br>C_{L i}&#x3D;\frac{2 K_{2 i} \pi \lambda_{i} \alpha_{i}}{\lambda_{i}+2 K_{2 i}+1}+\frac{8}{3}\left(1-\frac{\lambda_{i}}{10}\right) \sin ^{2} \alpha_{i} \cos \alpha_{i}<br>$$<br>式中, $\lambda_{i}$ 是展弦比, $K_{2 i}$ 是二维深度修正因子, $\alpha_{i}$ 是水翼的攻角。二维深度修正因 子 $K_{2 i}$ 的表达式如下:<br>$$<br>K_{2 i}&#x3D;\frac{\left(4 f_{i}\right)^{2}+8 f_{i} \sin \alpha_{i}+1}{\left(4 f_{i}\right)^{2}+8 f_{i} \sin \alpha_{i}+2}<br>$$<br>式中, $f_{i}$ 是水翼在 $1 &#x2F; 4$ 翼弦处水翼的浸没深度, $f_{i}$ 根据水翼处于自由液面时具有的 临界条件可以用以下方式计算:<br>$$<br>f_{i}&#x3D;\frac{d_{i}}{b_{i}}+\frac{\frac{d_{i}}{4} \sin \alpha_{i}}{0.05+\frac{d_{i}}{b_{i}}}<br>$$<br>式中, $d_{i}$ 为水翼的导边到自由液面的长度, 计算方法如下:<br>$$<br>d_{i}&#x3D;d_{0 i}+\xi-\left(x_{f i}-x_{G}\right) \sin \theta<br>$$<br>攻角 $\alpha_{i}$ 的计算方法如下:</p><p>$$<br>\alpha_i &#x3D; \alpha_{si} - \alpha_{0i} + \frac{\dot{\xi} - (x_{fi} - x_g) \dot{\theta} - \dot{\zeta}<em>i}{V} + \theta<br>$$<br>其中, $ \alpha</em>{s i} $ 为水翼的安装角, $ \alpha_{0 i} $ 是水翼的零升力攻角, $ \dot{\zeta}<em>{i} $ 是波浪在水翼处的运动速度垂直于水面方向的分量。<br>在参考论文中，对于全浸式水翼艇的水翼升力系数由于计算过于繁杂, 本文根据经验将其定为常 数, 取值 &#x3D;&#x3D;0.33&#x3D;&#x3D;^[1]^，其襟翼计算的升力系数参考如下：<br>$$<br>\begin{array}{l|l}<br>  前翼单位面积受力关于攻角 \alpha 斜率 \left(\frac{\partial C</em>{f p-L 1}\left(\alpha_{\left.f_{p 1}\right)}\right)}{\partial \alpha_{f_{p}}}\right) &amp; 0.08 \<br>\hline   后翼单位面积受力关于攻角 \alpha 斜率 \left(\frac{\partial C_{f p-L 2}\left(\alpha_{\left.f_{p 2}\right)}\right)}{\partial \alpha_{f p 2}}\right) &amp; 0.08<br>\end{array}<br>$$</p><h4 id="水翼的惯性力"><a href="#水翼的惯性力" class="headerlink" title="水翼的惯性力"></a>水翼的惯性力</h4><p>航行器在水中运动时可以看作是一个刚体，受到的惯性力除了航行器本身的以外还有周围流体的作用。航行器运动时周围的流体质点就会受到扰动，就会将流体反作用力施加在航行器上。流体作用力大小正比于运动加速度，方向与运动加速度方向相反， 也称作惯性力，大小如下：<br>$$<br>{F_{a i}&#x3D;-m_{f i}\left(\ddot{\xi}+V \dot{\theta}-d_{i} \ddot{\theta}-\ddot{\zeta}<em>{i}\right)}<br>$$<br> $m</em>{f i}$为水翼的附加质量，它是水翼的惯性阻力与对应的水翼垂向运动加速度的比例系数。由于水的密度较大，所以水翼的附加质量不可忽略。其中, ${m_{f i}&#x3D;\frac{\pi}{2} \cdot \frac{b_{i}^{2}}{4} \cdot l_{i} \cdot \rho, l_{i}}$ 是水翼的翼展, $b_{i}$ 是水翼的翼弦, V为水翼航行器的航速,$d_{i}$是水翼到船体的重心的距离, $\ddot{\zeta}_{i}$ 是波浪在水翼处的运动加速度垂直于水面方向的分量。</p><h3 id="水翼航行器转动惯量的估算"><a href="#水翼航行器转动惯量的估算" class="headerlink" title="水翼航行器转动惯量的估算"></a>水翼航行器转动惯量的估算</h3><p>一个长方体关于其对角线的转动惯量可以通过以下公式计算：</p><p>$$<br>I &#x3D; (M&#x2F;12) * (h² + w² + l²)<br>$$<br>其中：</p><ul><li>I 是转动惯量</li><li>M 是质量</li><li>h、w、l 分别是高度、宽度和长度</li></ul><p>假设我们有一个质量为1.5千克的长方体，其长度为1米，宽度和高度都是0.3米，我们可以将这些数值代入公式：</p><p>$$<br>I &#x3D; (1.5&#x2F;12) * (0.3² + 0.3² + 1²)<br>$$</p><p>$$<br>I &#x3D; 0.125 kg*m²<br>$$</p><p>这就是这个长方体关于其对角线的转动惯量。注意，这是在假设质量均匀分布的情况下的转动惯量。如果质量分布不均匀，转动惯量会有所不同。</p><p>刚体转动惯量是惯性张量在特定轴线上的取值，而惯性张量则是一个包含了刚体在不同轴线上转动惯量的矩阵。即Iyy取0.14.</p><p>对于我们所设计的水翼航行器航，行器结构参数如下表所示。</p><p>潜行速度10km&#x2F;h（2.8m&#x2F;s）,滑行速度20km&#x2F;h(5.6m&#x2F;s),即V&#x3D;5.6m&#x2F;s。</p><table><thead><tr><th align="center">名称</th><th align="center">数值</th></tr></thead><tbody><tr><td align="center">航行器质量 m&#x2F;kg</td><td align="center">1.5</td></tr><tr><td align="center">重力加速度 g &#x2F;( m·$s ^{-2} $)</td><td align="center">9.8</td></tr><tr><td align="center">航行器转动惯量 Jyy &#x2F;( kg·$m^{-2} $ )</td><td align="center">0.14（估计）</td></tr><tr><td align="center">连接杆长 d&#x2F;m</td><td align="center">0.09</td></tr><tr><td align="center">连接杆1&#x2F;前翼距航行器重心距离 d1 &#x2F;m</td><td align="center">0.3（估计）</td></tr><tr><td align="center">连接杆2&#x2F;后翼距航行器重心距离 d2 &#x2F;m</td><td align="center">0.3（估计）</td></tr><tr><td align="center">电机距航行器重心距离 d2 &#x2F;m</td><td align="center">0.3（估计）</td></tr><tr><td align="center">前翼展长 L1 &#x2F;m</td><td align="center">0.135</td></tr><tr><td align="center">前翼弦长 b1 &#x2F;m</td><td align="center">0.0324</td></tr><tr><td align="center">后翼展长 L2 &#x2F;m</td><td align="center">0.1016</td></tr><tr><td align="center">后翼弦长 b2&#x2F;m</td><td align="center">0.0168</td></tr></tbody></table><h3 id="线性化后的方程"><a href="#线性化后的方程" class="headerlink" title="线性化后的方程"></a>线性化后的方程</h3><p>$$<br>Z_{\ddot{\xi}} &#x3D; m + \sum_{i&#x3D;1}^{2} m_{fi}<br>$$</p><p>$$<br>Z_{\dot{\xi}} &#x3D; \frac{1}{2} \rho V^2 \sum_{i&#x3D;1}^{2} \left( S_i \frac{\partial C_{Li}}{\partial \dot{\xi}} \right)<br>$$</p><p>$$<br>Z_\xi &#x3D; \frac{1}{2} \rho V^2 \sum_{i&#x3D;1}^{2} \left( S_i \frac{\partial C_{Li}}{\partial \dot{\xi}} \right)<br>$$</p><p>$$<br>Z_{\ddot{\theta}} &#x3D; -\sum_{i&#x3D;1}^{2} (m_{fi} d_i)<br>$$</p><p>$$<br>Z_{\dot{\theta}} &#x3D; \frac{1}{2} \rho V^2 \sum_{i&#x3D;1}^{2} \left( S_i \frac{\partial C_{Li}}{\partial \dot{\theta}} \right)<br>$$</p><p>$$<br>Z_\theta &#x3D; \frac{1}{2} \rho V^2 \sum_{i&#x3D;1}^{2} \left( S_i \frac{\partial C_{Li}}{\partial \dot{\theta}} \right)<br>$$</p><p>$$<br>Z_{fp-\alpha i} &#x3D; \frac{1}{2} \rho V^2 S_{fpi} \frac{\partial C_{fp-Li}(\alpha_{fpi})}{\partial \alpha_{fpi}}<br>$$</p><p>$$<br>M_{\ddot{\xi}} &#x3D; -\sum_{i&#x3D;1}^{2} (m_{fi} d_i)<br>$$</p><p>$$<br>M_{\dot{\xi}} &#x3D; -\frac{1}{2} \rho V^2 \sum_{i&#x3D;1}^{2} \left( S_i \frac{\partial C_{Li}}{\partial \dot{\xi}} d_i \right)<br>$$</p><p>$$<br>M_\xi &#x3D; -\frac{1}{2} \rho V^2 \sum_{i&#x3D;1}^{2} \left( S_i \frac{\partial C_{Li}}{\partial \dot{\xi}} d_i \right)<br>$$</p><p>$$<br>M_{\ddot{\theta}} &#x3D; J_{yy} + \sum_{i&#x3D;1}^{2} (m_{fi} d_i^2)<br>$$</p><p>$$<br>M_{\dot{\theta}} &#x3D; \frac{1}{2} \rho V^2 \sum_{i&#x3D;1}^{2} \left( S_i \frac{\partial C_{Li}}{\partial \dot{\xi}} d_i \right) - \sum_{i&#x3D;1}^{2} (m_{fi} V d_i)<br>$$</p><p>$$<br>M_\theta &#x3D; -\frac{1}{2} \rho V^2 \sum_{i&#x3D;1}^{2} \left( S_i \frac{\partial C_{Li}}{\partial \dot{\xi}} d_i \right)<br>$$</p><p>$$<br>M_{fp-\alpha i} &#x3D; -\frac{1}{2} \rho V^2 S_{fpi} \frac{\partial C_{fp-Li}(\alpha_{fpi})}{\partial \alpha_{fpi}} d_i<br>$$</p><p>通过MATLAB进行计算得到：</p><ul><li>前后水翼的质量 m_f1 和 m_f2: 0.055652    0.011261</li><li>水翼的面积 S_1 和 S_2: 0.004374   0.0017069</li><li>襟翼的面积 S_fp: 0.0008748</li><li>$Z_{\ddot{\xi}}$: 1.5669</li><li>$Z_{\dot{\xi}}$: 31.4649</li><li>$Z_{\xi}$: 31.4649</li><li>$Z_{\ddot{\theta}}$: -0.020074</li><li>$Z_{\dot{\theta}}$: 31.4649</li><li>$Z_{\theta}$: 31.4649</li><li>$Z_{f p-\alpha i}$: 1.0973</li><li>$M_{\ddot{\xi}}$: -0.020074</li><li>$M_{\dot{\xi}}$: -9.4395</li><li>$M_{\xi}$: -9.4395</li><li>$M_{\ddot{\theta}}$: 0.14602</li><li>$M_{\dot{\theta}}$: 9.3271</li><li>$M_{\theta}$: -9.4395</li><li>$M_{f p-\alpha i}$: -0.65841</li></ul><p>给定的工作点为 θ &#x3D; 2° 、v &#x3D; 5.6m &#x2F; s、ξ &#x3D; －0.045 m，我们将这些值分别代入上述线性化后的数学模型中，我们可以得到：</p><ol><li>对于 $Z(\ddot{\xi}, \dot{\xi}, \xi, \ddot{\theta}, \dot{\theta}, \theta)$ 线性化后的方程是：</li></ol><p>$$<br>{1.5669 \ddot{\xi}+31.4649 \dot{\xi}+31.4649 (\xi-0.045)-0.020074 \ddot{\theta}+31.4649 \dot{\theta}+31.4649 (\theta-0.0349)&#x3D;-1.0973 (\alpha_{f p 1}+\alpha_{f p 2})+Z_{w}}<br>$$</p><ol start="2"><li>对于 $M(\ddot{\xi}, \dot{\xi}, \xi, \ddot{\theta}, \dot{\theta}, \theta)$ 线性化后的方程是：</li></ol><p>$$<br>{-0.020074 \ddot{\xi}-9.4395 \dot{\xi}-9.4395 (\xi-0.045)+0.14602 \ddot{\theta}+9.3271 \dot{\theta}-9.439 (\theta-0.0349)&#x3D;-0.65841 (\alpha_{f p 1}+\alpha_{f p 2})+M_{w}}<br>$$</p><p>其中，我们假设了 ${\dot{\xi}<em>{d} &#x3D; \ddot{\xi}</em>{d} &#x3D; \dot{\theta}<em>{d} &#x3D; \ddot{\theta}</em>{d} &#x3D; 0}$，因为在平稳工作点，速度和加速度通常被设为零。并且我们使用了小角度近似，将2°转换为弧度，得到 ${\theta_{d} &#x3D; 2 \times \pi &#x2F; 180 &#x3D; 0.0349}$rad。</p><p>注意，这些方程中的变量${\ddot{\xi}<em>{\delta}, \dot{\xi}</em>{\delta}, \xi_{\delta}, \ddot{\theta}<em>{\delta}, \dot{\theta}</em>{\delta}, \theta_{\delta}}$是在平衡点 $\ddot{\xi}<em>{d}, \dot{\xi}</em>{d}, \xi_{d}, \ddot{\theta}<em>{d}, \dot{\theta}</em>{d}, \theta_{d}$ 周围的小幅度变动，而这些平衡点的具体数值已经根据给出的实际工作点来确定。最后，这些方程中的 ${\alpha_{f p 1}, \alpha_{f p 2}, Z_{w}, M_{w}}$ 是控制输入和干扰。代入方程得到：<br>$$<br>1.5669 \ddot{\xi}+31.4649 \dot{\xi}+31.4649 (\xi-0.045)-0.020074 \ddot{\theta}+31.4649 \dot{\theta}+31.4649 (\theta-0.0349)&#x3D;-1.0973 (\alpha_{f p 1}+\alpha_{f p 2})+Z_{W}<br>$$</p><p>$$<br>-0.020074 \ddot{\xi}-9.4395 \dot{\xi}-9.4395 (\xi-0.045)+0.14602 \ddot{\theta}+9.3271 \dot{\theta}-9.439 (\theta-0.0349)&#x3D;-0.65841 (\alpha_{f p 1}+\alpha_{f p 2})+M_{w}<br>$$</p><h3 id="状态空间方程"><a href="#状态空间方程" class="headerlink" title="状态空间方程"></a>状态空间方程</h3><p>状态向量 $x$ 和控制输入向量 $u$ 已经给出，同时还给出了扰动向量 $W$。</p><p>将得到的方程整理成 $\dot{x}&#x3D;Ax+Bu+DW$ 的形式，其中 $A$ 是系统矩阵，$B$ 是输入矩阵，$D$ 是扰动矩阵。把每一个方程中的线性项和非线性项分开,确定矩阵 $A$, $B$ 和 $D$。</p><p>由于方程中有常数项，也就是 $(x_{1}-0.045)$ 和 $(x_{3}-0.0349)$。可以通过在每个方程中加上这些常数项的系数，然后从右侧减去相同的项来消除这些项。 所以，状态方程可以写成以下的形式：<br>$$<br>\dot{x_{1}}&#x3D;x_{2}<br>$$</p><p>$$<br>\dot{x_{2}}&#x3D;(1&#x2F;1.5669)[ -31.4649 x_{2}-31.4649 x_{1}+0.020074 x_{4}-31.4649 x_{4}-31.4649 x_{3}+1.0973 (\alpha_{f p 1}+\alpha_{f p 2})-Z_{W}+1.5669<em>0.045+31.4649</em>0.0349]<br>$$</p><p>$$<br>\dot{x_{3}}&#x3D;x_{4}<br>$$</p><p>$$<br>\dot{x_{4}}&#x3D;(1&#x2F;0.14602)[0.020074 x_{2}+9.4395 x_{2}+9.4395 x_{1}-9.3271 x_{4}+9.4395 x_{3}+0.65841 (\alpha_{f p 1}+\alpha_{f p 2})-M_{w}+0.14602<em>0.045-9.4395</em>0.0349]<br>$$</p><p>现在可以得到 $A$, $B$ 和 $D$ 矩阵了：</p><p>$$A&#x3D;\begin{bmatrix}<br>0 &amp; 1 &amp; 0 &amp; 0 \<br>-31.4649&#x2F;1.5669 &amp; -31.4649&#x2F;1.5669 &amp; -31.4649&#x2F;1.5669 &amp; (0.020074-31.4649)&#x2F;1.5669 \<br>0 &amp; 0 &amp; 0 &amp; 1 \<br>9.4395&#x2F;0.14602 &amp; 0.020074&#x2F;0.14602 &amp; 9.4395&#x2F;0.14602 &amp; -9.3271&#x2F;0.14602<br>\end{bmatrix}$$</p><p>$$B&#x3D;\begin{bmatrix}<br>0 &amp; 0 \<br>1.0973&#x2F;1.5669 &amp; 1.0973&#x2F;1.5669 \<br>0 &amp; 0 \<br>0.65841&#x2F;0.14602 &amp; 0.65841&#x2F;0.14602<br>\end{bmatrix}$$</p><p>$$D&#x3D;\begin{bmatrix}<br>0 &amp; 0 \<br>-1&#x2F;1.5669 &amp; 0 \<br>0 &amp; 0 \<br>0 &amp; -1&#x2F;0.14602<br>\end{bmatrix}$$</p><p>所以，我们得到了水翼航行器纵向运动的连续状态方程是：</p><p>$$\dot{x}&#x3D;A x+B u+D W$$</p><p>$$y&#x3D;Cx$$</p><p>其中，$$x&#x3D;\begin{bmatrix}<br>\xi \<br>\dot{\xi} \<br>\theta \<br>\dot{\theta}<br>\end{bmatrix}$, $u&#x3D;\begin{bmatrix}<br>\alpha_{f p 1} \<br>\alpha_{f p 2}<br>\end{bmatrix}$,$W&#x3D;\begin{bmatrix}<br>Z_{w} \<br>M_{w}<br>\end{bmatrix}$$</p><p>$A,B,D$ 如上所述,$C$为单位矩阵。即方程为：</p><p>$$<br>\begin{aligned}<br>{\left[\begin{array}{l}<br>\dot{x}<em>{1} \<br>\dot{x}</em>{2} \<br>\dot{x}<em>{3} \<br>\dot{x}</em>{4}<br>\end{array}\right]&#x3D;} &amp; {\left[\begin{array}{cccc}<br>0 &amp; 1 &amp; 0 &amp; 0 \<br>-31.4649 &#x2F; 1.5669 &amp; -31.4649 &#x2F; 1.5669 &amp; -31.4649 &#x2F; 1.5669 &amp; (0.020074-31.4649) &#x2F; 1.5669 \<br>0 &amp; 0 &amp; 0 &amp; 1 \<br>9.4395 &#x2F; 0.14602 &amp; 0.020074 &#x2F; 0.14602 &amp; 9.4395 &#x2F; 0.14602 &amp; -9.3271 &#x2F; 0.14602<br>\end{array}\right]\left[\begin{array}{l}<br>x_{1} \<br>x_{2} \<br>x_{3} \<br>x_{4}<br>\end{array}\right] } \<br>&amp; +\left[\begin{array}{cc}<br>0 &amp; 0 \<br>1.0973 &#x2F; 1.5669 &amp; 1.0973 &#x2F; 1.5669 \<br>0 &amp; 0 \<br>0.65841 &#x2F; 0.14602 &amp; 0.65841 &#x2F; 0.14602<br>\end{array}\right]\left[\begin{array}{l}<br>\alpha_{f p 1} \<br>\alpha_{f p 2}<br>\end{array}\right]+\left[\begin{array}{cc}<br>0 &amp; 0 \<br>-1 &#x2F; 1.5669 &amp; 0 \<br>0 &amp; 0 \<br>0 &amp; -1 &#x2F; 0.14602<br>\end{array}\right]\left[\begin{array}{l}<br>Z_{w} \<br>M_{w}<br>\end{array}\right]<br>\end{aligned}<br>$$<br>[1]杨洋. 全浸式水翼艇纵向运动鲁棒滑模重复控制设计[D].哈尔滨工程大学,2020.</p>]]></content>
      
      
      
        <tags>
            
            <tag> UAV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>M5STACK上手</title>
      <link href="/4.M5STACK%E4%B8%8A%E6%89%8B/"/>
      <url>/4.M5STACK%E4%B8%8A%E6%89%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="M5STACK上手"><a href="#M5STACK上手" class="headerlink" title="M5STACK上手"></a>M5STACK上手</h1><h1 id="一、已封装M5函数"><a href="#一、已封装M5函数" class="headerlink" title="一、已封装M5函数"></a>一、已封装M5函数</h1><h1 id="1-system"><a href="#1-system" class="headerlink" title="1.system"></a>1.system</h1><h2 id="begin"><a href="#begin" class="headerlink" title="begin()"></a>begin()</h2><p><strong>功能:</strong></p><p>初始化 LCD; 初始化 SD 卡; 清串口缓冲区,设置串口波特率为 115200; 初始化 I2C; 设置 MBus模式; 初始化 Axp电源管理芯片; 初始化触屏功能; 初始化 RTC</p><p><strong>函数原型:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void begin(bool LCDEnable = true, bool SDEnable = true, bool SerialEnable = true, bool I2CEnable = false, mbus_mode_t mode = kMBusModeOutput)</span><br></pre></td></tr></table></figure><p><strong>使用示例:</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;M5Core2.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  M<span class="number">5.</span><span class="built_in">begin</span>();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h2 id="update"><a href="#update" class="headerlink" title="update()"></a>update()</h2><p><strong>功能:</strong></p><p>读取按键的状态</p><p><strong>函数原型:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void update()</span><br></pre></td></tr></table></figure><p><strong>使用示例:</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;M5Core2.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  M<span class="number">5.</span><span class="built_in">begin</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  M<span class="number">5.</span><span class="built_in">update</span>();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h2 id="shutdown"><a href="#shutdown" class="headerlink" title="shutdown()"></a>shutdown()</h2><p>函数重载1:关闭电源,再次启动需要通过PWR按键唤醒</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void shutdown()</span><br></pre></td></tr></table></figure><p>函数重载2:关闭电源,根据传入的延时秒数,在延时结束后通过RTC唤醒设备。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int shutdown( int seconds )</span><br></pre></td></tr></table></figure><p>函数重载3:关闭电源,传入指定了某个时间点的RTC时间结构体,当符合该时间的<code>时</code>,<code>分</code>,<code>秒</code>的时候通过RTC唤醒设备。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int shutdown( const RTC_TimeTypeDef &amp;RTC_TimeStruct)</span><br></pre></td></tr></table></figure><p>函数重载4:关闭电源,传入指定了某个时间点的RTC时间结构体,当同时符合该时间点的<code>周数</code>,<code>天数</code>,<code>时间</code>的时通过RTC唤醒设备。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int shutdown( const RTC_DateTypeDef &amp;RTC_DateStruct, const RTC_TimeTypeDef &amp;RTC_TimeStruct)</span><br></pre></td></tr></table></figure><p><strong>使用示例:</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;M5Core2.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">RTC_TimeTypeDef RTCtime;</span><br><span class="line">RTC_TimeTypeDef RTCtime_Now;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> timeStrbuff[<span class="number">64</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span></span>&#123;</span><br><span class="line">  M<span class="number">5.</span><span class="built_in">begin</span>(<span class="literal">true</span>,<span class="literal">true</span>,<span class="literal">true</span>,<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">  RTCtime.Hours = <span class="number">10</span>;</span><br><span class="line">  RTCtime.Minutes = <span class="number">30</span>;</span><br><span class="line">  RTCtime.Seconds = <span class="number">45</span>;</span><br><span class="line"></span><br><span class="line">  M<span class="number">5.L</span>cd.<span class="built_in">setCursor</span>(<span class="number">0</span>,<span class="number">80</span>);</span><br><span class="line">  M<span class="number">5.L</span>cd.<span class="built_in">println</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">  M<span class="number">5.L</span>cd.<span class="built_in">println</span>(<span class="string">&quot;BtnA:  shutdown, use power button to turn back on&quot;</span>);</span><br><span class="line">  M<span class="number">5.L</span>cd.<span class="built_in">println</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">  M<span class="number">5.L</span>cd.<span class="built_in">println</span>(<span class="string">&quot;BtnB:  shutdown, wake up after 5 seconds&quot;</span>);</span><br><span class="line">  M<span class="number">5.L</span>cd.<span class="built_in">println</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">  M<span class="number">5.L</span>cd.<span class="built_in">println</span>(<span class="string">&quot;BtnC:  shutdown, wake up at RTC Time 10:30:45&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span></span>&#123;</span><br><span class="line">  M<span class="number">5.</span><span class="built_in">update</span>();</span><br><span class="line">  <span class="keyword">if</span>(M<span class="number">5.</span>BtnA.<span class="built_in">wasPressed</span>())&#123;</span><br><span class="line">    M<span class="number">5.</span><span class="built_in">shutdown</span>();</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span>(M<span class="number">5.</span>BtnB.<span class="built_in">wasPressed</span>())&#123;</span><br><span class="line">    M<span class="number">5.</span><span class="built_in">shutdown</span>(<span class="number">5</span>);</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span>(M<span class="number">5.</span>BtnC.<span class="built_in">wasPressed</span>())&#123;</span><br><span class="line">    M<span class="number">5.</span><span class="built_in">shutdown</span>(RTCtime);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  M<span class="number">5.L</span>cd.<span class="built_in">setCursor</span>(<span class="number">0</span>,<span class="number">140</span>);</span><br><span class="line">  M<span class="number">5.</span>Rtc.<span class="built_in">GetTime</span>(&amp;RTCtime_Now);</span><br><span class="line">  <span class="built_in">sprintf</span>(timeStrbuff,<span class="string">&quot;RTC Time Now is %02d:%02d:%02d&quot;</span>,</span><br><span class="line">         RTCtime_Now.Hours,RTCtime_Now.Minutes,RTCtime_Now.Seconds);</span><br><span class="line">  M<span class="number">5.L</span>cd.<span class="built_in">println</span>(timeStrbuff);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Core2 屏幕像素为 320x240,以屏幕左上角为原点 (0,0)</strong></p><p>颜色代码:</p><table><thead><tr><th align="center">定义</th><th align="center">16进制值</th><th align="center">R</th><th align="center">G</th><th align="center">B</th></tr></thead><tbody><tr><td align="center">BLACK</td><td align="center">0x0000</td><td align="center">0</td><td align="center">0</td><td align="center">0</td></tr><tr><td align="center">NAVY</td><td align="center">0x000F</td><td align="center">0</td><td align="center">0</td><td align="center">128</td></tr><tr><td align="center">DARKGREEN</td><td align="center">0x03E0</td><td align="center">0</td><td align="center">128</td><td align="center">0</td></tr><tr><td align="center">MAROON</td><td align="center">0x7800</td><td align="center">128</td><td align="center">0</td><td align="center">0</td></tr><tr><td align="center">PURPLE</td><td align="center">0x780F</td><td align="center">128</td><td align="center">0</td><td align="center">128</td></tr><tr><td align="center">OLIVE</td><td align="center">0x7BE0</td><td align="center">128</td><td align="center">128</td><td align="center">0</td></tr><tr><td align="center">LIGHTGREY</td><td align="center">0xC618</td><td align="center">192</td><td align="center">192</td><td align="center">192</td></tr><tr><td align="center">DARKGREY</td><td align="center">0x7BEF</td><td align="center">128</td><td align="center">128</td><td align="center">128</td></tr><tr><td align="center">BLUE</td><td align="center">0x001F</td><td align="center">0</td><td align="center">0</td><td align="center">255</td></tr><tr><td align="center">GREENYELLOW</td><td align="center">0xB7E0</td><td align="center">180</td><td align="center">255</td><td align="center">0</td></tr><tr><td align="center">GREEN</td><td align="center">0x07E0</td><td align="center">0</td><td align="center">255</td><td align="center">0</td></tr><tr><td align="center">YELLOW</td><td align="center">0xFFE0</td><td align="center">255</td><td align="center">255</td><td align="center">0</td></tr><tr><td align="center">ORANGE</td><td align="center">0xFDA0</td><td align="center">255</td><td align="center">180</td><td align="center">0</td></tr><tr><td align="center">PINK</td><td align="center">0xFC9F</td><td align="center">255</td><td align="center">255</td><td align="center">16</td></tr><tr><td align="center">CYAN</td><td align="center">0x07FF</td><td align="center">0</td><td align="center">255</td><td align="center">255</td></tr><tr><td align="center">DARKCYAN</td><td align="center">0x03EF</td><td align="center">0</td><td align="center">128</td><td align="center">128</td></tr><tr><td align="center">RED</td><td align="center">0xF800</td><td align="center">255</td><td align="center">0</td><td align="center">0</td></tr><tr><td align="center">MAGENTA</td><td align="center">0xF81F</td><td align="center">255</td><td align="center">0</td><td align="center">255</td></tr><tr><td align="center">WHITE</td><td align="center">0xFFFF</td><td align="center">255</td><td align="center">255</td><td align="center">255</td></tr></tbody></table><h1 id="2-AXP192"><a href="#2-AXP192" class="headerlink" title="2.$AXP192$"></a>2.$AXP192$</h1><p>AXP192 是一款高度集成的电源系统管理芯片, 在M5Core2库中封装了一系列电源芯片对周边外设电源控制的API</p><h2 id="SetLcdVoltage"><a href="#SetLcdVoltage" class="headerlink" title="SetLcdVoltage()"></a>SetLcdVoltage()</h2><p><strong>功能:</strong></p><p>设置屏幕电压,调整亮度,参数有效范围 2500-3300</p><p><strong>函数原型:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void SetLcdVoltage(uint16_t voltage)</span><br></pre></td></tr></table></figure><p><strong>使用示例:</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;M5Core2.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  M<span class="number">5.</span><span class="built_in">begin</span>(); <span class="comment">//By default, &quot;M5.begin()&quot; will initialize AXP192 chip</span></span><br><span class="line">  M<span class="number">5.L</span>cd.<span class="built_in">fillScreen</span>(RED);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  M<span class="number">5.</span><span class="built_in">update</span>();</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2500</span>; i&lt;<span class="number">3300</span>;i++)&#123;</span><br><span class="line">    M<span class="number">5.</span>Axp.<span class="built_in">SetLcdVoltage</span>(i);</span><br><span class="line">    <span class="built_in">delay</span>(<span class="number">10</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">3300</span>; i&gt;<span class="number">2500</span>;i--)&#123;</span><br><span class="line">    M<span class="number">5.</span>Axp.<span class="built_in">SetLcdVoltage</span>(i);</span><br><span class="line">    <span class="built_in">delay</span>(<span class="number">10</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h2 id="PowerOff"><a href="#PowerOff" class="headerlink" title="PowerOff()"></a>PowerOff()</h2><p><strong>功能:</strong></p><p>切断所有供电(除RTC外)</p><p><strong>函数原型:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void PowerOff()</span><br></pre></td></tr></table></figure><p><strong>使用示例:</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;M5Core2.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  M<span class="number">5.</span><span class="built_in">begin</span>();</span><br><span class="line">  M<span class="number">5.L</span>cd.<span class="built_in">fillScreen</span>(RED);</span><br><span class="line">  <span class="built_in">delay</span>(<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  M<span class="number">5.</span>Axp.<span class="built_in">PowerOff</span>();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h2 id="deepSleep"><a href="#deepSleep" class="headerlink" title="deepSleep()"></a>deepSleep()</h2><p><strong>功能:</strong></p><p>深度睡眠(恢复后程序将从头开始执行)</p><p><strong>函数原型:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void deepSleep(uint64_t time_in_us)</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">参数</th><th align="center">类型</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">time_in_us</td><td align="center">uint64_t</td><td align="center">睡眠时间</td></tr></tbody></table><p><strong>使用示例:</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;M5Core2.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  M<span class="number">5.</span><span class="built_in">begin</span>();</span><br><span class="line">  M<span class="number">5.L</span>cd.<span class="built_in">println</span>(<span class="string">&quot;Going to deep sleep for 5 seconds.&quot;</span>);</span><br><span class="line">  <span class="built_in">delay</span>(<span class="number">2000</span>);</span><br><span class="line">  M<span class="number">5.</span>Axp.<span class="built_in">DeepSleep</span>(<span class="built_in">SLEEP_SEC</span>(<span class="number">5</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h2 id="lightSleep"><a href="#lightSleep" class="headerlink" title="lightSleep()"></a>lightSleep()</h2><p><strong>功能:</strong></p><p>浅度睡眠(恢复后程序将从下一行继续执行)</p><p><strong>函数原型:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void lightSleep(uint64_t time_in_us)</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">参数</th><th align="center">类型</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">time_in_us</td><td align="center">uint64_t</td><td align="center">睡眠时间</td></tr></tbody></table><p><strong>使用示例:</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;M5Core2.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  M<span class="number">5.</span><span class="built_in">begin</span>();</span><br><span class="line">  M<span class="number">5.L</span>cd.<span class="built_in">println</span>(<span class="string">&quot;Going to light sleep for 5 seconds.&quot;</span>);</span><br><span class="line">  <span class="built_in">delay</span>(<span class="number">2000</span>);</span><br><span class="line">  M<span class="number">5.</span>Axp.<span class="built_in">lightSleep</span>(<span class="built_in">SLEEP_SEC</span>(<span class="number">5</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h2 id="SetLed"><a href="#SetLed" class="headerlink" title="SetLed()"></a>SetLed()</h2><p><strong>功能:</strong></p><p>设置内置LED灯: state &#x3D; 1 为点亮; state &#x3D; 0 为熄灭</p><p><strong>函数原型:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void SetLed(uint8_t state)</span><br></pre></td></tr></table></figure><p><strong>使用示例:</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;M5Core2.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  M<span class="number">5.</span><span class="built_in">begin</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  M<span class="number">5.</span>Axp.<span class="built_in">SetLed</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="built_in">delay</span>(<span class="number">1000</span>);</span><br><span class="line">  M<span class="number">5.</span>Axp.<span class="built_in">SetLed</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="built_in">delay</span>(<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h2 id="SetBusPowerMode"><a href="#SetBusPowerMode" class="headerlink" title="SetBusPowerMode()"></a>SetBusPowerMode()</h2><p><strong>功能:</strong></p><p>设置BUS电源模式,设置0为USB&#x2F;BAT供电,设置1为外部输入供电</p><p><strong>函数原型:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void SetBusPowerMode( uint8_t state )</span><br></pre></td></tr></table></figure><p><strong>使用示例:</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;M5Core2.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  M<span class="number">5.</span><span class="built_in">begin</span>();</span><br><span class="line">  M<span class="number">5.</span>Axp.<span class="built_in">SetBusPowerMode</span>(<span class="number">0</span>);  <span class="comment">//Set the Bus power mode for USB/BAT power supply.  设置Bus电源模式为USB/BAT供电</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h2 id="SetSpkEnable"><a href="#SetSpkEnable" class="headerlink" title="SetSpkEnable()"></a>SetSpkEnable()</h2><p><strong>功能:</strong></p><p>设置扬声器电源启用</p><p><strong>函数原型:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void SetSpkEnable(uint8_t state)</span><br></pre></td></tr></table></figure><p><strong>使用示例:</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;M5Core2.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  M<span class="number">5.</span><span class="built_in">begin</span>();</span><br><span class="line">  M<span class="number">5.</span>Axp.<span class="built_in">SetSpkEnable</span>(<span class="number">1</span>);  <span class="comment">//Power on the speaker.  开启扬声器电源</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h2 id="SetCHGCurrent"><a href="#SetCHGCurrent" class="headerlink" title="SetCHGCurrent()"></a>SetCHGCurrent()</h2><p><strong>功能:</strong></p><p>设置电池充电电流</p><p><strong>函数原型:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void SetCHGCurrent(uint8_t state)</span><br></pre></td></tr></table></figure><h2 id="GetBatVoltage"><a href="#GetBatVoltage" class="headerlink" title="GetBatVoltage()"></a>GetBatVoltage()</h2><p><strong>功能:</strong></p><p>读取电池电压</p><p><strong>函数原型:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">float GetBatVoltage()</span><br></pre></td></tr></table></figure><p><strong>使用示例:</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;M5Core2.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  M<span class="number">5.</span><span class="built_in">begin</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Serial.<span class="built_in">printf</span>(<span class="string">&quot;Bat Voltage:%f\n&quot;</span>, M<span class="number">5.</span>Axp.<span class="built_in">GetBatVoltage</span>());</span><br><span class="line">  <span class="built_in">delay</span>(<span class="number">500</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h2 id="GetBatCurrent"><a href="#GetBatCurrent" class="headerlink" title="GetBatCurrent()"></a>GetBatCurrent()</h2><p><strong>函数原型:</strong></p><p><strong>功能:</strong></p><p>读取电池电流</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">float GetBatCurrent()</span><br></pre></td></tr></table></figure><p><strong>使用示例:</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;M5Core2.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  M<span class="number">5.</span><span class="built_in">begin</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Serial.<span class="built_in">printf</span>(<span class="string">&quot;Bat Current:%f\n&quot;</span>, M<span class="number">5.</span>Axp.<span class="built_in">GetBatCurrent</span>());</span><br><span class="line">  <span class="built_in">delay</span>(<span class="number">500</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h2 id="GetVBusVoltage"><a href="#GetVBusVoltage" class="headerlink" title="GetVBusVoltage()"></a>GetVBusVoltage()</h2><p><strong>功能:</strong></p><p>读取VBUS电压</p><p><strong>函数原型:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">float GetVBusVoltage()</span><br></pre></td></tr></table></figure><p><strong>使用示例:</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;M5Core2.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  M<span class="number">5.</span><span class="built_in">begin</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Serial.<span class="built_in">printf</span>(<span class="string">&quot;VBus Voltage:%f\n&quot;</span>, M<span class="number">5.</span>Axp.<span class="built_in">GetVBusVoltage</span>());</span><br><span class="line">  <span class="built_in">delay</span>(<span class="number">500</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h2 id="GetVBusCurrent"><a href="#GetVBusCurrent" class="headerlink" title="GetVBusCurrent()"></a>GetVBusCurrent()</h2><p><strong>功能:</strong></p><p>读取VBUS电流</p><p><strong>函数原型:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">float GetVBusCurrent()</span><br></pre></td></tr></table></figure><p><strong>使用示例:</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;M5Core2.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  M<span class="number">5.</span><span class="built_in">begin</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Serial.<span class="built_in">printf</span>(<span class="string">&quot;VBus Current:%f\n&quot;</span>, M<span class="number">5.</span>Axp.<span class="built_in">GetVBusCurrent</span>());</span><br><span class="line">  <span class="built_in">delay</span>(<span class="number">500</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h2 id="GetTempInAXP192"><a href="#GetTempInAXP192" class="headerlink" title="GetTempInAXP192()"></a>GetTempInAXP192()</h2><p><strong>功能:</strong></p><p>读取AXP192芯片温度</p><p><strong>函数原型:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">float GetTempInAXP192()</span><br></pre></td></tr></table></figure><p><strong>使用示例:</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;M5Core2.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  M<span class="number">5.</span><span class="built_in">begin</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Serial.<span class="built_in">printf</span>(<span class="string">&quot;AXP192 Temp:%f\n&quot;</span>, M<span class="number">5.</span>Axp.<span class="built_in">GetTempInAXP192</span>());</span><br><span class="line">  <span class="built_in">delay</span>(<span class="number">500</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h2 id="GetBatPower"><a href="#GetBatPower" class="headerlink" title="GetBatPower()"></a>GetBatPower()</h2><p><strong>功能:</strong></p><p>读取电池当前消耗功率</p><p><strong>函数原型:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">float GetBatPower()</span><br></pre></td></tr></table></figure><p><strong>使用示例:</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;M5Core2.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  M<span class="number">5.</span><span class="built_in">begin</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Serial.<span class="built_in">printf</span>(<span class="string">&quot;AXP192 Temp:%f\n&quot;</span>, M<span class="number">5.</span>Axp.<span class="built_in">GetTempInAXP192</span>());</span><br><span class="line">  <span class="built_in">delay</span>(<span class="number">500</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h2 id="GetBatChargeCurrent"><a href="#GetBatChargeCurrent" class="headerlink" title="GetBatChargeCurrent()"></a>GetBatChargeCurrent()</h2><p><strong>功能:</strong></p><p>读取电池充电电流</p><p><strong>函数原型:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">float GetBatChargeCurrent()</span><br></pre></td></tr></table></figure><p><strong>使用示例:</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;M5Core2.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  M<span class="number">5.</span><span class="built_in">begin</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Serial.<span class="built_in">printf</span>(<span class="string">&quot;Bat Charge Current:%f\n&quot;</span>, M<span class="number">5.</span>Axp.<span class="built_in">GetBatChargeCurrent</span>());</span><br><span class="line">  <span class="built_in">delay</span>(<span class="number">500</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h2 id="isCharging"><a href="#isCharging" class="headerlink" title="isCharging()"></a>isCharging()</h2><p><strong>功能:</strong></p><p>检查是否处于充电状态</p><p><strong>函数原型:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bool isCharging()</span><br></pre></td></tr></table></figure><p><strong>使用示例:</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;M5Core2.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  M<span class="number">5.</span><span class="built_in">begin</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Serial.<span class="built_in">printf</span>(<span class="string">&quot;Charging state:%d\n&quot;</span>, M<span class="number">5.</span>Axp.<span class="built_in">isCharging</span>());</span><br><span class="line">  <span class="built_in">delay</span>(<span class="number">500</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;M5Core2.h&gt;</span></span></span><br><span class="line">TFT_eSprite img = <span class="built_in">TFT_eSprite</span>(&amp;M<span class="number">5.L</span>cd);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  M<span class="number">5.</span><span class="built_in">begin</span>();  <span class="comment">//初始化 M5Core2</span></span><br><span class="line">  img.<span class="built_in">deleteSprite</span>();    <span class="comment">//从内存中删除画布</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><h1 id="3-LCD-屏幕"><a href="#3-LCD-屏幕" class="headerlink" title="3.LCD 屏幕"></a>3.LCD 屏幕</h1><p><strong>Core2 屏幕像素为 320x240,以屏幕左上角为原点 (0,0)</strong></p><p>颜色代码:</p><table><thead><tr><th align="center">定义</th><th align="center">16进制值</th><th align="center">R</th><th align="center">G</th><th align="center">B</th></tr></thead><tbody><tr><td align="center">BLACK</td><td align="center">0x0000</td><td align="center">0</td><td align="center">0</td><td align="center">0</td></tr><tr><td align="center">NAVY</td><td align="center">0x000F</td><td align="center">0</td><td align="center">0</td><td align="center">128</td></tr><tr><td align="center">DARKGREEN</td><td align="center">0x03E0</td><td align="center">0</td><td align="center">128</td><td align="center">0</td></tr><tr><td align="center">MAROON</td><td align="center">0x7800</td><td align="center">128</td><td align="center">0</td><td align="center">0</td></tr><tr><td align="center">PURPLE</td><td align="center">0x780F</td><td align="center">128</td><td align="center">0</td><td align="center">128</td></tr><tr><td align="center">OLIVE</td><td align="center">0x7BE0</td><td align="center">128</td><td align="center">128</td><td align="center">0</td></tr><tr><td align="center">LIGHTGREY</td><td align="center">0xC618</td><td align="center">192</td><td align="center">192</td><td align="center">192</td></tr><tr><td align="center">DARKGREY</td><td align="center">0x7BEF</td><td align="center">128</td><td align="center">128</td><td align="center">128</td></tr><tr><td align="center">BLUE</td><td align="center">0x001F</td><td align="center">0</td><td align="center">0</td><td align="center">255</td></tr><tr><td align="center">GREENYELLOW</td><td align="center">0xB7E0</td><td align="center">180</td><td align="center">255</td><td align="center">0</td></tr><tr><td align="center">GREEN</td><td align="center">0x07E0</td><td align="center">0</td><td align="center">255</td><td align="center">0</td></tr><tr><td align="center">YELLOW</td><td align="center">0xFFE0</td><td align="center">255</td><td align="center">255</td><td align="center">0</td></tr><tr><td align="center">ORANGE</td><td align="center">0xFDA0</td><td align="center">255</td><td align="center">180</td><td align="center">0</td></tr><tr><td align="center">PINK</td><td align="center">0xFC9F</td><td align="center">255</td><td align="center">255</td><td align="center">16</td></tr><tr><td align="center">CYAN</td><td align="center">0x07FF</td><td align="center">0</td><td align="center">255</td><td align="center">255</td></tr><tr><td align="center">DARKCYAN</td><td align="center">0x03EF</td><td align="center">0</td><td align="center">128</td><td align="center">128</td></tr><tr><td align="center">RED</td><td align="center">0xF800</td><td align="center">255</td><td align="center">0</td><td align="center">0</td></tr><tr><td align="center">MAGENTA</td><td align="center">0xF81F</td><td align="center">255</td><td align="center">0</td><td align="center">255</td></tr><tr><td align="center">WHITE</td><td align="center">0xFFFF</td><td align="center">255</td><td align="center">255</td><td align="center">255</td></tr></tbody></table><p>类名: Lcd</p><h2 id="begin-1"><a href="#begin-1" class="headerlink" title="begin()"></a>begin()</h2><p><strong>功能:</strong></p><p>初始化以供使用</p><p><strong>函数原型:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void begin()</span><br></pre></td></tr></table></figure><p><strong>注意:</strong><br>如果您不想使用M5.begin() 初始化LCD,请在使用显示器之前调用此函数</p><p><strong>使用示例:</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;M5Core2.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  M<span class="number">5.L</span>cd.<span class="built_in">begin</span>();  <span class="comment">//初始化 M5Stack</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h2 id="sleep"><a href="#sleep" class="headerlink" title="sleep()"></a>sleep()</h2><p>功能:</p><p>将显示切换到节能模式</p><p><strong>函数原型:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void sleep()</span><br></pre></td></tr></table></figure><p><strong>使用示例:</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;M5Core2.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  M<span class="number">5.L</span>cd.<span class="built_in">begin</span>();  <span class="comment">//初始化 M5Core2</span></span><br><span class="line">  M<span class="number">5.L</span>cd.<span class="built_in">sleep</span>();    <span class="comment">//切换至休眠模式</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h2 id="clear"><a href="#clear" class="headerlink" title="clear()"></a>clear()</h2><p><strong>功能:</strong></p><p>清空显示屏所显示的内容</p><p><strong>函数原型:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void clear()</span><br></pre></td></tr></table></figure><p><strong>使用示例:</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;M5Core2.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  M<span class="number">5.L</span>cd.<span class="built_in">begin</span>();  <span class="comment">//初始化 M5Core2</span></span><br><span class="line">  M<span class="number">5.L</span>cd.<span class="built_in">fillScreen</span>(RED);</span><br><span class="line">  <span class="built_in">delay</span>(<span class="number">1000</span>);</span><br><span class="line">  M<span class="number">5.L</span>cd.<span class="built_in">clear</span>();    <span class="comment">//清空显示屏所显示的内容</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h2 id="wakeup"><a href="#wakeup" class="headerlink" title="wakeup()"></a>wakeup()</h2><p><strong>功能:</strong></p><p>从节能模式恢复显示</p><p><strong>函数原型:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void wakeup()</span><br></pre></td></tr></table></figure><p><strong>使用示例:</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;M5Core2.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  M<span class="number">5.L</span>cd.<span class="built_in">begin</span>();  <span class="comment">//初始化 M5Core2</span></span><br><span class="line">  M<span class="number">5.L</span>cd.<span class="built_in">wakeup</span>();    <span class="comment">//从节能模式恢复显示</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h2 id="hight"><a href="#hight" class="headerlink" title="hight()"></a>hight()</h2><p><strong>功能:</strong></p><p>返回屏幕高度</p><p><strong>函数原型:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void hight()</span><br></pre></td></tr></table></figure><p><strong>使用示例:</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;M5Core2.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  M<span class="number">5.</span><span class="built_in">begin</span>();   <span class="comment">//初始化 M5Core2</span></span><br><span class="line">  M<span class="number">5.L</span>cd.<span class="built_in">print</span>(M<span class="number">5.L</span>cd.<span class="built_in">height</span>());    <span class="comment">//在屏幕上显示屏幕的高度</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h2 id="width"><a href="#width" class="headerlink" title="width()"></a>width()</h2><p><strong>功能:</strong></p><p>返回屏幕宽度</p><p><strong>函数原型:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void width()</span><br></pre></td></tr></table></figure><p><strong>使用示例:</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;M5Core2.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  M<span class="number">5.</span><span class="built_in">begin</span>();   <span class="comment">//初始化 M5Core2</span></span><br><span class="line">  M<span class="number">5.L</span>cd.<span class="built_in">print</span>(M<span class="number">5.L</span>cd.<span class="built_in">width</span>());    <span class="comment">//在屏幕上显示屏幕的宽度</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h2 id="getCursorX"><a href="#getCursorX" class="headerlink" title="getCursorX()"></a>getCursorX()</h2><p><strong>功能:</strong></p><p>获取字符末尾处的x坐标</p><p><strong>函数原型:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int16_t getCursorX()</span><br></pre></td></tr></table></figure><p><strong>注意:</strong><br>不适用于drawNumber()</p><p><strong>使用示例:</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;M5Core2.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  M<span class="number">5.</span><span class="built_in">begin</span>();  <span class="comment">//初始化 M5Core2</span></span><br><span class="line">  M<span class="number">5.L</span>cd.<span class="built_in">print</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">  <span class="type">int</span> X = M<span class="number">5.L</span>cd.<span class="built_in">getCursorX</span>();</span><br><span class="line">  M<span class="number">5.L</span>cd.<span class="built_in">print</span>(X);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h2 id="getCursorY"><a href="#getCursorY" class="headerlink" title="getCursorY()"></a>getCursorY()</h2><p><strong>功能:</strong></p><p>获取字符末尾处的y坐标</p><p><strong>函数原型:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int16_t getCursorY()</span><br></pre></td></tr></table></figure><p><strong>注意:</strong><br>不适用于drawNumber()</p><p><strong>使用示例:</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;M5Core2.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  M<span class="number">5.</span><span class="built_in">begin</span>();  <span class="comment">//初始化 M5Core2</span></span><br><span class="line">  M<span class="number">5.L</span>cd.<span class="built_in">print</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">  <span class="type">int</span> X = M<span class="number">5.L</span>cd.<span class="built_in">getCursorY</span>();</span><br><span class="line">  M<span class="number">5.L</span>cd.<span class="built_in">print</span>(Y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h2 id="getRotation"><a href="#getRotation" class="headerlink" title="getRotation()"></a>getRotation()</h2><p><strong>功能:</strong></p><p>返回屏幕旋转方向</p><p><strong>函数原型:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uint8_t getRotation()</span><br></pre></td></tr></table></figure><p><strong>使用示例:</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;M5Core2.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  M<span class="number">5.</span><span class="built_in">begin</span>();  <span class="comment">//初始化 M5Core2</span></span><br><span class="line">  M<span class="number">5.L</span>cd.<span class="built_in">print</span>(M<span class="number">5.L</span>cd.<span class="built_in">getRotation</span>());    <span class="comment">//在屏幕上输出屏幕的旋转方向</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h2 id="getTextDatum"><a href="#getTextDatum" class="headerlink" title="getTextDatum()"></a>getTextDatum()</h2><p><strong>功能:</strong></p><p>返回文字对齐方式( 为上方列表中对齐方式的编号 )</p><p><strong>函数原型:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">textdatum_t getRotation()</span><br></pre></td></tr></table></figure><p><strong>使用示例:</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;M5Core2.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  M<span class="number">5.</span><span class="built_in">begin</span>();  <span class="comment">//初始化 M5Core2</span></span><br><span class="line">  M<span class="number">5.L</span>cd.<span class="built_in">setTextDatum</span>(MC_DATUM);    <span class="comment">//设置文字的对齐方式</span></span><br><span class="line">  M<span class="number">5.L</span>cd.<span class="built_in">drawString</span>(<span class="string">&quot;hello&quot;</span>, <span class="number">160</span>, <span class="number">120</span>, <span class="number">2</span>);    <span class="comment">//在(160,120)处以2号字体打印字符串hello</span></span><br><span class="line">  M<span class="number">5.L</span>cd.<span class="built_in">print</span>(M<span class="number">5.L</span>cd.<span class="built_in">getTextDatum</span>());    <span class="comment">//屏幕打印获取到的文字对齐方式</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h2 id="setCursor"><a href="#setCursor" class="headerlink" title="setCursor()"></a>setCursor()</h2><p><strong>功能:</strong></p><p>设置文本光标在(x,y)处</p><p><strong>函数原型:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void setCursor(int16_t x, int16_t y)</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">参数</th><th align="center">类型</th><th align="center">类型</th></tr></thead><tbody><tr><td align="center">x</td><td align="center">int16_t</td><td align="center">x坐标(像素)</td></tr><tr><td align="center">y</td><td align="center">int16_t</td><td align="center">y坐标(像素)</td></tr></tbody></table><p><strong>使用示例:</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;M5Core2.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  M<span class="number">5.</span><span class="built_in">begin</span>();             <span class="comment">//初始化 M5Core2</span></span><br><span class="line">  M<span class="number">5.L</span>cd.<span class="built_in">setCursor</span>(<span class="number">0</span>, <span class="number">30</span>);</span><br><span class="line">  M<span class="number">5.L</span>cd.<span class="built_in">printf</span>(<span class="string">&quot;Hello M5&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h2 id="setRotation"><a href="#setRotation" class="headerlink" title="setRotation()"></a>setRotation()</h2><p><strong>功能:</strong></p><p>旋转屏幕</p><p><strong>函数原型:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void setRotation(uint8_t m)</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">参数</th><th align="center">类型</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">m</td><td align="center">uint8_t</td><td align="center">旋转角度 ( * 90°)</td></tr></tbody></table><p><strong>注意:</strong></p><ol><li>旋转角度为90°的倍数</li><li>0-3为顺时针旋转,4-7逆时针旋转(默认为1)</li><li>需要在显示前设置</li></ol><p><strong>使用示例:</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;M5Core2.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  M<span class="number">5.</span><span class="built_in">begin</span>();             <span class="comment">//初始化 M5Core2</span></span><br><span class="line">  M<span class="number">5.L</span>cd.<span class="built_in">setRotation</span>(<span class="number">2</span>);  <span class="comment">//将屏幕顺时针旋转180度(2*90)</span></span><br><span class="line">  M<span class="number">5.L</span>cd.<span class="built_in">fillEllipse</span>(<span class="number">160</span>, <span class="number">100</span>, <span class="number">60</span>, <span class="number">100</span>, YELLOW);    <span class="comment">//在(160,100)处创建一个长轴,短轴分别为60,100黄色椭圆</span></span><br><span class="line">  <span class="built_in">delay</span>(<span class="number">1000</span>);</span><br><span class="line">  M<span class="number">5.L</span>cd.<span class="built_in">setRotation</span>(<span class="number">1</span>);  <span class="comment">//将屏幕恢复为默认显示状态</span></span><br><span class="line">  M<span class="number">5.L</span>cd.<span class="built_in">fillEllipse</span>(<span class="number">160</span>, <span class="number">100</span>, <span class="number">60</span>, <span class="number">100</span>, GREEN);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h2 id="SetLcdVoltage-1"><a href="#SetLcdVoltage-1" class="headerlink" title="SetLcdVoltage()"></a>SetLcdVoltage()</h2><p>功能:</p><p>设置屏幕亮度</p><p><strong>函数原型:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void SetLcdVoltage(uint16_t voltage)</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">参数</th><th align="center">类型</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">voltage</td><td align="center">uint16_t</td><td align="center">电压值</td></tr></tbody></table><p><strong>注意:</strong><br>电压值取值范围(2500~3300)</p><p><strong>使用示例:</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;M5Core2.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  M<span class="number">5.</span><span class="built_in">begin</span>();</span><br><span class="line">  M<span class="number">5.L</span>cd.<span class="built_in">fillScreen</span>(RED);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  M<span class="number">5.</span><span class="built_in">update</span>();</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2500</span>; i&lt;<span class="number">3300</span>;i++)&#123;</span><br><span class="line">    M<span class="number">5.</span>Axp.<span class="built_in">SetLcdVoltage</span>(i);  <span class="comment">//每隔10ms设置一次电压值</span></span><br><span class="line">    <span class="built_in">delay</span>(<span class="number">10</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">3300</span>; i&gt;<span class="number">2500</span>;i--)&#123;</span><br><span class="line">    M<span class="number">5.</span>Axp.<span class="built_in">SetLcdVoltage</span>(i);</span><br><span class="line">    <span class="built_in">delay</span>(<span class="number">10</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h2 id="alphaBlend"><a href="#alphaBlend" class="headerlink" title="alphaBlend()"></a>alphaBlend()</h2><p><strong>功能:</strong></p><p>设置透明度,混合前景和背景色.</p><p><strong>函数原型:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uint16_t alphaBlend(uint8_t alpha, uint16_t fgc, uint16_t bgc)</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">参数</th><th align="center">描述</th><th align="center">类型</th></tr></thead><tbody><tr><td align="center">alpha</td><td align="center">uint8_t</td><td align="center">透明度</td></tr><tr><td align="center">fgc</td><td align="center">uint16_t</td><td align="center">前景色</td></tr><tr><td align="center">bgc</td><td align="center">uint16_t</td><td align="center">背景色</td></tr></tbody></table><p><strong>使用示例:</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;M5Core2.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  M<span class="number">5.L</span>cd.<span class="built_in">begin</span>();  <span class="comment">//初始化 M5Core2</span></span><br><span class="line">  M<span class="number">5.L</span>cd.<span class="built_in">fillScreen</span>(M<span class="number">5.L</span>cd.<span class="built_in">alphaBlend</span>(<span class="number">128</span>, <span class="number">0X00FF00</span>, <span class="number">0XFF0000</span>));</span><br><span class="line">  <span class="comment">//设置前景、背景色分别为0X00FF00,0XFF0000 透明度为128,并填充至整个屏幕</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h2 id="setFreeFont"><a href="#setFreeFont" class="headerlink" title="setFreeFont()"></a>setFreeFont()</h2><p><strong>功能:</strong></p><p>设置要使用的GFX字体</p><p><strong>函数原型:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void setFreeFont(const GFXfont *f)</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">参数</th><th align="center">类型</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">GFXfont *f</td><td align="center">const</td><td align="center">字体名称</td></tr></tbody></table><p><strong>使用示例:</strong></p><h2 id="loadFont"><a href="#loadFont" class="headerlink" title="loadFont()"></a>loadFont()</h2><p><strong>功能:</strong></p><p>从VLW文件加载字体</p><p><strong>函数原型:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void loadFont(String fontName, bool flash)</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">参数</th><th align="center">类型</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">fontName</td><td align="center">String</td><td align="center">字体名称</td></tr><tr><td align="center">flash</td><td align="center">bool</td><td align="center">文件来源</td></tr></tbody></table><p><strong>使用示例:</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;M5Core2.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  M<span class="number">5.</span><span class="built_in">begin</span>();  <span class="comment">//初始化 M5Core2</span></span><br><span class="line">  M<span class="number">5.L</span>cd.<span class="built_in">loadFont</span>(<span class="string">&quot;filename&quot;</span>, SD);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h2 id="unloadFont"><a href="#unloadFont" class="headerlink" title="unloadFont()"></a>unloadFont()</h2><p><strong>功能:</strong></p><p>卸载字体</p><p><strong>函数原型:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void unloadFont()</span><br></pre></td></tr></table></figure><p><strong>使用示例:</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;M5Core2.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  M<span class="number">5.</span><span class="built_in">begin</span>();  <span class="comment">//初始化 M5Core2</span></span><br><span class="line">  M<span class="number">5.L</span>cd.<span class="built_in">unloadFont</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h2 id="fontsLoaded"><a href="#fontsLoaded" class="headerlink" title="fontsLoaded()"></a>fontsLoaded()</h2><p><strong>功能:</strong></p><p>返回是否加载自己的字体</p><p><strong>函数原型:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uint16_t fontsLoaded(void)</span><br></pre></td></tr></table></figure><p><strong>返回值:</strong></p><p>返回显示字体的编码的16进制值</p><p><strong>使用示例:</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;M5Core2.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  M<span class="number">5.</span><span class="built_in">begin</span>();  <span class="comment">//初始化 M5Core2</span></span><br><span class="line">  M<span class="number">5.L</span>cd.<span class="built_in">print</span>(M<span class="number">5.L</span>cd.<span class="built_in">fontsLoaded</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h2 id="fillScreen"><a href="#fillScreen" class="headerlink" title="fillScreen()"></a>fillScreen()</h2><p><strong>功能:</strong></p><p>以指定的颜色填充整个屏幕</p><p><strong>函数原型:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void fillScreen(uint32_t color)</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">参数</th><th align="center">类型</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">color</td><td align="center">uint32_t</td><td align="center">颜色值</td></tr></tbody></table><p><strong>使用示例:</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;M5Core2.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  M<span class="number">5.</span><span class="built_in">begin</span>();  <span class="comment">//初始化 M5Core2</span></span><br><span class="line">  M<span class="number">5.L</span>cd.<span class="built_in">fillScreen</span>(RED);    <span class="comment">//在屏幕上填充红色</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h2 id="invertDisplay"><a href="#invertDisplay" class="headerlink" title="invertDisplay()"></a>invertDisplay()</h2><p><strong>功能:</strong></p><p>以负&#x2F;正方式反转屏幕颜色</p><p><strong>函数原型:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void invertDisplay(boolean i)</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">参数</th><th align="center">类型</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">i</td><td align="center">boolean</td><td align="center">反转时为 true</td></tr></tbody></table><p><strong>使用示例:</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;M5Core2.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  M<span class="number">5.</span><span class="built_in">begin</span>();  <span class="comment">//初始化 M5Core2</span></span><br><span class="line">  M<span class="number">5.L</span>cd.<span class="built_in">fillScreen</span>(RED);    <span class="comment">//在屏幕上填充红色</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  M<span class="number">5.L</span>cd.<span class="built_in">invertDisplay</span>(<span class="number">1</span>);    <span class="comment">//开启反转</span></span><br><span class="line">  <span class="built_in">delay</span>(<span class="number">1000</span>);</span><br><span class="line">  M<span class="number">5.L</span>cd.<span class="built_in">invertDisplay</span>(<span class="number">0</span>);    <span class="comment">//关闭反转</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h2 id="color565"><a href="#color565" class="headerlink" title="color565()"></a>color565()</h2><p><strong>功能:</strong></p><p>更改为函数中使用的颜色代码（rgb 565）</p><p><strong>函数原型:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">color565(uint8_t red, uint8_t green, uint8_t blue)</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">参数</th><th align="center">类型</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">red</td><td align="center">uint8_t</td><td align="center">红</td></tr><tr><td align="center">green</td><td align="center">uint8_t</td><td align="center">绿</td></tr><tr><td align="center">blue</td><td align="center">uint8_t</td><td align="center">蓝</td></tr></tbody></table><p><strong>使用示例:</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;M5Core2.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  M<span class="number">5.</span><span class="built_in">begin</span>();  <span class="comment">//初始化 M5Core2</span></span><br><span class="line">  <span class="type">uint16_t</span> colorvalue = <span class="number">0</span>;</span><br><span class="line">  colorvalue = <span class="built_in">color565</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>);</span><br><span class="line">  M<span class="number">5.L</span>cd.<span class="built_in">fillEllipse</span>(<span class="number">160</span>, <span class="number">100</span>, <span class="number">60</span>, <span class="number">100</span>, colorvalue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h1 id="4-Text"><a href="#4-Text" class="headerlink" title="4.Text"></a>4.Text</h1><h2 id="print"><a href="#print" class="headerlink" title="print()"></a>print()</h2><p><strong>功能:</strong></p><p>在屏幕当前位置打印字符串</p><p><strong>函数原型:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">size_t print()</span><br></pre></td></tr></table></figure><p><strong>使用示例:</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;M5Core2.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  M<span class="number">5.</span><span class="built_in">begin</span>();  <span class="comment">//初始化 M5Core2</span></span><br><span class="line">  M<span class="number">5.L</span>cd.<span class="built_in">print</span>(<span class="string">&quot;this is a print text function&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h2 id="textWidth"><a href="#textWidth" class="headerlink" title="textWidth()"></a>textWidth()</h2><p><strong>功能:</strong></p><p>返回文本所占像素宽度</p><p><strong>函数原型:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int16_t textWidth(const String&amp; string)</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">参数</th><th align="center">类型</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">string</td><td align="center">const String&amp;</td><td align="center">字符串</td></tr></tbody></table><p><strong>使用示例:</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;M5Core2.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  M<span class="number">5.</span><span class="built_in">begin</span>();   <span class="comment">//初始化 M5Core2</span></span><br><span class="line">  String text = <span class="string">&quot;hello  &quot;</span>;</span><br><span class="line">  M<span class="number">5.L</span>cd.<span class="built_in">print</span>(text);</span><br><span class="line">  M<span class="number">5.L</span>cd.<span class="built_in">print</span>(M<span class="number">5.L</span>cd.<span class="built_in">textWidth</span>(text));    <span class="comment">//在屏幕上打印字符串数组text所占像素宽度</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h2 id="setTextSize"><a href="#setTextSize" class="headerlink" title="setTextSize()"></a>setTextSize()</h2><p><strong>功能:</strong></p><p>设置显示文字的大小</p><p><strong>函数原型:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void setTextSize(uint8_t s)</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">参数</th><th align="center">类型</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">s</td><td align="center">uint8_t</td><td align="center">文字的大小 (1~7)</td></tr></tbody></table><p><strong>使用示例:</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;M5Core2.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  M<span class="number">5.</span><span class="built_in">begin</span>();  <span class="comment">//初始化 M5Core2</span></span><br><span class="line">  M<span class="number">5.L</span>cd.<span class="built_in">setTextSize</span>(<span class="number">4</span>);    <span class="comment">//设置字体大小为4</span></span><br><span class="line">  M<span class="number">5.L</span>cd.<span class="built_in">print</span>(<span class="string">&quot;Hello M5Core2&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h2 id="setTextColor"><a href="#setTextColor" class="headerlink" title="setTextColor()"></a>setTextColor()</h2><p><strong>功能:</strong></p><p>设置显示文本的前景颜色 &#x2F; 设置显示文本的前景颜色和背景颜色</p><p><strong>函数原型:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void setTextColor(uint16_t color)</span><br><span class="line">void setTextColor(uint16_t color, uint16_t backgroundcolor)</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">参数</th><th align="center">类型</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">color</td><td align="center">uint16_t</td><td align="center">文本的前景颜色</td></tr><tr><td align="center">backgroundcolor</td><td align="center">uint16_t</td><td align="center">文本的背景颜色</td></tr></tbody></table><p><strong>注意:</strong><br>1.如果函数的 backgroundcolor 值没给出,则使用当前的背景颜色<br>2.若不设置文字的颜色，默认为白色</p><p><strong>使用示例:</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;M5Core2.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  M<span class="number">5.</span><span class="built_in">begin</span>(); <span class="comment">//初始化 M5Core2</span></span><br><span class="line">  M<span class="number">5.L</span>cd.<span class="built_in">setTextColor</span>(RED,BLACK);    <span class="comment">//设置文本的前、背景色分别为红色和黑色</span></span><br><span class="line">  <span class="comment">//M5.Lcd.setTextColor(RED);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h2 id="setTextWrap"><a href="#setTextWrap" class="headerlink" title="setTextWrap()"></a><strong>setTextWrap()</strong></h2><p><strong>功能:</strong></p><p>设置自动换行功能</p><p><strong>函数原型:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void setTextWrap(boolean wrapX, boolean wrapY)</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">参数</th><th align="center">类型</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">wrapX</td><td align="center">boolean</td><td align="center">X 方向(默认开启)</td></tr><tr><td align="center">wrapY</td><td align="center">boolean</td><td align="center">Y 方向</td></tr></tbody></table><p><strong>使用示例:</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;M5Core2.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  M<span class="number">5.</span><span class="built_in">begin</span>();   <span class="comment">//初始化 M5Core2</span></span><br><span class="line">  M<span class="number">5.L</span>cd.<span class="built_in">setTextWrap</span>(<span class="literal">true</span>, <span class="literal">true</span>);    <span class="comment">//开启x、y轴自动换行</span></span><br><span class="line">    M<span class="number">5.L</span>cd.<span class="built_in">print</span>(<span class="string">&quot;hello M5Core2 hello M5Core2 hello M5Core2 hello M5Core2 hello M5Core2 hello M5Core2 hello M5Core2 hello M5Core2&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h2 id="setTextPadding"><a href="#setTextPadding" class="headerlink" title="setTextPadding()"></a>setTextPadding()</h2><p><strong>功能:</strong></p><p>填充指定空白宽度(可帮助擦除旧的文本和数字)</p><p><strong>函数原型:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void setTextPadding(uint16_t x_width)</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">参数</th><th align="center">类型</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">x_width</td><td align="center">uint16_t</td><td align="center">空白区域宽度</td></tr></tbody></table><p><strong>使用示例:</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;M5Core2.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  M<span class="number">5.</span><span class="built_in">begin</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  M<span class="number">5.L</span>cd.<span class="built_in">drawString</span>(<span class="string">&quot;Orbitron 32&quot;</span>, <span class="number">160</span>, <span class="number">60</span>, <span class="number">2</span>);</span><br><span class="line">  <span class="built_in">delay</span>(<span class="number">2000</span>);</span><br><span class="line">  M<span class="number">5.L</span>cd.<span class="built_in">setTextPadding</span>(M<span class="number">5.L</span>cd.<span class="built_in">width</span>() - <span class="number">20</span>);</span><br><span class="line">  M<span class="number">5.L</span>cd.<span class="built_in">drawString</span>(<span class="string">&quot;Orbitron 32 with padding&quot;</span>, <span class="number">160</span>, <span class="number">60</span>, <span class="number">2</span>);</span><br><span class="line">  <span class="built_in">delay</span>(<span class="number">2000</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h2 id="setTextDatum"><a href="#setTextDatum" class="headerlink" title="setTextDatum()"></a>setTextDatum()</h2><p><strong>功能:</strong></p><p>设置文本对齐方式</p><p><strong>函数原型:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void setTextDatum(uint8_t datum)</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">参数</th><th align="center">类型</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">TL_DATUM (0)</td><td align="center">uint8_t</td><td align="center">左上角对齐(默认)</td></tr><tr><td align="center">TC_DATUM (1)</td><td align="center">uint8_t</td><td align="center">居中向上对齐</td></tr><tr><td align="center">TR_DATUM (2)</td><td align="center">uint8_t</td><td align="center">右上角对齐</td></tr><tr><td align="center">ML_DATUM (3)</td><td align="center">uint8_t</td><td align="center">中部左对齐</td></tr><tr><td align="center">MC_DATUM (4)</td><td align="center">uint8_t</td><td align="center">中心对齐</td></tr><tr><td align="center">MR_DATUM (5)</td><td align="center">uint8_t</td><td align="center">中部右对齐</td></tr><tr><td align="center">BL_DATUM (6)</td><td align="center">uint8_t</td><td align="center">左下角对齐</td></tr><tr><td align="center">BC_DATUM (7)</td><td align="center">uint8_t</td><td align="center">居中底部对齐</td></tr><tr><td align="center">BR_DATUM (8)</td><td align="center">uint8_t</td><td align="center">右下角对齐</td></tr><tr><td align="center">L_BASELINE (9)</td><td align="center">uint8_t</td><td align="center">左字符基线</td></tr><tr><td align="center">C_BASELINE (10)</td><td align="center">uint8_t</td><td align="center">中字符基线</td></tr><tr><td align="center">R_BASELINE (11)</td><td align="center">uint8_t</td><td align="center">右字符基线</td></tr></tbody></table><p><strong>注意:</strong><br>1.不适用于print()</p><p><strong>使用示例:</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;M5Core2.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  M<span class="number">5.</span><span class="built_in">begin</span>();  <span class="comment">//初始化 M5Core2</span></span><br><span class="line">  M<span class="number">5.L</span>cd.<span class="built_in">setTextDatum</span>(MC_DATUM);    <span class="comment">//设置文本对齐方式为中心对齐</span></span><br><span class="line">  M<span class="number">5.L</span>cd.<span class="built_in">drawString</span>(<span class="string">&quot;hello&quot;</span>, <span class="number">160</span>, <span class="number">120</span>, <span class="number">2</span>);    <span class="comment">//在(160,120)处以2号字体打印字符串hello</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h1 id="5-Draw"><a href="#5-Draw" class="headerlink" title="5.Draw"></a>5.Draw</h1><h2 id="drawFastHLine"><a href="#drawFastHLine" class="headerlink" title="drawFastHLine()"></a>drawFastHLine()</h2><p><strong>功能:</strong></p><p>在(X,Y)处划一条长度为w的color色水平线条</p><p><strong>函数原型:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void drawFastHLine(int32_t x, int32_t y, int32_t w, uint32_t color)</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">参数</th><th align="center">类型</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">x</td><td align="center">int32_t</td><td align="center">坐标 X</td></tr><tr><td align="center">y</td><td align="center">int32_t</td><td align="center">坐标 Y</td></tr><tr><td align="center">w</td><td align="center">int32_t</td><td align="center">宽度(像素)</td></tr><tr><td align="center">color</td><td align="center">uint32_t</td><td align="center">线条颜色</td></tr></tbody></table><p><strong>使用示例:</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;M5Core2.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  M<span class="number">5.</span><span class="built_in">begin</span>();  <span class="comment">//初始化 M5Core2</span></span><br><span class="line">  M<span class="number">5.L</span>cd.<span class="built_in">drawFastHLine</span>(<span class="number">3</span>, <span class="number">100</span>, <span class="number">255</span>, GREEN);    <span class="comment">//在(3,100)处划一条长度为255的绿色水平线条</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h2 id="drawFastVLine"><a href="#drawFastVLine" class="headerlink" title="drawFastVLine()"></a>drawFastVLine()</h2><p><strong>功能:</strong></p><p>在(X,Y)处划一条长度为w的color色 垂直线条</p><p><strong>函数原型:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void drawFastVLine(int32_t x, int32_t y, int32_t w, uint32_t color)</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">参数</th><th align="center">类型</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">x</td><td align="center">int32_t</td><td align="center">坐标 X</td></tr><tr><td align="center">y</td><td align="center">int32_t</td><td align="center">坐标 Y</td></tr><tr><td align="center">w</td><td align="center">int32_t</td><td align="center">宽度(像素)</td></tr><tr><td align="center">color</td><td align="center">uint32_t</td><td align="center">线条颜色（可选）</td></tr></tbody></table><p><strong>使用示例:</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;M5Core2.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  M<span class="number">5.</span><span class="built_in">begin</span>();  <span class="comment">//初始化 M5Core2</span></span><br><span class="line">  M<span class="number">5.L</span>cd.<span class="built_in">drawFastVLine</span>(<span class="number">100</span>, <span class="number">0</span>, <span class="number">255</span>, TFT_GREEN);    <span class="comment">//在(100,0)处划一条长度为255的绿色垂直线条</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h2 id="drawString"><a href="#drawString" class="headerlink" title="drawString()"></a>drawString()</h2><p><strong>功能:</strong></p><p>在(x,y)处显示字符串</p><p><strong>函数原型:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int16_t drawString(const char *string, int32_t poX, int32_t poY, uint8_t font)</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">参数</th><th align="center">类型</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">string</td><td align="center">const char *</td><td align="center">一个字符串</td></tr><tr><td align="center">poX</td><td align="center">int32_t</td><td align="center">X坐标</td></tr><tr><td align="center">poY</td><td align="center">int32_t</td><td align="center">Y坐标</td></tr><tr><td align="center">font</td><td align="center">uint8_t</td><td align="center">字体</td></tr></tbody></table><p><strong>使用示例:</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;M5Core2.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  M<span class="number">5.</span><span class="built_in">begin</span>();  <span class="comment">//初始化 M5Core2</span></span><br><span class="line">  M<span class="number">5.L</span>cd.<span class="built_in">drawString</span>(<span class="string">&quot;Hello M5&quot;</span>, <span class="number">160</span>, <span class="number">100</span>, <span class="number">2</span>);    <span class="comment">//在(160,100)处以2号字体显示字符串Hello M5</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h2 id="drawNumber"><a href="#drawNumber" class="headerlink" title="drawNumber()"></a>drawNumber()</h2><p><strong>功能:</strong></p><p>在(x,y)处显示整数</p><p><strong>函数原型:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void drawNumber(long long_num, int32_t poX, int32_t poY)</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">参数</th><th align="center">类型</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">long_num</td><td align="center">long</td><td align="center">数字</td></tr><tr><td align="center">poX</td><td align="center">int32_t</td><td align="center">X坐标</td></tr><tr><td align="center">poY</td><td align="center">int32_t</td><td align="center">Y坐标</td></tr></tbody></table><p><strong>使用示例:</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;M5Core2.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  M<span class="number">5.</span><span class="built_in">begin</span>();  <span class="comment">//初始化 M5Core2</span></span><br><span class="line">  M<span class="number">5.L</span>cd.<span class="built_in">drawNumber</span>(<span class="number">99</span>, <span class="number">55</span>, <span class="number">100</span>);    <span class="comment">//在(99,55)处显示整数100</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h2 id="drawChar"><a href="#drawChar" class="headerlink" title="drawChar()"></a>drawChar()</h2><p><strong>功能:</strong></p><p>在(X,Y)处以字体font显示字符</p><p><strong>函数原型:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int16_t drawChar(int16_t uniCode, int32_t x, uint16_t y, uint8_t font)</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">参数</th><th align="center">类型</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">uniCode</td><td align="center">int16_t</td><td align="center">字符</td></tr><tr><td align="center">x</td><td align="center">int32_t</td><td align="center">X坐标</td></tr><tr><td align="center">y</td><td align="center">uint16_t</td><td align="center">Y坐标</td></tr><tr><td align="center">font</td><td align="center">uint8_t</td><td align="center">字体</td></tr></tbody></table><p><strong>使用示例:</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;M5Core2.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  M<span class="number">5.</span><span class="built_in">begin</span>(); <span class="comment">//初始化 M5Core2</span></span><br><span class="line">  M<span class="number">5.L</span>cd.<span class="built_in">drawChar</span>(<span class="string">&#x27;A&#x27;</span>, <span class="number">160</span>, <span class="number">120</span>, <span class="number">2</span>);    <span class="comment">//在(160,120)处以字体2显示字符A</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h2 id="drawFloat"><a href="#drawFloat" class="headerlink" title="drawFloat()"></a>drawFloat()</h2><p><strong>功能:</strong></p><p>在(X,Y)处显示小数点后dp位的浮点数floatNumber</p><p><strong>函数原型:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int16_t drawFloat(float floatNumber, uint8_t dp, int32_t poX, int32_t poY)</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">参数</th><th align="center">类型</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">floatNumber</td><td align="center">float</td><td align="center">所显示的小数</td></tr><tr><td align="center">dp</td><td align="center">uint8_t</td><td align="center">小数位数</td></tr><tr><td align="center">poX</td><td align="center">int32_t</td><td align="center">在x处显示</td></tr><tr><td align="center">poY</td><td align="center">int32_t</td><td align="center">在y处显示</td></tr></tbody></table><p><strong>使用示例:</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;M5Core2.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  M<span class="number">5.</span><span class="built_in">begin</span>();   <span class="comment">//初始化 M5Core2</span></span><br><span class="line">  M<span class="number">5.L</span>cd.<span class="built_in">drawFloat</span>(<span class="number">3.1415928</span>,<span class="number">7</span>,<span class="number">100</span>,<span class="number">100</span>);    <span class="comment">//在(100,100)处显示小数点后7位的浮点数3.1415928</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h2 id="drawPixel"><a href="#drawPixel" class="headerlink" title="drawPixel()"></a>drawPixel()</h2><p><strong>功能:</strong></p><p>在(X,Y)处画点</p><p><strong>函数原型:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void drawPixel(int32_t x, int32_t y, uint32_t color)</span><br></pre></td></tr></table></figure><p><strong>参数:</strong></p><table><thead><tr><th align="center">参数</th><th align="center">类型</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">x</td><td align="center">int32_t</td><td align="center">X坐标</td></tr><tr><td align="center">y</td><td align="center">int32_t</td><td align="center">Y坐标</td></tr><tr><td align="center">color</td><td align="center">uint32_t</td><td align="center">颜色</td></tr></tbody></table><p><strong>使用示例:</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;M5Core2.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  M<span class="number">5.</span><span class="built_in">begin</span>();  <span class="comment">//初始化 M5Core2</span></span><br><span class="line">  M<span class="number">5.L</span>cd.<span class="built_in">drawPixel</span>(<span class="number">22</span>,<span class="number">22</span>,RED);    <span class="comment">//在(22,22)处画一个红色的像素点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h2 id="drawLine"><a href="#drawLine" class="headerlink" title="drawLine()"></a>drawLine()</h2><p><strong>功能:</strong></p><p>从点(x0,y0)到点(x1,y1)以指定颜色(color)绘制直线</p><p><strong>函数原型:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void drawLine(int32_t x0, int32_t y0, int32_t x1, int32_t y1, uint32_t color)</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">参数</th><th align="center">类型</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">x</td><td align="center">int32_t</td><td align="center">X坐标</td></tr><tr><td align="center">y</td><td align="center">int32_t</td><td align="center">Y坐标</td></tr><tr><td align="center">color</td><td align="center">uint32_t</td><td align="center">颜色</td></tr></tbody></table><p><strong>使用示例:</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;M5Core2.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  M<span class="number">5.</span><span class="built_in">begin</span>();  <span class="comment">//初始化 M5Core2</span></span><br><span class="line">  M<span class="number">5.L</span>cd.<span class="built_in">drawLine</span>(<span class="number">200</span>, <span class="number">0</span>, <span class="number">200</span>,<span class="number">2000</span>,GREEN);    <span class="comment">//从点(200,0)到点(200,200)以绿色绘制直线</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h2 id="drawRect"><a href="#drawRect" class="headerlink" title="drawRect()"></a>drawRect()</h2><p><strong>功能:</strong></p><p>在(x,y)处以指定颜色绘制宽高分别为width和height的矩形线框</p><p><strong>函数原型:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void drawRect(int32_t x, int32_t y, int32_t w, int32_t h, uint32_t color)</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">参数</th><th align="center">类型</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">x</td><td align="center">int32_t</td><td align="center">X坐标</td></tr><tr><td align="center">y</td><td align="center">int32_t</td><td align="center">Y坐标</td></tr><tr><td align="center">w</td><td align="center">int32_t</td><td align="center">矩形框的宽(单位: 像素)</td></tr><tr><td align="center">h</td><td align="center">int32_t</td><td align="center">矩形框的高(单位: 像素)</td></tr><tr><td align="center">color</td><td align="center">uint32_t</td><td align="center">颜色值</td></tr></tbody></table><p><strong>使用示例:</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;M5Core2.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  M<span class="number">5.</span><span class="built_in">begin</span>();  <span class="comment">//初始化 M5Core2</span></span><br><span class="line">  M<span class="number">5.L</span>cd.<span class="built_in">drawRect</span>(<span class="number">180</span>, <span class="number">12</span>, <span class="number">122</span>, <span class="number">10</span>, BLUE);    <span class="comment">//在(180,12)处以蓝色绘制宽高分别为122和10的矩形线框</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h2 id="fillRect"><a href="#fillRect" class="headerlink" title="fillRect()"></a>fillRect()</h2><p><strong>功能:</strong></p><p>在(x,y)处以指定颜色绘制宽高分别为width和height的填充矩形</p><p><strong>函数原型:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void fillRect(int32_t x, int32_t y, int32_t w, int32_t h, uint32_t color)</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">参数</th><th align="center">类型</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">x</td><td align="center">int32_t</td><td align="center">X坐标</td></tr><tr><td align="center">y</td><td align="center">int32_t</td><td align="center">Y坐标</td></tr><tr><td align="center">w</td><td align="center">int32_t</td><td align="center">矩形框的宽(单位: 像素)</td></tr><tr><td align="center">h</td><td align="center">int32_t</td><td align="center">矩形框的高(单位: 像素)</td></tr><tr><td align="center">color</td><td align="center">uint32_t</td><td align="center">颜色值</td></tr></tbody></table><p><strong>使用示例:</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;M5Core2.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  M<span class="number">5.</span><span class="built_in">begin</span>();  <span class="comment">//初始化 M5Core2</span></span><br><span class="line">  M<span class="number">5.L</span>cd.<span class="built_in">fillRect</span>(<span class="number">150</span>, <span class="number">120</span>, <span class="number">122</span>, <span class="number">10</span>, BLUE);    <span class="comment">//在(150,120)处绘制一个长122、宽为10的蓝色填充矩形</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h2 id="drawRoundRect"><a href="#drawRoundRect" class="headerlink" title="drawRoundRect()"></a>drawRoundRect()</h2><p><strong>功能:</strong></p><p>在(x,y)处绘制宽高分别为width、height的圆角矩形线框,圆角半径为radius,颜色为color</p><p><strong>函数原型:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void drawRoundRect(int32_t x, int32_t y, int32_t w, int32_t h, int32_t r, uint32_t color)</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">参数</th><th align="center">类型</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">x</td><td align="center">int32_t</td><td align="center">矩形左上角的x坐标</td></tr><tr><td align="center">y</td><td align="center">int32_t</td><td align="center">矩形左上角的Y坐标</td></tr><tr><td align="center">w</td><td align="center">int32_t</td><td align="center">矩形(像素)</td></tr><tr><td align="center">h</td><td align="center">int32_t</td><td align="center">矩形的高度</td></tr><tr><td align="center">r</td><td align="center">int32_t</td><td align="center">转角半径f</td></tr><tr><td align="center">color</td><td align="center">uint32_t</td><td align="center">方线的颜色</td></tr></tbody></table><p><strong>使用示例:</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;M5Core2.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  M<span class="number">5.</span><span class="built_in">begin</span>();   <span class="comment">//初始化 M5Core2</span></span><br><span class="line">  M<span class="number">5.L</span>cd.<span class="built_in">drawRoundRect</span>(<span class="number">55</span>,<span class="number">55</span>,<span class="number">30</span>,<span class="number">50</span>,<span class="number">10</span>,GREEN);    <span class="comment">//在(55,55)处绘制宽高分别为30、50的圆角半径为10,颜色为绿色的圆角矩形线框</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h2 id="fillRoundRect"><a href="#fillRoundRect" class="headerlink" title="fillRoundRect()"></a>fillRoundRect()</h2><p><strong>功能:</strong></p><p>在(x,y)处绘制宽高分别为width、height的圆角矩形线框,圆角半径为radius,颜色为color</p><p><strong>函数原型:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void fillRoundRect(int32_t x, int32_t y, int32_t w, int32_t h, int32_t r, uint32_t color)</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">参数</th><th align="center">类型</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">x</td><td align="center">int32_t</td><td align="center">矩形左上角的x坐标</td></tr><tr><td align="center">y</td><td align="center">int32_t</td><td align="center">矩形左上角的Y坐标</td></tr><tr><td align="center">w</td><td align="center">int32_t</td><td align="center">矩形宽度(像素)</td></tr><tr><td align="center">h</td><td align="center">int32_t</td><td align="center">矩形的高度(像素)</td></tr><tr><td align="center">r</td><td align="center">int32_t</td><td align="center">转角半径f</td></tr><tr><td align="center">color</td><td align="center">uint32_t</td><td align="center">方线的颜色</td></tr></tbody></table><p><strong>使用示例:</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;M5Core2.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  M<span class="number">5.</span><span class="built_in">begin</span>();   <span class="comment">//初始化 M5Core2</span></span><br><span class="line">  M<span class="number">5.L</span>cd.<span class="built_in">fillRoundRect</span>(<span class="number">55</span>, <span class="number">55</span>, <span class="number">30</span>, <span class="number">50</span>, <span class="number">10</span>, GREEN);<span class="comment">//在(55,55)处绘制宽高分别为30、50的圆角半径为10,颜色为绿色的圆角矩形  </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h2 id="drawCircle"><a href="#drawCircle" class="headerlink" title="drawCircle()"></a>drawCircle()</h2><p><strong>功能:</strong></p><p>在(x,y)处绘制半径为r的color色圆线框</p><p><strong>函数原型:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void drawCircle(int32_t x0, int32_t y0, int32_t r, uint32_t color)</span><br></pre></td></tr></table></figure><p><strong>参数:</strong></p><table><thead><tr><th align="center">参数</th><th align="center">类型</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">x0</td><td align="center">int32_t</td><td align="center">圆中心X坐标</td></tr><tr><td align="center">y0</td><td align="center">int32_t</td><td align="center">圆中心Y坐标</td></tr><tr><td align="center">r</td><td align="center">int32_t</td><td align="center">圆的半径</td></tr><tr><td align="center">color</td><td align="center">uint32_t</td><td align="center">圆的颜色</td></tr></tbody></table><p><strong>使用示例:</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;M5Core2.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  M<span class="number">5.</span><span class="built_in">begin</span>();   <span class="comment">//初始化 M5Core2</span></span><br><span class="line">  M<span class="number">5.L</span>cd.<span class="built_in">drawCircle</span>(<span class="number">100</span>, <span class="number">100</span>, <span class="number">50</span>, RED);   <span class="comment">//在(x,y)处绘制半径为50的红色圆线圈</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h2 id="fillCircle"><a href="#fillCircle" class="headerlink" title="fillCircle()"></a>fillCircle()</h2><p><strong>功能:</strong></p><p>在(x,y)处绘制半径为r的color色填充圆</p><p><strong>函数原型:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void drawCircle(int32_t x0, int32_t y0, int32_t r, uint32_t color)</span><br></pre></td></tr></table></figure><p><strong>参数:</strong></p><table><thead><tr><th align="center">参数</th><th align="center">类型</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">x0</td><td align="center">int32_t</td><td align="center">圆中心X坐标</td></tr><tr><td align="center">y0</td><td align="center">int32_t</td><td align="center">圆中心Y坐标</td></tr><tr><td align="center">r</td><td align="center">int32_t</td><td align="center">圆的半径</td></tr><tr><td align="center">color</td><td align="center">uint32_t</td><td align="center">圆的颜色</td></tr></tbody></table><p><strong>使用示例:</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;M5Core2.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  M<span class="number">5.</span><span class="built_in">begin</span>();   <span class="comment">//初始化 M5Core2</span></span><br><span class="line">  M<span class="number">5.L</span>cd.<span class="built_in">fillCircle</span>(<span class="number">100</span>, <span class="number">100</span>, <span class="number">50</span>, RED); <span class="comment">//在(x,y)处绘制半径为50的填充红色圆</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h2 id="drawEllipse"><a href="#drawEllipse" class="headerlink" title="drawEllipse()"></a>drawEllipse()</h2><p><strong>功能:</strong></p><p>在(x,y)处绘制宽度、高度分别为rx,ry的椭圆线框</p><p><strong>函数原型:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void fillEllipse(int16_t x0, int16_t y0, int32_t rx, int32_t ry, uint16_t color)</span><br></pre></td></tr></table></figure><p><strong>参数:</strong></p><table><thead><tr><th align="center">参数</th><th align="center">类型</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">x0</td><td align="center">int16_t</td><td align="center">椭圆的中心X坐标</td></tr><tr><td align="center">y0</td><td align="center">int16_t</td><td align="center">椭圆的中心Y坐标</td></tr><tr><td align="center">rx</td><td align="center">int32_t</td><td align="center">椭圆的宽度(像素)</td></tr><tr><td align="center">ry</td><td align="center">int32_t</td><td align="center">椭圆的高度(像素)</td></tr><tr><td align="center">color</td><td align="center">uint16_t</td><td align="center">椭圆的颜色</td></tr></tbody></table><p><strong>使用示例:</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;M5Core2.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  M<span class="number">5.</span><span class="built_in">begin</span>();   <span class="comment">//初始化 M5Core2</span></span><br><span class="line">  M<span class="number">5.L</span>cd.<span class="built_in">drawEllipse</span>(<span class="number">160</span>, <span class="number">100</span>, <span class="number">60</span>, <span class="number">100</span>, YELLOW);<span class="comment">//在（160,100）处绘制颜色为黄色的宽度、高度分别为60,100的椭圆轮廓线</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h2 id="fillEllipse"><a href="#fillEllipse" class="headerlink" title="fillEllipse()"></a>fillEllipse()</h2><p><strong>功能:</strong></p><p>在(x,y)处绘制宽度、高度分别为rx,ry的填充椭圆</p><p><strong>函数原型:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void fillEllipse(int16_t x0, int16_t y0, int32_t rx, int32_t ry, uint16_t color)</span><br></pre></td></tr></table></figure><p><strong>参数:</strong></p><table><thead><tr><th align="center">参数</th><th align="center">类型</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">x0</td><td align="center">int16_t</td><td align="center">椭圆的中心X坐标</td></tr><tr><td align="center">y0</td><td align="center">int16_t</td><td align="center">椭圆的中心Y坐标</td></tr><tr><td align="center">rx</td><td align="center">int32_t</td><td align="center">圆的宽度(像素)</td></tr><tr><td align="center">ry</td><td align="center">int32_t</td><td align="center">圆的高度(像素)</td></tr><tr><td align="center">color</td><td align="center">uint16_t</td><td align="center">椭圆的颜色</td></tr></tbody></table><p><strong>使用示例:</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;M5Core2.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  M<span class="number">5.</span><span class="built_in">begin</span>();  <span class="comment">//初始化 M5Core2</span></span><br><span class="line">  M<span class="number">5.L</span>cd.<span class="built_in">fillEllipse</span>(<span class="number">160</span>, <span class="number">100</span>, <span class="number">60</span>, <span class="number">100</span>, YELLOW);    <span class="comment">//在（160,100）处绘制颜色为黄色的宽度、高度分别为60,100的填充黄色椭圆</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h2 id="drawTriangle"><a href="#drawTriangle" class="headerlink" title="drawTriangle()"></a>drawTriangle()</h2><p><strong>功能:</strong></p><p>以(x1, y1) (x2, y2) (x3, y3)为顶点绘制三角形线框</p><p><strong>函数原型:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void drawTriangle(int32_t x0, int32_t y0, int32_t x1, int32_t y1, int32_t x2, int32_t y2, uint32_t color)</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">参数</th><th align="center">类型</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">x*</td><td align="center">int32_t</td><td align="center">顶点X*的x坐标</td></tr><tr><td align="center">y*</td><td align="center">int32_t</td><td align="center">顶点Y*的x坐标</td></tr><tr><td align="center">color</td><td align="center">uint32_t</td><td align="center">三角形的颜色</td></tr></tbody></table><p><strong>使用示例:</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;M5Core2.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  M<span class="number">5.</span><span class="built_in">begin</span>();   <span class="comment">//初始化 M5Core2</span></span><br><span class="line">  M<span class="number">5.L</span>cd.<span class="built_in">drawTriangle</span>(<span class="number">30</span>, <span class="number">30</span>, <span class="number">180</span>, <span class="number">100</span>, <span class="number">80</span>, <span class="number">150</span>, YELLOW); <span class="comment">//以 (30,30) (180,100) (80,150)为顶点绘制黄色三角形线框</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h2 id="drawTriangle-1"><a href="#drawTriangle-1" class="headerlink" title="drawTriangle()"></a>drawTriangle()</h2><p><strong>功能:</strong></p><p>以(x1, y1) (x2, y2) (x3, y3)为顶点绘制填充三角形</p><p><strong>函数原型:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void drawTriangle(int32_t x0, int32_t y0, int32_t x1, int32_t y1, int32_t x2, int32_t y2, uint32_t color)</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">参数</th><th align="center">类型</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">x*</td><td align="center">int32_t</td><td align="center">顶点X*的x坐标</td></tr><tr><td align="center">y*</td><td align="center">int32_t</td><td align="center">顶点Y*的x坐标</td></tr><tr><td align="center">color</td><td align="center">uint32_t</td><td align="center">三角形的颜色</td></tr></tbody></table><p><strong>使用示例:</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;M5Core2.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  M<span class="number">5.</span><span class="built_in">begin</span>();   <span class="comment">//初始化 M5Core2</span></span><br><span class="line">  M<span class="number">5.L</span>cd.<span class="built_in">drawTriangle</span>(<span class="number">30</span>, <span class="number">30</span>, <span class="number">180</span>, <span class="number">100</span>, <span class="number">80</span>, <span class="number">150</span>, YELLOW); <span class="comment">//以 (30,30) (180,100) (80,150)为顶点绘制填充黄色三角形</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h2 id="drawXBitmap"><a href="#drawXBitmap" class="headerlink" title="drawXBitmap()"></a>drawXBitmap()</h2><p><strong>功能:</strong></p><p>绘制位图</p><p><strong>函数原型:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void drawXBitmap(int16_t x, int16_t y, const uint8_t *bitmap, int16_t w, int16_t h, uint16_t color)</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">参数</th><th align="center">类型</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">x</td><td align="center">int16_t</td><td align="center">坐标 X</td></tr><tr><td align="center">y</td><td align="center">int16_t</td><td align="center">坐标 Y</td></tr><tr><td align="center">bitmap</td><td align="center">const uint8_t</td><td align="center">所示图像</td></tr><tr><td align="center">w</td><td align="center">int16_t</td><td align="center">宽度(像素)</td></tr><tr><td align="center">h</td><td align="center">int16_t</td><td align="center">高度(像素)</td></tr><tr><td align="center">color</td><td align="center">uint16_t</td><td align="center">颜色</td></tr></tbody></table><p><strong>使用示例:</strong></p><p>见使用示例 sketch:<code>M5Stack</code>-&gt;<code>Advanced</code>-&gt;<code>Display</code>-&gt;<code>drawXBitmap</code></p><h2 id="drawBitmap"><a href="#drawBitmap" class="headerlink" title="drawBitmap()"></a>drawBitmap()</h2><p><strong>功能:</strong></p><p>绘制位图</p><p><strong>函数原型:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">drawBitmap(int16_t x0, int16_t y0, int16_t w, int16_t h, const uint16_t *data)</span><br><span class="line">drawBitmap(int16_t x0, int16_t y0, int16_t w, int16_t h, uint16_t *data)</span><br><span class="line">drawBitmap(int16_t x0, int16_t y0, int16_t w, int16_t h, const uint16_t *data, uint16_t transparent)</span><br><span class="line">drawBitmap(int16_t x0, int16_t y0, int16_t w, int16_t h, const uint8_t *data)</span><br><span class="line">drawBitmap(int16_t x0, int16_t y0, int16_t w, int16_t h, uint8_t *data)</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">参数</th><th align="center">类型</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">x0</td><td align="center">uint16_t</td><td align="center">坐标 X</td></tr><tr><td align="center">y0</td><td align="center">uint16_t</td><td align="center">坐标 Y</td></tr><tr><td align="center">w</td><td align="center">int16_t</td><td align="center">宽度 (像素)</td></tr><tr><td align="center">h</td><td align="center">int16_t</td><td align="center">高度 (像素)</td></tr><tr><td align="center">data</td><td align="center">uint16_t* &#x2F; uint8_t*</td><td align="center">图像数量</td></tr><tr><td align="center">transparent</td><td align="center">uint16_t</td><td align="center">透明色码</td></tr></tbody></table><p><strong>注意:</strong><br>颜色代码由总共16位表示:红色5位,绿色6位,顶部蓝色5位</p><p><strong>使用示例:</strong></p><p>见使用示例 sketch:<code>M5Stack</code>-&gt;<code>games</code>-&gt;<code>Tetris</code></p><h2 id="drawBmpFile"><a href="#drawBmpFile" class="headerlink" title="drawBmpFile()"></a>drawBmpFile()</h2><p><strong>功能:</strong></p><p>从文件中读取位图并绘制它</p><p><strong>函数原型:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">drawBmpFile(fs::FS &amp;fs, const char *path, uint16_t x, uint16_t y)</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">参数</th><th align="center">类型</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">fs</td><td align="center">fs::FS</td><td align="center">文件流</td></tr><tr><td align="center">path</td><td align="center">const char *</td><td align="center">文件路径(SD 、SPIFFS)</td></tr><tr><td align="center">x</td><td align="center">int16_t</td><td align="center">坐标 X</td></tr><tr><td align="center">y</td><td align="center">int16_t</td><td align="center">坐标 Y</td></tr></tbody></table><p><strong>注意:</strong><br>1.根据大小和位数可能无法扩展<br>2.需要提前预装 <a href="https://github.com/me-no-dev/arduino-esp32fs-plugin">Arduino ESP32 filesystem uploader</a></p><p><strong>使用示例:</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;FS.h&quot;</span></span></span><br><span class="line"><span class="comment">//#include &quot;SPIFFS.h&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;M5Core2.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span></span>&#123;</span><br><span class="line">    M<span class="number">5.</span><span class="built_in">begin</span>(<span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">  M<span class="number">5.L</span>cd.<span class="built_in">drawBmpFile</span>(SD, <span class="string">&quot;/p2.bmp&quot;</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">  <span class="comment">//M5.Lcd.drawBmpFile(SPIFFS, &quot;/p2.bmp&quot;, 0, 0);</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>我们提供一个可以用来转换<code>jpg</code>图像-&gt;<code>.c</code>文件的脚本, 可以使用它来转换一些图片, 并使用上面的API将图像绘制到屏幕上 <a href="https://github.com/m5stack/M5Stack/tree/master/tools">bin2code.py</a></p><h2 id="drawJpg"><a href="#drawJpg" class="headerlink" title="drawJpg()"></a>drawJpg()</h2><p><strong>功能:</strong></p><p>从内存中读取 JPEG 格式的图片数据并绘制它</p><p><strong>函数原型:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void drawJpg(const uint8_t *jpg_data, size_t jpg_len, uint16_t x,uint16_t y, uint16_t maxWidth, uint16_t maxHeight,uint16_t offX, uint16_t offY, jpeg_div_t scale) &#123;</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">参数</th><th align="center">类型</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">jpg_data</td><td align="center">uint8_t *</td><td align="center">数据顶部</td></tr><tr><td align="center">jpg_len</td><td align="center">size_t</td><td align="center">数据长度</td></tr><tr><td align="center">x</td><td align="center">uint16_t</td><td align="center">坐标 X</td></tr><tr><td align="center">y</td><td align="center">uint16_t</td><td align="center">坐标 Y</td></tr><tr><td align="center">maxWidth</td><td align="center">uint16_t</td><td align="center">最大宽度 (像素)</td></tr><tr><td align="center">maxHeight</td><td align="center">uint16_t</td><td align="center">最大高度 (像素)</td></tr><tr><td align="center">offX</td><td align="center">uint16_t</td><td align="center">抵消 X (像素)</td></tr><tr><td align="center">offY</td><td align="center">uint16_t</td><td align="center">抵消 Y (像素)</td></tr><tr><td align="center">scale</td><td align="center">jpeg_div_t</td><td align="center">规模</td></tr></tbody></table><p>规格 (jpeg_div_t):</p><table><thead><tr><th align="center">定义</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">JPEG_DIV_NONE</td><td align="center">无</td></tr><tr><td align="center">JPEG_DIV_2</td><td align="center">1&#x2F;2</td></tr><tr><td align="center">JPEG_DIV_4</td><td align="center">1&#x2F;4</td></tr><tr><td align="center">JPEG_DIV_8</td><td align="center">1&#x2F;8</td></tr><tr><td align="center">JPEG_DIV_MAX</td><td align="center">MAX</td></tr></tbody></table><p><strong>注意:</strong><br>1.根据大小,位数和格式（渐进等）,可能无法扩展</p><ol start="2"><li><a href="https://github.com/Tinyu-Zhao/M5Stack/blob/master/examples/Games/Tetris/tetris_img.c">tetris_img下载</a></li></ol><p><strong>使用示例:</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;M5Core2.h&gt;</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">uint8_t</span> tetris_img[];    <span class="comment">//引用存储图像的数组,需要提前和 xxx.ino放在同一文件夹中</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  M<span class="number">5.</span><span class="built_in">begin</span>();  <span class="comment">//初始化 M5Core2</span></span><br><span class="line">  M<span class="number">5.L</span>cd.<span class="built_in">drawJpg</span>(tetris_img, <span class="number">34215</span>);    <span class="comment">//从内存中读取名为tetris_img的jpeg文件</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h2 id="drawJpgFile"><a href="#drawJpgFile" class="headerlink" title="drawJpgFile()"></a>drawJpgFile()</h2><p><strong>功能:</strong></p><p>从文件流中读取JPEG数据并绘制它</p><p><strong>函数原型:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void drawJpgFiledrawJpgFile(fs::FS &amp;fs, const char *path, uint16_t x,uint16_t y,uint16_t maxWidth, uint16_t maxHeight, uint16_t offX,uint16_t offY, jpeg_div_t scale)</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">参数</th><th align="center">类型</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">fs</td><td align="center">fs::FS</td><td align="center">文件流</td></tr><tr><td align="center">path</td><td align="center">const char *</td><td align="center">文件路径</td></tr><tr><td align="center">x</td><td align="center">uint16_t</td><td align="center">坐标 X</td></tr><tr><td align="center">y</td><td align="center">uint16_t</td><td align="center">坐标 Y</td></tr><tr><td align="center">maxWidth</td><td align="center">uint16_t</td><td align="center">Max Width (像素)</td></tr><tr><td align="center">maxHeight</td><td align="center">uint16_t</td><td align="center">Max Height (像素)</td></tr><tr><td align="center">offX</td><td align="center">uint16_t</td><td align="center">抵消X (像素)</td></tr><tr><td align="center">offY</td><td align="center">uint16_t</td><td align="center">抵消Y (像素)</td></tr><tr><td align="center">scale</td><td align="center">jpeg_div_t</td><td align="center">规模</td></tr></tbody></table><p>规模(jpeg_div_t):</p><table><thead><tr><th align="center">定义</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">JPEG_DIV_NONE</td><td align="center">no care.</td></tr><tr><td align="center">JPEG_DIV_2</td><td align="center">1&#x2F;2</td></tr><tr><td align="center">JPEG_DIV_4</td><td align="center">1&#x2F;4</td></tr><tr><td align="center">JPEG_DIV_8</td><td align="center">1&#x2F;8</td></tr><tr><td align="center">JPEG_DIV_MAX</td><td align="center">MAX</td></tr></tbody></table><p><strong>注意:</strong><br>根据尺寸和格式（渐进等）,可能无法扩展</p><h2 id="progressBar"><a href="#progressBar" class="headerlink" title="progressBar()"></a>progressBar()</h2><p><strong>功能:</strong></p><p>显示显示进度的栏</p><p><strong>函数原型:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void progressBar(int x, int y, int w, int h, uint8_t val)</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">参数</th><th align="center">类型</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">x</td><td align="center">int</td><td align="center">坐标 X</td></tr><tr><td align="center">y</td><td align="center">int</td><td align="center">坐标 Y</td></tr><tr><td align="center">w</td><td align="center">int</td><td align="center">宽度 (像素)</td></tr><tr><td align="center">h</td><td align="center">int</td><td align="center">高度(像素)</td></tr><tr><td align="center">val</td><td align="center">uint8_t</td><td align="center">进度(0-100%)</td></tr></tbody></table><p><strong>注意:</strong><br>进度条将用蓝色显示</p><p><strong>使用示例:</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;M5Core2.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  M<span class="number">5.</span><span class="built_in">begin</span>();  <span class="comment">//初始化 M5Core2</span></span><br><span class="line">  M<span class="number">5.L</span>cd.<span class="built_in">progressBar</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">240</span>, <span class="number">20</span>, <span class="number">20</span>);    <span class="comment">//在(0,0)处显示宽高分别为240,20进度为20%的进度条</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h2 id="qrcode"><a href="#qrcode" class="headerlink" title="qrcode()"></a>qrcode()</h2><p><strong>功能:</strong></p><p>创建一个二维码</p><p><strong>函数原型:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void qrcode(const char *string, uint16_t x, uint16_t y, uint8_t width, uint8_t version)</span><br><span class="line">void qrcode(const String &amp;string, uint16_t x, uint16_t y, uint8_t width, uint8_t version)</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">参数</th><th align="center">类型</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">val</td><td align="center">string &#x2F; String&amp;</td><td align="center">要嵌入QR的字符串</td></tr><tr><td align="center">x</td><td align="center">uint16_t</td><td align="center">坐标 X</td></tr><tr><td align="center">y</td><td align="center">uint16_t</td><td align="center">坐标 Y</td></tr><tr><td align="center">width</td><td align="center">uint8_t</td><td align="center">宽度 (像素)</td></tr><tr><td align="center">version</td><td align="center">uint8_t</td><td align="center">二维码版本</td></tr></tbody></table><p><strong>注意:</strong><br>请根据字符数量选择合适的二维码版本</p><p><strong>使用示例:</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;M5Core2.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  M<span class="number">5.L</span>cd.<span class="built_in">begin</span>();   <span class="comment">//初始化 M5Core2</span></span><br><span class="line">  M<span class="number">5.L</span>cd.<span class="built_in">qrcode</span>(<span class="string">&quot;http://www.m5stack.com&quot;</span>, <span class="number">50</span>, <span class="number">10</span>, <span class="number">220</span>, <span class="number">6</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h1 id="6-Sprite"><a href="#6-Sprite" class="headerlink" title="6.Sprite"></a>6.Sprite</h1><h2 id="setColorDepth"><a href="#setColorDepth" class="headerlink" title="setColorDepth()"></a>setColorDepth()</h2><p><strong>功能:</strong></p><p>设置色深</p><p><strong>函数原型:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void* TFT_eSprite::setColorDepth(int8_t b)</span><br></pre></td></tr></table></figure><p><strong>使用示例:</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;M5Core2.h&gt;</span></span></span><br><span class="line">TFT_eSprite img = <span class="built_in">TFT_eSprite</span>(&amp;M<span class="number">5.L</span>cd);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    img.<span class="built_in">setColorDepth</span>(<span class="number">8</span>); <span class="comment">// Set color depth.  设置色深</span></span><br><span class="line">    img.<span class="built_in">setTextSize</span>(<span class="number">2</span>);</span><br><span class="line">    img.<span class="built_in">createSprite</span>(<span class="number">320</span>, <span class="number">240</span>);  <span class="comment">//Create a 320x240 canvas. 创建一块320x240的画布</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>应在创建画布前设置相应的色深</p><h2 id="createSprite"><a href="#createSprite" class="headerlink" title="createSprite()"></a>createSprite()</h2><p><strong>功能:</strong></p><p>创建一个指定宽高的画布</p><p><strong>函数原型:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void createSprite(int16_t w, int16_t h, uint8_t frames)</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">参数</th><th align="center">类型</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">x</td><td align="center">int16_t</td><td align="center">X坐标</td></tr><tr><td align="center">y</td><td align="center">int16_t</td><td align="center">Y坐标</td></tr><tr><td align="center">frames</td><td align="center">uint8_t</td><td align="center">色深[1~2,可选]</td></tr></tbody></table><p><strong>使用示例:</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;M5Core2.h&gt;</span></span></span><br><span class="line">TFT_eSprite img = <span class="built_in">TFT_eSprite</span>(&amp;M<span class="number">5.L</span>cd);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  M<span class="number">5.</span><span class="built_in">begin</span>();  <span class="comment">//初始化 M5Core2</span></span><br><span class="line">  img.<span class="built_in">createSprite</span>(<span class="number">320</span>, <span class="number">240</span>);    <span class="comment">//创建一块320x240的画布</span></span><br><span class="line">  img.<span class="built_in">fillSprite</span>(RED);    <span class="comment">//在画布上全部填充红色</span></span><br><span class="line">  img.<span class="built_in">pushSprite</span>(<span class="number">0</span>, <span class="number">0</span>, WHITE);    <span class="comment">//把画布推送到屏幕(0,0)处并设置白色为穿透色</span></span><br><span class="line">  M<span class="number">5.L</span>cd.<span class="built_in">print</span>(img.<span class="built_in">height</span>());    <span class="comment">//屏幕打印画布的高度    </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h2 id="fillSprite"><a href="#fillSprite" class="headerlink" title="fillSprite()"></a>fillSprite()</h2><p><strong>功能:</strong></p><p>将Sprite填充指定颜色</p><p><strong>函数原型:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void fillSprite(uint32_t color)</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">参数</th><th align="center">类型</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">color</td><td align="center">int32_t</td><td align="center">filled color</td></tr></tbody></table><p><strong>使用示例:</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;M5Core2.h&gt;</span></span></span><br><span class="line">TFT_eSprite img = <span class="built_in">TFT_eSprite</span>(&amp;M<span class="number">5.L</span>cd);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  M<span class="number">5.</span><span class="built_in">begin</span>();  <span class="comment">//初始化 M5Core2</span></span><br><span class="line">  img.<span class="built_in">createSprite</span>(<span class="number">320</span>, <span class="number">240</span>);    <span class="comment">//创建一块320x240的画布</span></span><br><span class="line">  img.<span class="built_in">fillSprite</span>(RED);    <span class="comment">//在画布上全部填充红色</span></span><br><span class="line">  img.<span class="built_in">pushSprite</span>(<span class="number">0</span>, <span class="number">0</span>);    <span class="comment">//把画布推送到屏幕(0,0)处</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h2 id="pushSprite"><a href="#pushSprite" class="headerlink" title="pushSprite()"></a>pushSprite()</h2><p><strong>功能:</strong></p><p>推送画布到指定坐标,并设置穿透色</p><p><strong>函数原型:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void pushSprite(int32_t x, int32_t y, uint16_t transparent)</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">参数</th><th align="center">类型</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">x</td><td align="center">int32_t</td><td align="center">X坐标</td></tr><tr><td align="center">y</td><td align="center">int32_t</td><td align="center">Y坐标</td></tr><tr><td align="center">transparent</td><td align="center">int16_t</td><td align="center">穿透色(可选)</td></tr></tbody></table><p><strong>使用示例:</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;M5Core2.h&gt;</span></span></span><br><span class="line">TFT_eSprite img = <span class="built_in">TFT_eSprite</span>(&amp;M<span class="number">5.L</span>cd);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  M<span class="number">5.</span><span class="built_in">begin</span>();  <span class="comment">//初始化 M5Core2</span></span><br><span class="line">  img.<span class="built_in">createSprite</span>(<span class="number">320</span>, <span class="number">240</span>);    <span class="comment">//创建一块320x240的画布</span></span><br><span class="line">  img.<span class="built_in">fillSprite</span>(RED);    <span class="comment">//在画布上全部填充红色</span></span><br><span class="line">  img.<span class="built_in">fillCircle</span>(<span class="number">100</span>,<span class="number">100</span>,<span class="number">20</span>,GREEN);</span><br><span class="line">  img.<span class="built_in">pushSprite</span>(<span class="number">0</span>, <span class="number">0</span>, GREEN);    <span class="comment">//把画布推送到屏幕(0,0)处并设置绿色为穿透色</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h2 id="height"><a href="#height" class="headerlink" title="height()"></a>height()</h2><p><strong>功能:</strong></p><p>返回Sprite的高度</p><p><strong>函数原型:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int16_t height()</span><br></pre></td></tr></table></figure><p><strong>使用示例:</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;M5Core2.h&gt;</span></span></span><br><span class="line">TFT_eSprite img = <span class="built_in">TFT_eSprite</span>(&amp;M<span class="number">5.L</span>cd);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  M<span class="number">5.</span><span class="built_in">begin</span>();  <span class="comment">//初始化 M5Core2</span></span><br><span class="line">  img.<span class="built_in">createSprite</span>(<span class="number">320</span>, <span class="number">240</span>);    <span class="comment">//创建一块320x240的画布</span></span><br><span class="line">  img.<span class="built_in">fillSprite</span>(RED);    <span class="comment">//在画布上全部填充红色</span></span><br><span class="line">  img.<span class="built_in">pushSprite</span>(<span class="number">0</span>, <span class="number">0</span>, WHITE);    <span class="comment">//把画布推送到屏幕(0,0)处并设置白色为穿透色</span></span><br><span class="line">  M<span class="number">5.L</span>cd.<span class="built_in">print</span>(img.<span class="built_in">height</span>());    <span class="comment">//屏幕打印画布的高度    </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h2 id="deleteSprite"><a href="#deleteSprite" class="headerlink" title="deleteSprite()"></a>deleteSprite()</h2><p><strong>功能:</strong></p><p>从内存删除画布</p><p><strong>函数原型:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void deleteSprite(void)</span><br></pre></td></tr></table></figure><p><strong>使用示例:</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;M5Core2.h&gt;</span></span></span><br><span class="line">TFT_eSprite img = <span class="built_in">TFT_eSprite</span>(&amp;M<span class="number">5.L</span>cd);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  M<span class="number">5.</span><span class="built_in">begin</span>();  <span class="comment">//初始化 M5Core2</span></span><br><span class="line">  img.<span class="built_in">deleteSprite</span>();    <span class="comment">//从内存中删除画布</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><h1 id="7-按键"><a href="#7-按键" class="headerlink" title="7.按键"></a>7.按键</h1><p><strong>类名: BtnA &#x2F; BtnB &#x2F; BtnC</strong></p><h2 id="read"><a href="#read" class="headerlink" title="read()"></a>read()</h2><p><strong>功能:</strong></p><p>读取按键状态: 0,松开; 1,按下</p><p><strong>函数原型:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uint8_t read()</span><br></pre></td></tr></table></figure><p><strong>使用示例:</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;M5Core2.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  M<span class="number">5.</span><span class="built_in">begin</span>();</span><br><span class="line">  M<span class="number">5.L</span>cd.<span class="built_in">println</span>(<span class="string">&quot;Please pressed Button A.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  M<span class="number">5.L</span>cd.<span class="built_in">setCursor</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  M<span class="number">5.L</span>cd.<span class="built_in">printf</span>(<span class="string">&quot;Button A Status: %d &quot;</span>,M<span class="number">5.</span>BtnA.<span class="built_in">read</span>());    <span class="comment">//打印按键A按下的状态</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h2 id="lastChange"><a href="#lastChange" class="headerlink" title="lastChange()"></a>lastChange()</h2><p><strong>功能:</strong></p><p>返回最后一次状态发生变化的时间</p><p><strong>函数原型:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uint32_t lastChange()</span><br></pre></td></tr></table></figure><p><strong>注意:</strong><br>1.返回的时间是从M5Core初始化的那一刻开始计时,单位为毫秒</p><p><strong>使用示例:</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;M5Core2.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  M<span class="number">5.</span><span class="built_in">begin</span>();</span><br><span class="line">  M<span class="number">5.L</span>cd.<span class="built_in">println</span>(<span class="string">&quot;Please pressed Button A.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  M<span class="number">5.</span><span class="built_in">update</span>();</span><br><span class="line">  M<span class="number">5.L</span>cd.<span class="built_in">setCursor</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  M<span class="number">5.L</span>cd.<span class="built_in">printf</span>(<span class="string">&quot;The last change at %d ms /n&quot;</span>,M<span class="number">5.</span>BtnA.<span class="built_in">lastChange</span>());    <span class="comment">//打印按键A最后一次状态变化的时间</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h1 id="8-Press"><a href="#8-Press" class="headerlink" title="8.Press"></a>8.Press</h1><h2 id="isPressed"><a href="#isPressed" class="headerlink" title="isPressed()"></a>isPressed()</h2><p><strong>功能:</strong></p><p>返回按键按下状态: 如果按键按下,返回true; 否则返回false</p><p><strong>函数原型:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uint8_t isPressed()</span><br></pre></td></tr></table></figure><p><strong>使用示例:</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;M5Core2.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  M<span class="number">5.</span><span class="built_in">begin</span>();</span><br><span class="line">  M<span class="number">5.L</span>cd.<span class="built_in">println</span>(<span class="string">&quot;Please pressed Button A.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  M<span class="number">5.</span><span class="built_in">update</span>();    <span class="comment">//需添加M5.update()才能读取到按键的状态,细节请见System</span></span><br><span class="line">  M<span class="number">5.L</span>cd.<span class="built_in">setCursor</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (M<span class="number">5.</span>BtnA.<span class="built_in">isPressed</span>()) &#123;    <span class="comment">//如果按键按下</span></span><br><span class="line">    M<span class="number">5.L</span>cd.<span class="built_in">println</span>(<span class="string">&quot;Button is Pressed.&quot;</span>);</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    M<span class="number">5.L</span>cd.<span class="built_in">println</span>(<span class="string">&quot;Button is Released.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">delay</span>(<span class="number">20</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h2 id="pressedFor"><a href="#pressedFor" class="headerlink" title="pressedFor()"></a>pressedFor()</h2><p><strong>功能:</strong></p><p>返回按键按下状态: 如果按键按下超过指定时间后,返回true; 否则返回false</p><p><strong>函数原型:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uint8_t pressedFor(uint32_t ms)</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">参数</th><th align="center">类型</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">ms</td><td align="center">uint32_t</td><td align="center">按键按下时间 (毫秒)</td></tr></tbody></table><p><strong>使用示例:</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;M5Core2.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  M<span class="number">5.</span><span class="built_in">begin</span>();</span><br><span class="line">  M<span class="number">5.L</span>cd.<span class="built_in">println</span>(<span class="string">&quot;Please pressed Button A.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  M<span class="number">5.</span><span class="built_in">update</span>();</span><br><span class="line">  <span class="keyword">if</span> (M<span class="number">5.</span>BtnA.<span class="built_in">pressedFor</span>(<span class="number">2000</span>)) &#123;    <span class="comment">//如果按键按下超过2秒</span></span><br><span class="line">    M<span class="number">5.L</span>cd.<span class="built_in">println</span>(<span class="string">&quot;Button A was pressed for more than 2 seconds.&quot;</span>);</span><br><span class="line">    <span class="built_in">delay</span>(<span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h2 id="wasPressed"><a href="#wasPressed" class="headerlink" title="wasPressed()"></a>wasPressed()</h2><p><strong>功能:</strong></p><p>返回按键按下状态: 如果按键按下,只会返回一次true,否则返回false</p><p><strong>函数原型:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uint8_t wasPressed()</span><br></pre></td></tr></table></figure><p><strong>使用示例:</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;M5Core2.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  M<span class="number">5.</span><span class="built_in">begin</span>();</span><br><span class="line">  M<span class="number">5.L</span>cd.<span class="built_in">println</span>(<span class="string">&quot;Please pressed Button A.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  M<span class="number">5.</span><span class="built_in">update</span>();</span><br><span class="line">  <span class="keyword">if</span> (M<span class="number">5.</span>BtnA.<span class="built_in">wasPressed</span>()) &#123;    <span class="comment">//如果按键按下</span></span><br><span class="line">    M<span class="number">5.L</span>cd.<span class="built_in">println</span>(<span class="string">&quot;Button is pressed.&quot;</span>);</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="built_in">delay</span>(<span class="number">20</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h1 id="9-Released"><a href="#9-Released" class="headerlink" title="9.Released"></a>9.Released</h1><h2 id="isReleased"><a href="#isReleased" class="headerlink" title="isReleased()"></a>isReleased()</h2><p><strong>功能:</strong></p><p>返回按键释放状态: 如果按键释放,返回true; 否则返回false</p><p><strong>函数原型:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uint8_t isPressed()</span><br></pre></td></tr></table></figure><p><strong>使用示例:</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;M5Core2.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  M<span class="number">5.</span><span class="built_in">begin</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  M<span class="number">5.</span><span class="built_in">update</span>();    <span class="comment">//需添加M5.update()才能读取到按键的状态,细节请见System</span></span><br><span class="line">  <span class="keyword">if</span> (M<span class="number">5.</span>BtnA.<span class="built_in">isReleased</span>()) &#123;    <span class="comment">//如果按键释放</span></span><br><span class="line">    M<span class="number">5.L</span>cd.<span class="built_in">println</span>(<span class="string">&quot;Button is released.&quot;</span>);</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    M<span class="number">5.L</span>cd.<span class="built_in">println</span>(<span class="string">&quot;Button is Pressed .&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">delay</span>(<span class="number">20</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h2 id="releasedFor"><a href="#releasedFor" class="headerlink" title="releasedFor()"></a>releasedFor()</h2><p><strong>功能:</strong></p><p>返回按键释放状态: 如果按键释放超过指定时间后,返回true; 否则返回false</p><p><strong>函数原型:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uint8_t pressedFor(uint32_t ms)</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">参数</th><th align="center">类型</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">ms</td><td align="center">uint32_t</td><td align="center">按键释放时间 (毫秒)</td></tr></tbody></table><p><strong>使用示例:</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;M5Core2.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  M<span class="number">5.</span><span class="built_in">begin</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  M<span class="number">5.</span><span class="built_in">update</span>();</span><br><span class="line">  M<span class="number">5.L</span>cd.<span class="built_in">setCursor</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (M<span class="number">5.</span>BtnA.<span class="built_in">releasedFor</span>(<span class="number">2000</span>)) &#123;    <span class="comment">//如果按键释放超过2秒</span></span><br><span class="line">    M<span class="number">5.L</span>cd.<span class="built_in">println</span>(<span class="string">&quot;Button A was released for more than 2 seconds.&quot;</span>);</span><br><span class="line">    <span class="built_in">delay</span>(<span class="number">1000</span>);</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    M<span class="number">5.L</span>cd.<span class="built_in">println</span>(<span class="string">&quot;Button A is pressed                           &quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h2 id="wasReleased"><a href="#wasReleased" class="headerlink" title="wasReleased()"></a>wasReleased()</h2><p><strong>功能:</strong></p><p>返回按键释放状态: 如果按键释放,只会返回一次true,否则返回false</p><p><strong>函数原型:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uint8_t wasReleased()</span><br></pre></td></tr></table></figure><p><strong>使用示例:</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;M5Core2.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  M<span class="number">5.</span><span class="built_in">begin</span>();</span><br><span class="line">  M<span class="number">5.L</span>cd.<span class="built_in">println</span>(<span class="string">&quot;Please pressed Button A.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  M<span class="number">5.</span><span class="built_in">update</span>();</span><br><span class="line">  <span class="keyword">if</span>(M<span class="number">5.</span>BtnA.<span class="built_in">wasReleased</span>()) &#123;    <span class="comment">//如果按键释放</span></span><br><span class="line">    M<span class="number">5.L</span>cd.<span class="built_in">println</span>(<span class="string">&quot;Button is Released.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">delay</span>(<span class="number">20</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h2 id="wasReleasefor"><a href="#wasReleasefor" class="headerlink" title="wasReleasefor()"></a>wasReleasefor()</h2><p><strong>功能:</strong></p><p>返回按键释放状态: 如果按键按下,在超过指定时间后释放,只会返回一次true,否则返回false</p><p><strong>函数原型:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uint8_t wasReleasefor(uint32_t ms)</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">参数</th><th align="center">类型</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">ms</td><td align="center">uint32_t</td><td align="center">按键按下时间 (毫秒)</td></tr></tbody></table><p><strong>使用示例:</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;M5Core2.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  M<span class="number">5.</span><span class="built_in">begin</span>();</span><br><span class="line">  M<span class="number">5.L</span>cd.<span class="built_in">println</span>(<span class="string">&quot;Please pressed Button A.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  M<span class="number">5.</span><span class="built_in">update</span>();</span><br><span class="line">  <span class="keyword">if</span> (M<span class="number">5.</span>BtnA.<span class="built_in">wasReleasefor</span>(<span class="number">3000</span>)) &#123;    <span class="comment">//如果按键A按下3s之后释放</span></span><br><span class="line">      M<span class="number">5.L</span>cd.<span class="built_in">println</span>(<span class="string">&quot;OK&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="10-TOUCH"><a href="#10-TOUCH" class="headerlink" title="10.TOUCH"></a>10.TOUCH</h1><p><strong>这是M5Stack Core2触摸屏库,你可以用该库中的API获取触摸交互信息。以及监听一些触控,手势事件并指定相应的处理程序.触摸屏幕的实际尺寸为<code>320x280</code>, 除去覆盖屏幕部分,剩余的40px高度覆盖到了面板上印有红色圆圈的位置,用户可以通过程序控制来模拟实体按键。</strong></p><h2 id="TouchButton类"><a href="#TouchButton类" class="headerlink" title="TouchButton类"></a>TouchButton类</h2><p>TouchButton继承至TouchZone类, 使用前通过创建实例按键实例,调用实例中包含的方法,进行使用</p><p><strong>构造函数:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TouchButton(uint16_t x_, uint16_t y_, uint16_t w_, uint16_t h_, const char* name_ = &quot;&quot;)</span><br></pre></td></tr></table></figure><p><strong>功能:创建矩形按键区域实例</strong></p><p><strong>获取状态:</strong></p><ul><li>设置按键状态</li><li><code>bool setState(bool)</code></li><li>按键是否按下</li><li><code>bool isPressed()</code></li><li>按键是否释放</li><li><code>bool isReleased()</code></li><li>按键按下触发单次</li><li><code>bool wasPressed()</code></li><li>按键释放触发单次</li><li><code>bool wasReleased()</code></li><li>按键长按-指定时间</li><li><code>bool pressedFor(uint32_t ms)</code></li><li>按键长按-指定时间</li><li><code>bool pressedFor(uint32_t ms, uint32_t continuous_time)</code></li><li>按键释放-指定时间</li><li><code>bool releasedFor(uint32_t ms)</code></li><li>按键按下-指定时间</li><li><code>bool wasReleasefor(uint32_t ms)</code></li></ul><p><strong>获取属性:</strong></p><ul><li><code>int32_t lastChange()</code></li><li><code>uint8_t finger;</code></li><li><code>bool changed;</code></li><li><code>char name[16];</code></li></ul><p><strong>事件监听:</strong></p><ul><li>添加按键触摸处理事件,设置触发事件的类型</li><li><code>void addHandler(void (*fn)(TouchEvent&amp;), uint16_t eventMask = TE_ALL)</code></li><li>事件类型</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NUM_EVENTS    8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TE_TOUCH    0x0001</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TE_RELEASE    0x0002</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TE_MOVE     0x0004</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TE_GESTURE    0x0008</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TE_TAP        0x0010</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TE_DBLTAP    0x0020</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TE_DRAGGED    0x0040</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TE_PRESSED    0x0080</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TE_ALL        0x0FFF</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TE_BTNONLY    0x1000</span></span><br><span class="line"> </span><br></pre></td></tr></table></figure><p><strong>使用示例:</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">  <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;M5Core2.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">Button <span class="title">lt</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>, <span class="number">160</span>, <span class="number">120</span>, <span class="string">&quot;left-top&quot;</span>)</span></span>;</span><br><span class="line"><span class="function">Button <span class="title">lb</span><span class="params">(<span class="number">0</span>, <span class="number">120</span>, <span class="number">160</span>, <span class="number">120</span>, <span class="string">&quot;left-bottom&quot;</span>)</span></span>;</span><br><span class="line"><span class="function">Button <span class="title">rt</span><span class="params">(<span class="number">160</span>, <span class="number">0</span>, <span class="number">160</span>, <span class="number">120</span>, <span class="string">&quot;right-top&quot;</span>)</span></span>;</span><br><span class="line"><span class="function">Button <span class="title">rb</span><span class="params">(<span class="number">160</span>, <span class="number">120</span>, <span class="number">160</span>, <span class="number">120</span>, <span class="string">&quot;right-bottom&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">colorButtons</span><span class="params">(Event&amp; e)</span> </span>&#123;</span><br><span class="line">    Button&amp; b = *e.button;</span><br><span class="line">    M<span class="number">5.L</span>cd.<span class="built_in">fillRect</span>(b.x, b.y, b.w, b.h, b.<span class="built_in">isPressed</span>() ? WHITE : BLACK);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">dblTapped</span><span class="params">(Event&amp; e)</span> </span>&#123;</span><br><span class="line">    Serial.<span class="built_in">println</span>(<span class="string">&quot;--- TOP RIGHT BUTTON WAS DOUBLETAPPED ---&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    M<span class="number">5.</span><span class="built_in">begin</span>();</span><br><span class="line">    M<span class="number">5.</span>Buttons.<span class="built_in">addHandler</span>(colorButtons,  E_TOUCH + E_RELEASE);</span><br><span class="line">    rt.<span class="built_in">addHandler</span>(dblTapped, E_DBLTAP);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    M<span class="number">5.</span><span class="built_in">update</span>();</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h2 id="Gesture类"><a href="#Gesture类" class="headerlink" title="Gesture类"></a>Gesture类</h2><p>Gesture类支持传入两个TouchButton区域,创建触摸手势对象与手势名称。通过<code>addHandler</code>创建手势触发后的处理函数,当由区域1移动至区域2且符合手势配置时将触发处理函数。</p><p><strong>构造函数:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Gesture(TouchZone fromZone_, TouchZone toZone_, const char* name_ = &quot;&quot;, uint16_t maxTime_ = GESTURE_MAXTIME, uint16_t minDistance_ = GESTURE_MINDIST)</span><br></pre></td></tr></table></figure><p><strong>功能:创建矩形按键区域实例</strong></p><p><strong>使用示例:</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;M5Core2.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">TouchZone <span class="title">topHalf</span><span class="params">(<span class="number">0</span>,<span class="number">0</span>,<span class="number">320</span>,<span class="number">120</span>)</span></span>;</span><br><span class="line"><span class="function">TouchZone <span class="title">bottomHalf</span><span class="params">(<span class="number">0</span>,<span class="number">120</span>,<span class="number">320</span>,<span class="number">160</span>)</span></span>;</span><br><span class="line"><span class="function">Gesture <span class="title">swipeDown</span><span class="params">(topHalf, bottomHalf, <span class="string">&quot;Swipe Down&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">yayWeSwiped</span><span class="params">(TouchEvent&amp; e)</span> </span>&#123;</span><br><span class="line">  Serial.<span class="built_in">println</span>(<span class="string">&quot;--- SWIPE DOWN DETECTED ---&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  M<span class="number">5.</span><span class="built_in">begin</span>();</span><br><span class="line">  swipeDown.<span class="built_in">addHandler</span>(yayWeSwiped);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  M<span class="number">5.</span><span class="built_in">update</span>();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h2 id="update-1"><a href="#update-1" class="headerlink" title="update"></a>update</h2><p>所有触摸状态的更新,都依赖于<code>M5.update()</code></p><h2 id="TouchEvent结构体"><a href="#TouchEvent结构体" class="headerlink" title="TouchEvent结构体"></a>TouchEvent结构体</h2><p>当触摸事件被触发时候,将会自动调用该区域使用<code>addHandler</code>所绑定的处理函数,同时将<code>TouchEvent结构体</code>作为参数进行传入。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TouchEvent</span> &#123;</span><br><span class="line">    <span class="type">uint8_t</span> finger;  <span class="comment">//触摸点序号,最大支持两点</span></span><br><span class="line">    <span class="type">uint16_t</span> type;  <span class="comment">//事件类型</span></span><br><span class="line">    TouchPoint from;  <span class="comment">//事件初始触摸点坐标--&gt;x,y</span></span><br><span class="line">    TouchPoint to;   <span class="comment">//事件结束触摸点坐标--&gt;x,y</span></span><br><span class="line">    <span class="type">uint16_t</span> duration; <span class="comment">//事件持续时间</span></span><br><span class="line">    TouchButton* button; <span class="comment">//事件触发对象</span></span><br><span class="line">    Gesture* gesture; <span class="comment">//事件触发手势</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p><strong>使用示例:</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;M5Core2.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">TouchButton lt = <span class="built_in">TouchButton</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">160</span>, <span class="number">120</span>, <span class="string">&quot;left-top&quot;</span>);</span><br><span class="line">TouchButton lb = <span class="built_in">TouchButton</span>(<span class="number">0</span>, <span class="number">120</span>, <span class="number">160</span>, <span class="number">120</span>, <span class="string">&quot;left-bottom&quot;</span>);</span><br><span class="line">TouchButton rt = <span class="built_in">TouchButton</span>(<span class="number">160</span>, <span class="number">0</span>, <span class="number">160</span>, <span class="number">120</span>, <span class="string">&quot;right-top&quot;</span>);</span><br><span class="line">TouchButton rb = <span class="built_in">TouchButton</span>(<span class="number">160</span>, <span class="number">120</span>, <span class="number">160</span>, <span class="number">120</span>, <span class="string">&quot;right-bottom&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">eventDisplay</span><span class="params">(TouchEvent&amp; e)</span> </span>&#123;</span><br><span class="line">  Serial.<span class="built_in">printf</span>(<span class="string">&quot;%-12s finger%d  %-18s (%3d, %3d)&quot;</span>, M<span class="number">5.</span>Touch.<span class="built_in">eventTypeName</span>(e), e.finger, M<span class="number">5.</span>Touch.<span class="built_in">eventObjName</span>(e),  e.from.x, e.from.y);</span><br><span class="line">  <span class="keyword">if</span> (e.type != TE_TOUCH &amp;&amp; e.type != TE_TAP &amp;&amp; e.type != TE_DBLTAP) &#123;</span><br><span class="line">    Serial.<span class="built_in">printf</span>(<span class="string">&quot;--&gt; (%3d, %3d)  %5d ms&quot;</span>, e.to.x, e.to.y, e.duration);</span><br><span class="line">  &#125;</span><br><span class="line">  Serial.<span class="built_in">println</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  M<span class="number">5.</span><span class="built_in">begin</span>();</span><br><span class="line">  M<span class="number">5.</span>Touch.<span class="built_in">addHandler</span>(eventDisplay);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  M<span class="number">5.</span><span class="built_in">update</span>();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h2 id="Touch对象"><a href="#Touch对象" class="headerlink" title="Touch对象"></a>Touch对象</h2><p>随着<code>M5.begin()</code>初始化,将会生成一个Touch实例,该实例中可以获取到当前屏幕的一些触摸操作信息,如坐标,状态等。</p><h2 id="getPressPoint"><a href="#getPressPoint" class="headerlink" title="getPressPoint()"></a>getPressPoint()</h2><p><strong>功能</strong></p><p>获取触摸坐标</p><p><strong>函数原型:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TouchPoint_t getPressPoint()</span><br><span class="line">#include &lt;M5Core2.h&gt;</span><br><span class="line"></span><br><span class="line">void setep() &#123;</span><br><span class="line">    M5.begin();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void loop() &#123;</span><br><span class="line">    TouchPoint_t coordinate;</span><br><span class="line">    coordinate = M5.Touch.getPressPoint();</span><br><span class="line">    Serial.printf(&quot;x:%d, y:%d \r\n&quot;, coordinate.x, coordinate.y);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h2 id="ispressed"><a href="#ispressed" class="headerlink" title="ispressed()"></a>ispressed()</h2><p><strong>功能</strong></p><p>检查屏幕是否按压</p><p><strong>函数原型:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bool ispressed()</span><br></pre></td></tr></table></figure><p><strong>Example</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;M5Core2.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    M<span class="number">5.</span><span class="built_in">begin</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(M<span class="number">5.</span>Touch.<span class="built_in">ispressed</span>()) &#123;</span><br><span class="line">        Serial.<span class="built_in">println</span>(<span class="string">&quot;Pressed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h2 id="HotZone-t-createHotZone"><a href="#HotZone-t-createHotZone" class="headerlink" title="HotZone_t* createHotZone()"></a>HotZone_t* createHotZone()</h2><p><strong>功能</strong></p><p>创建一个触摸热区</p><p><strong>函数原型:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HotZone_t* creatHotZone(uint16_t x0, uint16_t y0, uint16_t w, uint16_t h, void (*fun)() = nullptr )</span><br></pre></td></tr></table></figure><p><strong>Example</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;M5Core2.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doFunc</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">  Serial.<span class="built_in">println</span>(<span class="string">&quot;executed doFunc()&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">HotZone <span class="title">Btn</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>, <span class="number">320</span>, <span class="number">240</span>, &amp;doFunc)</span>)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span></span>&#123;</span><br><span class="line">    M<span class="number">5.</span><span class="built_in">begin</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h2 id="inHotZone"><a href="#inHotZone" class="headerlink" title="inHotZone()"></a>inHotZone()</h2><p><strong>功能</strong></p><p>判断是否在热区内</p><p><strong>函数原型:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bool inHotZone(TouchPoint_t point)</span><br></pre></td></tr></table></figure><p><strong>Example</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;M5Core2.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">HotZone <span class="title">Btn</span><span class="params">(<span class="number">140</span>, <span class="number">100</span>, <span class="number">200</span>, <span class="number">160</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    M<span class="number">5.</span><span class="built_in">begin</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    TouchPoint_t pos = M<span class="number">5.</span>Touch.<span class="built_in">getPressPoint</span>();</span><br><span class="line">    <span class="keyword">if</span>(Btn.<span class="built_in">inHotZone</span>(pos)) &#123;</span><br><span class="line">        Serial.<span class="built_in">printf</span>(<span class="string">&quot;%d, %d\r\n&quot;</span>, pos.x, pos.y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="11-RTC"><a href="#11-RTC" class="headerlink" title="11.RTC"></a>11.RTC</h1><p><strong>类名: Rtc</strong></p><h2 id="begin-2"><a href="#begin-2" class="headerlink" title="begin()"></a>begin()</h2><p><strong>功能:</strong></p><p>初始化RTC时钟</p><p><strong>函数原型:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void begin(void)</span><br></pre></td></tr></table></figure><p><strong>注意:</strong><br>1.如果您不想使用M5.begin() 初始化RTC时钟,请在使用RTC之前调用此功能</p><p><strong>使用示例:</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;M5Core2.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  M<span class="number">5.</span>Rtc.<span class="built_in">begin</span>();  <span class="comment">//初始化 RTC时钟</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h2 id="SetTime"><a href="#SetTime" class="headerlink" title="SetTime()"></a>SetTime()</h2><p><strong>功能:</strong></p><p>设置实时时钟时间</p><p><strong>函数原型:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void SetTime(RTC_TimeTypeDef* RTC_TimeStruct)</span><br></pre></td></tr></table></figure><p><strong>使用示例:</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;M5Core2.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">RTC_TimeTypeDef TimeStruct;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  M<span class="number">5.</span><span class="built_in">begin</span>();</span><br><span class="line"></span><br><span class="line">  TimeStruct.Hours   = <span class="number">18</span>;    <span class="comment">//设置实时时钟结构体的具体时刻</span></span><br><span class="line">  TimeStruct.Minutes = <span class="number">56</span>;</span><br><span class="line">  TimeStruct.Seconds = <span class="number">10</span>;</span><br><span class="line">  M<span class="number">5.</span>Rtc.<span class="built_in">SetTime</span>(&amp;TimeStruct);    <span class="comment">//将设置的时间写入实时时钟</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h2 id="GetTime"><a href="#GetTime" class="headerlink" title="GetTime()"></a>GetTime()</h2><p><strong>功能:</strong></p><p>获取实时时钟时间</p><p><strong>函数原型:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void GetTime(RTC_TimeTypeDef* RTC_TimeStruct)</span><br></pre></td></tr></table></figure><p><strong>使用示例:</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;M5Core2.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">RTC_TimeTypeDef TimeStruct;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  M<span class="number">5.</span><span class="built_in">begin</span>();</span><br><span class="line">  M<span class="number">5.L</span>cd.<span class="built_in">println</span>(<span class="string">&quot;RTC Time TEST&quot;</span>);</span><br><span class="line">  TimeStruct.Hours   = <span class="number">18</span>;</span><br><span class="line">  TimeStruct.Minutes = <span class="number">56</span>;</span><br><span class="line">  TimeStruct.Seconds = <span class="number">10</span>;</span><br><span class="line">  M<span class="number">5.</span>Rtc.<span class="built_in">SetTime</span>(&amp;TimeStruct);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  M<span class="number">5.</span>Rtc.<span class="built_in">GetTime</span>(&amp;TimeStruct);</span><br><span class="line">  M<span class="number">5.L</span>cd.<span class="built_in">setCursor</span>(<span class="number">0</span>, <span class="number">15</span>);</span><br><span class="line">  M<span class="number">5.L</span>cd.<span class="built_in">printf</span>(<span class="string">&quot;Time: %02d : %02d : %02d/n&quot;</span>,TimeStruct.Hours, TimeStruct.Minutes, TimeStruct.Seconds);</span><br><span class="line">  <span class="built_in">delay</span>(<span class="number">500</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h2 id="SetData"><a href="#SetData" class="headerlink" title="SetData()"></a>SetData()</h2><p><strong>功能:</strong></p><p>设置实时时钟日期</p><p><strong>函数原型:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void SetData(RTC_TimeTypeDef* RTC_DateStruct)</span><br></pre></td></tr></table></figure><p><strong>使用示例:</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;M5Core2.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">RTC_DateTypeDef DateStruct;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  M<span class="number">5.</span><span class="built_in">begin</span>();</span><br><span class="line">  DateStruct.WeekDay = <span class="number">3</span>;</span><br><span class="line">  DateStruct.Month = <span class="number">3</span>;</span><br><span class="line">  DateStruct.Date = <span class="number">22</span>;</span><br><span class="line">  DateStruct.Year = <span class="number">2019</span>;</span><br><span class="line">  M<span class="number">5.</span>Rtc.<span class="built_in">SetData</span>(&amp;DateStruct);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h2 id="GetData"><a href="#GetData" class="headerlink" title="GetData()"></a>GetData()</h2><p><strong>功能:</strong></p><p>获取实时时钟日期</p><p><strong>函数原型:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void GetData(RTC_TimeTypeDef* RTC_DateStruct)</span><br></pre></td></tr></table></figure><p><strong>使用示例:</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;M5Core2.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">RTC_DateTypeDef DateStruct;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  M<span class="number">5.</span><span class="built_in">begin</span>();</span><br><span class="line">  M<span class="number">5.L</span>cd.<span class="built_in">println</span>(<span class="string">&quot;RTC Date TEST&quot;</span>);</span><br><span class="line">  DateStruct.WeekDay = <span class="number">5</span>;</span><br><span class="line">  DateStruct.Month = <span class="number">7</span>;</span><br><span class="line">  DateStruct.Date = <span class="number">23</span>;</span><br><span class="line">  DateStruct.Year = <span class="number">2021</span>;</span><br><span class="line">  M<span class="number">5.</span>Rtc.<span class="built_in">SetDate</span>(&amp;DateStruct);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  M<span class="number">5.</span>Rtc.<span class="built_in">GetDate</span>(&amp;DateStruct);    <span class="comment">//获取实时时钟的日期</span></span><br><span class="line">  M<span class="number">5.L</span>cd.<span class="built_in">setCursor</span>(<span class="number">0</span>, <span class="number">15</span>);</span><br><span class="line">  M<span class="number">5.L</span>cd.<span class="built_in">printf</span>(<span class="string">&quot;Data: %04d-%02d-%02d/n&quot;</span>,DateStruct.Year, DateStruct.Month,DateStruct.Date);    <span class="comment">//将此刻实时时钟的日期在屏幕输出</span></span><br><span class="line">  M<span class="number">5.L</span>cd.<span class="built_in">printf</span>(<span class="string">&quot;Week: %d/n&quot;</span>,DateStruct.WeekDay);</span><br><span class="line">  <span class="built_in">delay</span>(<span class="number">500</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h2 id="clearIRQ"><a href="#clearIRQ" class="headerlink" title="clearIRQ()"></a>clearIRQ()</h2><p><strong>功能:</strong></p><p>清除中断请求</p><p><strong>函数原型:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void clearIRQ()</span><br></pre></td></tr></table></figure><h2 id="disableIRQ"><a href="#disableIRQ" class="headerlink" title="disableIRQ()"></a>disableIRQ()</h2><p><strong>功能:</strong></p><p>关闭中断请求</p><p><strong>函数原型:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void disableIRQ()</span><br></pre></td></tr></table></figure><h2 id="SetAlarmIRQ"><a href="#SetAlarmIRQ" class="headerlink" title="SetAlarmIRQ()"></a>SetAlarmIRQ()</h2><p><strong>功能:</strong></p><p>设置中断时钟</p><p><strong>函数原型:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int SetAlarmIRQ(int afterSeconds)</span><br><span class="line">int SetAlarmIRQ( const RTC_TimeTypeDef &amp;RTC_TimeStruct)</span><br><span class="line">int SetAlarmIRQ( const RTC_DateTypeDef &amp;RTC_DateStruct, const RTC_TimeTypeDef &amp;RTC_TimeStruct)</span><br></pre></td></tr></table></figure><p><strong>使用示例:</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;M5Core2.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">RTC_TimeTypeDef TimeStruct;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  M<span class="number">5.</span><span class="built_in">begin</span>();</span><br><span class="line">  M<span class="number">5.L</span>cd.<span class="built_in">println</span>(<span class="string">&quot;RTC SetAlarmIQR&quot;</span>);</span><br><span class="line">  TimeStruct.Hours   = <span class="number">18</span>;</span><br><span class="line">  TimeStruct.Minutes = <span class="number">56</span>;</span><br><span class="line">  TimeStruct.Seconds = <span class="number">10</span>;</span><br><span class="line">  M<span class="number">5.</span>Rtc.<span class="built_in">SetTime</span>(&amp;TimeStruct);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  M<span class="number">5.</span><span class="built_in">update</span>();</span><br><span class="line">  M<span class="number">5.</span>Rtc.<span class="built_in">GetTime</span>(&amp;TimeStruct);</span><br><span class="line">  M<span class="number">5.L</span>cd.<span class="built_in">setCursor</span>(<span class="number">0</span>, <span class="number">15</span>);</span><br><span class="line">  M<span class="number">5.L</span>cd.<span class="built_in">printf</span>(<span class="string">&quot;Time: %02d : %02d : %02d/n&quot;</span>,TimeStruct.Hours, TimeStruct.Minutes, TimeStruct.Seconds);</span><br><span class="line">  <span class="keyword">if</span>(M<span class="number">5.</span>BtnA.<span class="built_in">wasPressed</span>())&#123;</span><br><span class="line">    M<span class="number">5.L</span>cd.<span class="built_in">println</span>(<span class="string">&quot;M5Core2 Will Close, Restore After 5 seconds &quot;</span>);</span><br><span class="line">    <span class="built_in">delay</span>(<span class="number">2000</span>);</span><br><span class="line">    M<span class="number">5.</span>Rtc.<span class="built_in">clearIRQ</span>();</span><br><span class="line">    M<span class="number">5.</span>Rtc.<span class="built_in">SetAlarmIRQ</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">delay</span>(<span class="number">10</span>);</span><br><span class="line">    M<span class="number">5.</span>Axp.<span class="built_in">PowerOff</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二、ESP32函数"><a href="#二、ESP32函数" class="headerlink" title="二、ESP32函数"></a>二、ESP32函数</h1><h1 id="1-GPIO与中断"><a href="#1-GPIO与中断" class="headerlink" title="1.GPIO与中断"></a>1.GPIO与中断</h1><p>GPIO6 ~ 11一般不使用，因为它们接了存储程序的Flash。<br>1.引脚工作方式设置<br>mode可选:<br>INPUT、OUTPUT、INPUT_PULLUP、INPUT_PULLDOWN<br>输入、输出、上拉输入、下拉输入</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">pinMode(pin, mode)</span><br></pre></td></tr></table></figure><p>2.设置某引脚高低电平</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">digitalWrite(pin, value)</span><br></pre></td></tr></table></figure><p>3.读取某引脚电平值</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">digitalRead(pin)</span><br></pre></td></tr></table></figure><p>外部中断：<br>       打开中断，使用</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">attachInterrupt(<span class="type">uint8_t</span> pin, <span class="type">void</span> (*)(<span class="type">void</span>), <span class="type">int</span> mode)</span><br></pre></td></tr></table></figure><p>(引脚号、中断服务函数、服务函数的输入参数、外部中断触发模式)<br>mode可选:<br>RISING、FALLING、CHANGE……<br>上升沿、下降沿、改变时、低电平、高电平…</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">attachInterruptArg(<span class="type">uint8_t</span> pin, <span class="type">void</span> (*)(<span class="type">void</span>*), <span class="type">void</span> * arg, <span class="type">int</span> mode)</span><br></pre></td></tr></table></figure><p>3.关闭中断，使用</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">detachInterrupt(<span class="type">uint8_t</span> pin)</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">使用示例:</span><br><span class="line"><span class="type">void</span> <span class="title function_">callBack</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> level = digitalRead(<span class="number">13</span>); <span class="comment">//读取GPIO_13上的电平</span></span><br><span class="line">  Serial.<span class="built_in">printf</span>(<span class="string">&quot;触发了中断，当前电平是： %d\n&quot;</span>, level);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  Serial.begin(<span class="number">115200</span>);</span><br><span class="line">  Serial.println();</span><br><span class="line"></span><br><span class="line">  pinMode(<span class="number">13</span>,OUTPUT);    <span class="comment">//GPIO_13,输出模式</span></span><br><span class="line">  attachInterrupt(<span class="number">13</span>, callBack, CHANGE);  <span class="comment">//当电平发生变化时，触发中断</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    delay(<span class="number">1000</span>);</span><br><span class="line">    digitalWrite(<span class="number">13</span>, <span class="number">1</span> ^ digitalRead(<span class="number">13</span>)); <span class="comment">//翻转 GPIO_13 电平</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  detachInterrupt(<span class="number">13</span>); <span class="comment">//关闭中断</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-PWM（LEDC）"><a href="#2-PWM（LEDC）" class="headerlink" title="2.PWM（LEDC）"></a>2.PWM（LEDC）</h1><p>ESP32有一个LEDC，原本设计用来控制LED，可以作简单的PWM输出<br>LEDC总共有16个路通道（0 ~ 15），分为高低速两组，高速通道（0 ~ 7）由80MHz时钟驱动，低速通道（8 ~ 15）由1MHz时钟驱动。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> <span class="title function_">ledcSetup</span><span class="params">(<span class="type">uint8_t</span> channel, <span class="type">double</span> freq, <span class="type">uint8_t</span> resolution_bits)</span></span><br></pre></td></tr></table></figure><p>channel为通道号，取值0 ~ 15；freq，设置频率；resolution_bits计数位数，取值0 ~ 20（该值决定后面ledcWrite方法中占空比的最大值，如该值写10，则占空比最大可写2^10-1&#x3D;1023 ；<br>   通道最终频率 &#x3D; 时钟频率 &#x2F; ( 分频系数 * ( 2^计数位数 ) )；（分频系数最大为1024）<br>   该方法返回值：最终频率；</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ledcWrite</span><span class="params">(<span class="type">uint8_t</span> channel, <span class="type">uint32_t</span> duty)</span></span><br></pre></td></tr></table></figure><p>(通道，占空比)；指定通道输出一定占空比的波形；</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> <span class="title function_">ledcWriteTone</span><span class="params">(<span class="type">uint8_t</span> channel, <span class="type">double</span> freq)</span></span><br></pre></td></tr></table></figure><p>(通道，频率)</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">uint32_t</span> <span class="title function_">ledcRead</span><span class="params">(<span class="type">uint8_t</span> channel)</span></span><br></pre></td></tr></table></figure><p>（通道）；返回指定通道占空比的值；</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> <span class="title function_">ledcReadFreq</span><span class="params">(<span class="type">uint8_t</span> channel)</span></span><br></pre></td></tr></table></figure><p>（通道）；返回指定通道当前频率（如果当前占空比为0 则该方法返回0）；</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ledcAttachPin</span><span class="params">(<span class="type">uint8_t</span> pin, <span class="type">uint8_t</span> channel)</span></span><br></pre></td></tr></table></figure><p>（引脚，通道）；绑定：将LEDC通道投射到指定IO口上；</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ledcDetachPin</span><span class="params">(<span class="type">uint8_t</span> pin)</span></span><br></pre></td></tr></table></figure><p>（引脚）;解除绑定：解除IO口的LEDC功能；</p><p>使用示例:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// GPIO_14 输出PWM</span></span><br><span class="line"><span class="comment">// GPIO_12 读取IO14输出的信号</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  Serial.begin(<span class="number">115200</span>);</span><br><span class="line">  Serial.println();</span><br><span class="line"></span><br><span class="line">  ledcSetup(<span class="number">8</span>, <span class="number">1</span>, <span class="number">10</span>);  <span class="comment">//设置LEDC通道8频率为1，分辨率为10位，即占空比可选0~1023</span></span><br><span class="line">  ledcAttachPin(<span class="number">14</span>, <span class="number">8</span>); <span class="comment">//设置LEDC通道8在IO14上输出</span></span><br><span class="line"></span><br><span class="line">  pinMode(<span class="number">12</span>, INPUT_PULLDOWN);   <span class="comment">//引脚12，下拉输入</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    ledcWrite(<span class="number">8</span>, <span class="number">250</span> * i); <span class="comment">//设置输出PWM</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">100</span>; j++)</span><br><span class="line">    &#123;</span><br><span class="line">      delay(<span class="number">10</span>);</span><br><span class="line">      Serial.println(digitalRead(<span class="number">12</span>));  <span class="comment">//读取引脚12的电平并输出</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-FreeRtos"><a href="#3-FreeRtos" class="headerlink" title="3.FreeRtos"></a>3.FreeRtos</h1><ul><li><strong>创建一个任务</strong></li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">xTaskCreate(</span><br><span class="line"></span><br><span class="line">  TaskCode,          <span class="comment">/* 任务将要调用的功能函数 */</span></span><br><span class="line"></span><br><span class="line">  TaskName,        <span class="comment">/* 任务名字 */</span></span><br><span class="line"></span><br><span class="line">  StackDepth,            <span class="comment">/* Stack size in bytes. */</span></span><br><span class="line"></span><br><span class="line">  Parameter,             <span class="comment">/* Parameter passed as input of the task */</span></span><br><span class="line"></span><br><span class="line">  priority,                <span class="comment">/* 任务优先级 */</span></span><br><span class="line"></span><br><span class="line">  TaskHandle);            <span class="comment">/* 句柄 */</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><p>TaskCode:指向任务函数的指针</p></li><li><p>TaskName:任务的名称</p></li><li><p>StackDepth:任务堆栈大小，以字节数表示。</p></li><li><p>Parameter:指针，指向任务函数所接收的参数</p></li><li><p>Priority:任务的优先级，数字越大优先级越高，默认最大32级（不定，可以自行去库文件修改），不同任务可以有相同优先级，够用的情况下，最大优先级越小越好</p></li><li><p>TaskHandle:返回一个句柄，用于以后进行函数调用（比如要删除某个任务或者修改其优先级）时对任务的引用</p></li><li><p>该函数会返回pdPass（成功时）或错误代码</p></li><li><p><strong>任务函数</strong></p></li></ul><p>任务函数就是我们自定义的功能函数了，注意，任务函数不能有任何返回值，即应该定义成void使用<code>TaskDelte（句柄）</code>函数可以删除任务</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span> &#123;</span><br><span class="line">  Serial.begin(<span class="number">112500</span>);</span><br><span class="line">  delay(<span class="number">1000</span>);</span><br><span class="line">  xTaskCreate(</span><br><span class="line">                    taskOne,          <span class="comment">/* Task function. */</span></span><br><span class="line">                    <span class="string">&quot;TaskOne&quot;</span>,        <span class="comment">/* String with name of task. */</span></span><br><span class="line">                    <span class="number">10000</span>,            <span class="comment">/* Stack size in bytes. */</span></span><br><span class="line">                    <span class="literal">NULL</span>,             <span class="comment">/* Parameter passed as input of the task */</span></span><br><span class="line">                    <span class="number">1</span>,                <span class="comment">/* Priority of the task. */</span></span><br><span class="line">                    <span class="literal">NULL</span>);            <span class="comment">/* Task handle. */</span></span><br><span class="line"></span><br><span class="line">  xTaskCreate(</span><br><span class="line">                    ,          <span class="comment">/* Task function. */</span></span><br><span class="line">                    <span class="string">&quot;TaskTwo&quot;</span>,        <span class="comment">/* String with name of task. */</span></span><br><span class="line">                    <span class="number">10000</span>,            <span class="comment">/* Stack size in bytes. */</span></span><br><span class="line">                    <span class="literal">NULL</span>,             <span class="comment">/* Parameter passed as input of the task */</span></span><br><span class="line">                    <span class="number">1</span>,                <span class="comment">/* Priority of the task. */</span></span><br><span class="line">                    <span class="literal">NULL</span>);            <span class="comment">/* Task handle. */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span> &#123;</span><br><span class="line">  delay(<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">taskOne</span><span class="params">( <span class="type">void</span> * parameter )</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>( <span class="type">int</span> i = <span class="number">0</span>;i&lt;<span class="number">10</span>;i++ )&#123;</span><br><span class="line">        Serial.println(<span class="string">&quot;Hello from task 1&quot;</span>); </span><br><span class="line">​    delay(<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line">Serial.println(<span class="string">&quot;Ending task 1&quot;</span>);</span><br><span class="line">vTaskDelete( <span class="literal">NULL</span> );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">taskTwo</span><span class="params">( <span class="type">void</span> * parameter)</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>( <span class="type">int</span> i = <span class="number">0</span>;i&lt;<span class="number">10</span>;i++ )&#123;</span><br><span class="line">        Serial.println(<span class="string">&quot;Hello from task 2&quot;</span>);</span><br><span class="line">​    delay(<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line">Serial.println(<span class="string">&quot;Ending task 2&quot;</span>);</span><br><span class="line">vTaskDelete( <span class="literal">NULL</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> M5STACK </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>推力计算</title>
      <link href="/3.%E6%8E%A8%E5%8A%9B%E8%AE%A1%E7%AE%97/"/>
      <url>/3.%E6%8E%A8%E5%8A%9B%E8%AE%A1%E7%AE%97/</url>
      
        <content type="html"><![CDATA[<h3 id="推力计算"><a href="#推力计算" class="headerlink" title="推力计算"></a>推力计算</h3><p>动力系统是水下航行器的重要组成部分，选择和设计推进器主要考虑水下航行器的航行速度及本体阻力。可由下式估算：<br>$$<br>F_{d} ＝0.5\rho AV^{2} C_{d}<br>$$<br>式中：</p><p>ρ——海水密度，一般在海面取为1028 kg&#x2F;m³ 3;淡水密度，一般在水面取为1000 kg&#x2F;m³；</p><p>A——特征面积（平方米），约为载体体积的 2&#x2F;3 次幂，或物体在水流方向上的投影面积；</p><p><em>v</em>——速度（m&#x2F;s）；</p><p><em>C</em>d——无因次阻力系数；取 Cd&#x3D;0.8~1。</p><p>航形器推力To、Tw 分别为航行器在出水过程、空中航行和水下航行时的推力<br>$$<br>To&#x3D;1.5kmg<br>$$</p><p>$$<br>Tw&#x3D;Dw<br>$$</p><p>式中：k为附加质量系数，k&gt;1；mg 为航行器的重力；Dw 分为航行器在水下所受到的阻力。</p><p>附加质量系数（k）是一种描述流体对物体（如AUV）加速运动的阻力的参数。当AUV在水中加速运动时，周围的流体会跟随物体运动，产生附加的惯性力。附加质量系数是为了考虑这种效应而引入的参数。</p><p>水下推进系统是安装在无人机尾部的螺旋桨。螺旋桨应提供足够的推进力来完成水下巡航。由于其结构和形状的复杂性，用解析或数值方法难以估计其阻力。因此，需要建立比例模型来测量无人机以 V速度在水下巡航时的水中阻力。</p>]]></content>
      
      
      
        <tags>
            
            <tag> UAV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>水翼样机设计</title>
      <link href="/2.%E6%B0%B4%E7%BF%BC%E6%A0%B7%E6%9C%BA%E8%AE%BE%E8%AE%A1/"/>
      <url>/2.%E6%B0%B4%E7%BF%BC%E6%A0%B7%E6%9C%BA%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="水翼样机设计"><a href="#水翼样机设计" class="headerlink" title="水翼样机设计"></a>水翼样机设计</h1><h2 id="大致模板"><a href="#大致模板" class="headerlink" title="大致模板"></a>大致模板</h2><p>尺寸（长宽高）173.5 * 81.4 * 95cm</p><p><img src="../images/Hydrofoil/Hydrofoil14.png"></p><h2 id="方案初步设计"><a href="#方案初步设计" class="headerlink" title="方案初步设计"></a>方案初步设计</h2><h3 id="冲浪板设计"><a href="#冲浪板设计" class="headerlink" title="冲浪板设计"></a>冲浪板设计</h3><h4 id="轮廓设计"><a href="#轮廓设计" class="headerlink" title="轮廓设计"></a>轮廓设计</h4><p>冲浪板的轮廓（outline）或平面形状是冲浪板最明显的特征。任何板的整体平面形状一般由常见的板型参数决定的——长度、板头宽度（nose width）、宽点（wide point）宽度和板尾宽度（tail width）。</p><p><img src="../images/Hydrofoil/Hydrofoil16.png"></p><p>长度确定：冲浪板通常分为长板、中板、短板三种尺寸。长板的标准长度是在九英尺（约2.74m）以上，短板的标准长度是在七英尺（2.13m）以下，中板的尺寸介于长板和短板之间，兼具长短板不同的特点和优点。长板提供更好的稳定性，更容易在波浪中保持平衡。此外，长板在小波浪和不太理想的条件下表现更好。短板可以实现更高的速度和更强的操控性，能在大波浪中完成更复杂的动作。</p><p><strong>考虑到整个跨介质机器人长约1m，设计的水翼样机长度初步定为0.6m，即60cm。</strong></p><h4 id="板头宽度"><a href="#板头宽度" class="headerlink" title="板头宽度"></a><strong>板头宽度</strong></h4><p><img src="../images/Hydrofoil/Hydrofoil15.png"></p><p>在短板上使用较宽的板头（大于11英寸），有助于弥补板排水量的整体减少，在较平的冲浪板上，较宽的板头有助于产生更多的升力。但一般来说，短板性能板的板头宽度（鼻部宽度）约在11英寸（约28厘米）到12英寸（约30.5厘米）之间。这种设计使得短板在波浪中更具灵活性和敏捷性，以便完成更为复杂的冲浪动作。</p><p><strong>考虑到上述情况，设计冲浪板板头宽度初步定为11英寸（约28厘米），在等比例缩小0.5后为14cm。</strong></p><h4 id="板尾宽度"><a href="#板尾宽度" class="headerlink" title="板尾宽度"></a><strong>板尾宽度</strong></h4><p>较宽的板尾（大于14英寸）设计最常见于适合较小、较软的浪，以及具有4个或更多尾鳍的冲浪板上。更宽的板尾使得移动缓慢的冲浪板可保持在水面上滑行。通常，短板性能板的板尾宽度约在14英寸（约35.5厘米）到15英寸（约38厘米）之间。这种设计有助于提供更好的操控性，使冲浪者能够在波浪中轻松地调整方向和完成高难度的动作。</p><p><strong>在这里，如上取中间值，设计冲浪板板尾宽度初步定为14英寸（约35.5厘米），在等比例缩小0.5后为17.78cm。</strong></p><h4 id="宽点"><a href="#宽点" class="headerlink" title="宽点"></a><strong>宽点</strong></h4><p>性能短板的宽点经常出现在板长的中点后面，而在许多复古板、长板和枪板的宽点则在中点之前。将宽点向后移会缩短冲浪板的转弯半径，但会影响驱动力。而宽点前移会使转弯半径更大，但保持了更多的驱动力。将宽点置于板长的中点通常被认为是“中性的”。这种设计在驱动力和响应能力之间取得折衷。</p><p>较宽的板（19英寸或更宽）比较窄的板具有更多的排水量和板底面积，在所有其他条件相同的情况下，这增加了浮力和划水的便利性。更宽的板也更稳定，更宽的板尾也是如此。通常情况下，短板性能板的宽点宽度约在18英寸（约45.7厘米）到20英寸（约50.8厘米）之间。这种设计有助于在保持操控性的同时，为冲浪者提供一定的浮力和稳定性。</p><p><strong>在这里，如上取中间值，设计冲浪板的宽点置于板长的中点，宽点宽度初步定为19英寸（约48.3厘米），在等比例缩小0.5后为24.13cm。</strong></p><h4 id="板面曲面"><a href="#板面曲面" class="headerlink" title="板面曲面"></a><strong>板面曲面</strong></h4><p>冲浪板的板缘到板缘之间的横剖面也是“翼型的&#x2F;foiled”，通常在龙骨处最厚，然后向外朝着板缘平滑地逐渐变薄。这种翼型形状不仅决定了板的厚度，也有助于确定板缘的厚度和排水量。因为板面可能是平的（flat）、圆顶的（domed）、凹型的（concave）或介于两者之间的任何形状。一般来说，板面越平，板面侧的排水量越往板缘分布，板的总排水量就越大，这种设计旨在提高稳定性和驱动力。</p><p>薄的板（最厚处为2.375英寸即6.0325cm或更薄）更容易变形，更难划水，同时驱动力也更小，但反应更快；这类板非常适合较好的浪和块头小或较高阶以及划水有力的冲浪者。厚的板（最厚处2.5英寸即6.35cm或更厚）不太可能折断，但在弹性变形方面显得刚硬，同时由于浮力增加使得划水更容易，且更有驱动力。</p><p><img src="../images/Hydrofoil/Hydrofoil1.png"></p><p><strong>在这里，考虑到稳定性和驱动力以及控制区域的设计要求（电池高约4cm），设计初步选择平的曲面，厚度为8cm。</strong></p><h4 id="冲浪板翘度"><a href="#冲浪板翘度" class="headerlink" title="冲浪板翘度"></a><strong>冲浪板翘度</strong></h4><p>典型的现代性能短板在板头尖处有大约5英寸的板头翘度，在板尾尖处有大约2又1&#x2F;4英寸的板尾翘度。所以对于大多数冲浪者来说，每种板的性能参数几乎都是预先确定的。大翘度（heavy rocker）或说非常弯曲的板会产生相对较大的升力和阻力，小翘度的板产生的升力小，但阻力也小。</p><p><img src="../images/Hydrofoil/Hydrofoil18.png"></p><p>以下是一个简单的表格，显示了几种不同类型常见长度的冲浪板的典型（板头和板尾）翘度规格：</p><p><img src="../images/Hydrofoil/Hydrofoil17.png"></p><p><strong>在这里，根据短板的典型值，设计的翘度为5英寸（约12.7cm）和2.5英寸（约6.35cm）。</strong></p><h4 id="板尾形状"><a href="#板尾形状" class="headerlink" title="板尾形状"></a><strong>板尾形状</strong></h4><p>目前为止最为流行的板尾是圆方尾，它提供了很多人理想中的升力和释放之间的平衡 ——其形状使得转向剧烈但流畅。</p><p><img src="../images/Hydrofoil/Hydrofoil3.png"></p><p><strong>综合，考虑板尾设计为圆方尾。</strong></p><h4 id="板底设计"><a href="#板底设计" class="headerlink" title="板底设计"></a><strong>板底设计</strong></h4><p>在理论上将所有板底（曲面）设计按特征分为三类：平面&#x2F;平的（flat）、凹面&#x2F;凹的（concave，俗称水槽）和凸面&#x2F;凸的（convex）。平底以非常可预测和平衡的方式发挥作用，特别是在中等速度和中等尺寸的浪中。许多削板师都同意，在一定条件下平底冲浪板是所有板底设计中效率最高、速度最快的。</p><p><strong>综合，考虑板底设计为平底。</strong></p><h3 id="水翼设计"><a href="#水翼设计" class="headerlink" title="水翼设计"></a>水翼设计</h3><p>基于前几周科大的师兄的水翼设计文档以及文献T 型水翼结构及轻量化设计，初步确定了水翼的基本参数。其中：<em>b</em> 为立柱高度，<em>c</em> 为立柱弦长，<em>d</em> 为水平主翼翼展，<em>c</em>r为翼根弦弦长，<em>c</em>t为翼尖弦弦长。</p><p><img src="../images/Hydrofoil/Hydrofoil2.png"></p><h4 id="翼型确定"><a href="#翼型确定" class="headerlink" title="翼型确定"></a>翼型确定</h4><p>基于对于水翼样机运行高速稳定等条件需要，NACA 系列翼型相对成熟且调用方便。因此，本文选择 NACA4 位翼型。</p><p>NACA0021 翼型为对称翼型，可以承受较大压力，故选用此翼型为立柱翼型。</p><p>NACA2421 翼型具有良好的升阻比性能及较大的失速攻角，可以产生较大升力，故选用此翼型为水平主翼翼型。</p><p><img src="../images/Hydrofoil/Hydrofoil5.png"></p><h4 id="立柱翼型参数确定"><a href="#立柱翼型参数确定" class="headerlink" title="立柱翼型参数确定"></a>立柱翼型参数确定</h4><p>根据设计要求以及参考水翼冲浪板的设计，立柱高度为15cm。</p><p><img src="../images/Hydrofoil/Hydrofoil4.png"></p><p>立柱翼型的展弦比</p><p><img src="../images/Hydrofoil/Hydrofoil6.png"></p><p>由图 可知：水平主翼保持不变，立柱展弦比由1 到 10 时，T 型水翼升阻比和升力系数先增加后趋于稳定。因此，当立柱展弦比取 6 时，T 型水翼具有较大的升阻比和较好的水动力性能。</p><p><strong>根据设计要求，立柱高度为 15cm，因此确定立柱弦长为2.5 cm，厚度为5.25mm。</strong></p><h4 id="前水翼翼型参数确定"><a href="#前水翼翼型参数确定" class="headerlink" title="前水翼翼型参数确定"></a>前水翼翼型参数确定</h4><p>基于科大师兄们的前期工作，确定水翼的基本参数。水翼机翼展弦比为5，水平主翼尖削比为 0.2，水翼攻角为 6°时具有较好的水动力效果。翼展和弦长如下（其中：l为翼展，b为平均弦长 ）：</p><table><thead><tr><th align="center">l(m)</th><th>5m&#x2F;s</th><th>10</th><th>15</th><th>20</th></tr></thead><tbody><tr><td align="center">1</td><td>0.0965</td><td>0.0607</td><td>0.0462</td><td>0.0381</td></tr><tr><td align="center">1.5kg</td><td>0.1182</td><td>0.0743</td><td>0.0566</td><td>0.0467</td></tr><tr><td align="center">2</td><td>0.1365</td><td>0.0858</td><td>0.0654</td><td>0.0539</td></tr><tr><td align="center">5</td><td>0.2158</td><td>0.1356</td><td>0.1034</td><td>0.0852</td></tr></tbody></table><table><thead><tr><th align="center">b(m)</th><th>5m&#x2F;s</th><th>10</th><th>15</th><th>20</th></tr></thead><tbody><tr><td align="center">1</td><td>0.0193</td><td>0.0121</td><td>0.0092</td><td>0.0076</td></tr><tr><td align="center">1.5kg</td><td>0.0236</td><td>0.0149</td><td>0.0113</td><td>0.0093</td></tr><tr><td align="center">2</td><td>0.0273</td><td>0.0172</td><td>0.0131</td><td>0.0108</td></tr><tr><td align="center">5</td><td>0.0432</td><td>0.0271</td><td>0.0207</td><td>0.0170</td></tr></tbody></table><p>以整体跨介质机器人为考虑对象，重约1.5kg，最大滑行速度≥5.56m&#x2F;s，最大潜行速度≥2.78m&#x2F;s，根据上表选择1.5kg，10m&#x2F;s速度下的参数。</p><p><strong>即翼展（l）为7.43cm，平均弦长（b）为1.49cm，厚度为0.32cm，具体如下图</strong></p><p><img src="../images/Hydrofoil/Hydrofoil8.png"></p><h4 id="前水翼控制"><a href="#前水翼控制" class="headerlink" title="前水翼控制"></a>前水翼控制</h4><p><img src="../images/Hydrofoil/Hydrofoil7.png"></p><p>上图为控制两个水翼pitch运动的连杆机构，通过参考这个进行设计。</p><p>水翼的yaw运动，暂时还未有较好的想法。</p><h4 id="尾翼翼型参数确定"><a href="#尾翼翼型参数确定" class="headerlink" title="尾翼翼型参数确定"></a>尾翼翼型参数确定</h4><p>尾翼基于前翼的2&#x2F;3设计。即翼展（l）为4.96cm，平均弦长（b）为0.83cm 。</p><h4 id="连接件长度确定"><a href="#连接件长度确定" class="headerlink" title="连接件长度确定"></a>连接件长度确定</h4><p>设计一个类圆锥形的连接前水翼和尾翼的连接件，长度为18cm，半径和电机配套。</p><h3 id="电路设计"><a href="#电路设计" class="headerlink" title="电路设计"></a>电路设计</h3><h4 id="模块整定"><a href="#模块整定" class="headerlink" title="模块整定"></a>模块整定</h4><table><thead><tr><th align="center">模块</th><th align="center">数目</th><th align="center">重量</th><th align="center">规格（长宽高mm）</th></tr></thead><tbody><tr><td align="center">雷迅V5+</td><td align="center">1</td><td align="center">91g</td><td align="center">85.5 * 42 * 33</td></tr><tr><td align="center">雷迅自带电源管理模块</td><td align="center">1</td><td align="center">20g</td><td align="center">——————</td></tr><tr><td align="center">格氏4s120c2000mah电池</td><td align="center">1</td><td align="center">215g</td><td align="center">77 * 38.5 * 41</td></tr><tr><td align="center">四合一60A电调</td><td align="center">1</td><td align="center">14.5g</td><td align="center">——————</td></tr><tr><td align="center">2429防水电机</td><td align="center">1</td><td align="center">55g</td><td align="center">——————</td></tr><tr><td align="center">2429配套桨叶</td><td align="center">1</td><td align="center">3.9g</td><td align="center">——————</td></tr><tr><td align="center">5kg微型舵机</td><td align="center">2</td><td align="center">12g * 2</td><td align="center">——————</td></tr><tr><td align="center">M10深度传感器</td><td align="center">1</td><td align="center">17.2g</td><td align="center">——————</td></tr><tr><td align="center">总重</td><td align="center">——</td><td align="center">440.6g</td><td align="center">——————</td></tr><tr><td align="center">具体水翼部分总重</td><td align="center">——</td><td align="center">100.1g</td><td align="center">——————</td></tr></tbody></table><h4 id="具体水翼部分"><a href="#具体水翼部分" class="headerlink" title="具体水翼部分"></a>具体水翼部分</h4><p><a href="https://item.taobao.com/item.htm?id=619179731744&price=18-88&sourceType=item&sourceType=item&suid=a33c1756-7ce7-45ea-8d98-045c6cdd6492&shareUniqueId=20882118293&ut_sk=1.YeWEmUVcKgkDAJMmT5nSmqcQ_21646297_1681180836505.Copy.1&un=3fec28508c4c9b564b3a4c4170b47de1&share_crt_v=1&un_site=0&spm=a2159r.13376460.0.0&sp_abtk=gray_1_code_simpleAndroid2&tbSocialPopKey=shareItem&sp_tk=REo2TmRQbEFoa3M=&cpp=1&shareurl=true&short_name=h.UsNuKtt&bxsign=scdjxbCfix98BqmvAozD_dyu4CEDwWL2hU0YWTtip9a_aHKfM5MOIgPSVR2nI9uOpH0ZQgHXdH_HqeWkSiP2syIvrF7qAxkAQIqK4tV42F4xJm6nGQONIKGel3hu1zRuMWU&tk=DJ6NdPlAhks&app=chrome">24292429防水电机</a></p><p><img src="../images/Hydrofoil/Hydrofoil9.png"></p><p><a href="https://item.taobao.com/item.htm?id=641048324758&price=18-125&sourceType=item&sourceType=item&suid=5a0de8eb-d0e9-4e37-96cb-b63f30a240a5&shareUniqueId=20882280080&ut_sk=1.YeWEmUVcKgkDAJMmT5nSmqcQ_21646297_1681180836505.Copy.1&un=3fec28508c4c9b564b3a4c4170b47de1&share_crt_v=1&un_site=0&spm=a2159r.13376460.0.0&sp_abtk=gray_1_code_simpleAndroid2&tbSocialPopKey=shareItem&sp_tk=Q3ZQRGRQT1p1STY=&cpp=1&shareurl=true&short_name=h.UHTo2RC&bxsign=scdXTWbzm0M2YbJZT0hScAScc0vIxlxPgtiR5xj84b-XtSb8iCvFBdFbCuow7Ono7JNjQ_N1whQOh6yMZ0SxtyLy5ontCPq61MaI-EPmN8hbB54E35ySiRqFZYlogzqNZb5&tk=CvPDdPOZuI6&app=chrome">2429配套桨叶</a></p><p><img src="../images/Hydrofoil/Hydrofoil11.png"></p><p><a href="https://item.taobao.com/item.htm?id=655259002426&price=45-135&sourceType=item&sourceType=item&suid=11e40215-0df3-4d49-b5ec-d10bfe5e457f&shareUniqueId=20600753558&ut_sk=1.YeWEmUVcKgkDAJMmT5nSmqcQ_21646297_1679462349080.Copy.1&un=3fec28508c4c9b564b3a4c4170b47de1&share_crt_v=1&un_site=0&spm=a2159r.13376460.0.0&sp_abtk=gray_1_code_simpleAndroid2&tbSocialPopKey=shareItem&sp_tk=Mk5oVWRRNjVYREQ=&cpp=1&shareurl=true&short_name=h.UrC6EXo&bxsign=scd0hdnUG5DG0gtV2dv2YKuIR7-R_g8WR-RNnGMO64l4blA7MDh2-EZNllwqVPeoY1PqpOvekkA3Fj91EWrdVPbLRO_0m75Frj6m3IJxHktRFej5ySKhYSctiNvsXobgqP0&tk=2NhUdQ65XDD&app=chrome">5kg微型舵机</a></p><p><img src="../images/Hydrofoil/Hydrofoil10.png"></p><p><a href="https://item.taobao.com/item.htm?id=544786964822">M10深度传感器</a></p><p>30bar即300m，0.2mbar即2mm。</p><p><img src="../images/Hydrofoil/Hydrofoil13.png"></p><h4 id="耐压密封部分"><a href="#耐压密封部分" class="headerlink" title="耐压密封部分"></a>耐压密封部分</h4><p>根据情况，设计玻璃耐压仓。</p><h3 id="草图："><a href="#草图：" class="headerlink" title="草图："></a>草图：</h3><p><img src="../images/Hydrofoil/Hydrofoil12.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> UAV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>飞行器机翼设计</title>
      <link href="/1.%E9%A3%9E%E8%A1%8C%E5%99%A8%E6%9C%BA%E7%BF%BC%E8%AE%BE%E8%AE%A1/"/>
      <url>/1.%E9%A3%9E%E8%A1%8C%E5%99%A8%E6%9C%BA%E7%BF%BC%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="飞行器机翼设计"><a href="#飞行器机翼设计" class="headerlink" title="飞行器机翼设计"></a>飞行器机翼设计</h1><h3 id="1-设计要求"><a href="#1-设计要求" class="headerlink" title="1.设计要求"></a>1.设计要求</h3><p>设计一架类固定翼的跨介质飞行器，跨介质飞行器设计要求如表 1.1 所示。</p><p>​                                                                                 <strong>表1.1 跨介质飞行器性能指标</strong></p><table><thead><tr><th align="center">巡航空速</th><th align="center">失速速度</th><th align="center">最大飞行速度</th><th align="center">最大滑行速度</th><th align="center">最大潜行速度</th><th align="center">最大潜行深度</th><th align="center">总重量</th><th align="center">续航时间</th></tr></thead><tbody><tr><td align="center">≥16.67m&#x2F;s</td><td align="center">10m&#x2F;s</td><td align="center">≥33.34m&#x2F;s</td><td align="center">≥5.56m&#x2F;s</td><td align="center">≥2.78m&#x2F;s</td><td align="center">≥5m</td><td align="center">约1.5kg</td><td align="center">≥30min</td></tr></tbody></table><h3 id="2-跨介质飞行器主要参数估算"><a href="#2-跨介质飞行器主要参数估算" class="headerlink" title="2.跨介质飞行器主要参数估算"></a>2.跨介质飞行器主要参数估算</h3><p>总体设计的初期完全定好各项参数是比较困难的，而最主要的飞行器设计参数有三个:</p><ol><li>飞行器的起飞重量$W_{T}$（Kg）;</li><li>机翼面积 S（m²）;</li><li>电机驱动螺旋桨的推力 P（N）；</li></ol><p>这三个参数中任意一个出现变化，就会导致整个飞行器的总体设计方案的改动。对上述三个参数进行处理，给出了下面两个相对参数:</p><ol><li>翼载荷W&#x2F;S（kg&#x2F;m²）；</li><li>推重比T&#x2F;W；</li></ol><p>跨介质飞行器在空中匀速平飞时，重力与升力平衡，由平飞要求有：<br>$$<br>W＝\frac{1}{2} \rho  V_{min}^{2}SC_{Lmax}<br>$$<br>式中：W为飞行器重量，</p><p>​$\rho$为空气密度，</p><p>​S 为机翼面积，</p><p>​$V_{min} $为最小平飞速度，</p><p>​$C_{Lmax}$为最大升力系数</p><p>经过变换可得:<br>$$<br>\frac{W}{S}＝\frac{1}{2} \rho  V^{2}C_{L}<br>$$<br>当平飞时，推进器推力等于跨介质航行器阻力<br>$$<br>T＝\frac{1}{2}\rho V^{2}SC_{x}<br>$$<br>式中：T ——跨介质航行器机翼的推进器推力，N</p><p>$ C_{x}$为阻力系数</p><p>$ C_{x}$阻力系数可表示为：<br>$$<br>C_{x} ＝C_{X_{0} } + C_{X_{i} }<br>$$<br>式中：$ C_{X_{0} }  $为零升阻力系数，这部分阻力系数与飞行器在没有产生升力时的阻力有关，主要包括形状阻力和摩擦阻力。形状阻力主要由飞行器的几何形状和流体特性决定，而摩擦阻力主要由飞行器表面的粗糙度和空气的粘性特性决定。零升阻力系数与飞行器的设计和制造质量密切相关。</p><p>​$  C_{X_{i} }  $为升致阻力系数，这部分阻力系数与飞行器在产生升力时所引起的阻力有关，主要是诱导阻力。诱导阻力是由于机翼产生升力时在机翼尖端形成的涡旋而产生的阻力。</p><p>将（4）式代入（3）式，得到：<br>$$<br>T＝\frac{1}{2} \rho V^{2}SC_{X_{0} } +\frac{1}{2} \rho V^{2}SC_{X_{i} }<br>$$<br>根据椭圆涡旋理论，我们可以得到以下公式来计算诱导阻力系数（升致阻力系数）：<br>$$<br>C_{xi} ＝\frac{ C_{L}^{2}}{π λ  e}<br>$$<br>其中：</p><ul><li>$C_{xi}$：诱导阻力系数</li><li>$C_{L}$：升力系数</li><li>λ ：展弦比，即翼展与平均弦长之比</li><li>e：奥斯瓦尔德效率因子，定义一个机翼效率的数字。椭圆翼效率最高，e为1。</li></ul><p>将（6）式代入（5）式，得到：<br>$$<br>T＝\frac{1}{2} \rho v^{2} S(C_{x0} +\frac{C_{L}^{2} }{\pi \lambda } )<br>$$</p><h3 id="3-跨介质飞行器MATLAB进行参数估算"><a href="#3-跨介质飞行器MATLAB进行参数估算" class="headerlink" title="3.跨介质飞行器MATLAB进行参数估算"></a>3.跨介质飞行器MATLAB进行参数估算</h3><p>我们选取爬升约束、航时约束、巡航约束、最大平飞速度约束、失速速度约束来作为飞机性能的基本要求。通过参照相关参数和经验公式，确定各个约束方程的相关参数，如下表所示，由此可以绘制出约束曲线族。</p><h4 id="a-爬升约束"><a href="#a-爬升约束" class="headerlink" title="a. 爬升约束"></a>a. 爬升约束</h4><ul><li><img src="../images/wing/wing1.png"></li></ul><p>飞行器在稳定爬上状态时，采用的推重比计算公式是：<br>$$<br>\frac{T}{W} ＝sin\alpha +\frac{(C_{x0} +\frac{C_{L,max}^{2} }{\pi\lambda e } )cos\alpha }{C_{L,max} }<br>$$<br>式中：$C_{x0}$为飞行器的零升阻力系数，$C_{L,max}$为飞行器的最 大升力系数，α为最大爬升角， λ为展弦比，e为奥斯瓦尔德效率因子。</p><h4 id="b-航时约束"><a href="#b-航时约束" class="headerlink" title="b. 航时约束"></a>b. 航时约束</h4><p>螺旋桨飞机航时最大时的翼载可以用下列公式进行计算：<br>$$<br>\frac{W}{S} ＝\frac{1}{2} \rho v^{2} \sqrt{3\pi \lambda eC_{x0} }<br>$$</p><h4 id="c-巡航速度约束"><a href="#c-巡航速度约束" class="headerlink" title="c. 巡航速度约束"></a>c. 巡航速度约束</h4><p>飞行器在巡航时，处于水平匀速飞行状态。这个时候飞行器的重量等于作用在飞行器上的升力，而推力等于阻力，所以推重比等于升阻比（或升力系数和阻力系数的比值）的倒数，其计算公式如下：<br>$$<br>\frac{T}{W} ＝\frac{C_{x0} +\frac{C_{L}^{2} }{\pi \lambda } }{C_{L}}<br>$$</p><h4 id="d-最大平飞速度约束"><a href="#d-最大平飞速度约束" class="headerlink" title="d. 最大平飞速度约束"></a>d. 最大平飞速度约束</h4><p>推重比也可以根据最大平飞速度来确定。如果能够得到最大平飞速度和翼载，就能计算出所需要的推重比.在水平飞行状态下,推力T需要克服飞行阻力。根据阻力公式，阻力D可以表示为：D &#x3D; 1&#x2F;2 * ρ * V_max^2 * C_x * S，其中 S 为机翼面积。为了计算推重比，需要将推力与重量之比表示为阻力与重量之比。因此，需要将阻力公式中的机翼面积S用重量W和翼载荷（W&#x2F;S）表示。由于 W&#x2F;S &#x3D; W &#x2F; S，可以得到 S &#x3D; W &#x2F; (W&#x2F;S)。<br>$$<br>\frac{T}{W} ＝\frac{\frac{1}{2} \rho V <em>{max}^{2} C</em>{x} }{\frac{W}{S} }<br>$$<br>式中：$V_{max}$为飞行器的失速速度；$C_{x}$为飞行器的阻力系数。</p><h4 id="e-失速速度约束"><a href="#e-失速速度约束" class="headerlink" title="e.失速速度约束"></a>e.失速速度约束</h4><p>由飞行器水平飞行时升力等于飞机的质量可以得到翼载表达式:<br>$$<br>\frac{W}{S}＝\frac{1}{2} \rho  V_{S}^{2}C_{L,max}<br>$$<br>式中：$V_{S}$为飞行器的失速速度。</p><table><thead><tr><th align="center">约束类型</th><th align="center">约束曲线公式</th><th align="center">参数选择</th></tr></thead><tbody><tr><td align="center">爬升约束</td><td align="center">$\frac{T}{W} ＝sin\alpha +\frac{(C_{x0} +\frac{C_{L,max}^{2} }{\pi\lambda e } )cos\alpha }{C_{L,max} }$</td><td align="center">α&#x3D;8°;$C_{x0}$ &#x3D;0.01;$C_{L,max}$&#x3D;1.4;λ&#x3D;8;e&#x3D;1</td></tr><tr><td align="center">航时约束</td><td align="center">$\frac{W}{S} ＝\frac{1}{2} \rho v^{2} \sqrt{3\pi \lambda eC_{x0} }$</td><td align="center">$\rho$&#x3D;1.226;v&#x3D;16.67;λ&#x3D;8;e&#x3D;1;$C_{x0}$ &#x3D;0.01</td></tr><tr><td align="center">巡航速度约束</td><td align="center">$\frac{T}{W} ＝\frac{C_{x0} +\frac{C_{L}^{2} }{\pi \lambda } }{C_{L}}$</td><td align="center">$C_{x0}$ &#x3D;0.01;$C_{L}$&#x3D;1;λ&#x3D;8</td></tr><tr><td align="center">最大平飞速度约束</td><td align="center">$\frac{T}{W} ＝\frac{\frac{1}{2} \rho V <em>{max}^{2} C</em>{x} }{\frac{W}{S} }$</td><td align="center">$\rho$&#x3D;1.226;$V_{max}$&#x3D;33.34</td></tr><tr><td align="center">失速速度约束</td><td align="center">$\frac{W}{S}＝\frac{1}{2} \rho  V_{S}^{2}C_{L,max}$</td><td align="center">$V_{S}$&#x3D;10;$C_{L,max}$&#x3D;1.4</td></tr></tbody></table><p><img src="../images/wing/wing2.png"></p><p>由上图可以得出，翼载荷为 168.5N&#x2F;m^2^，即17.194kg&#x2F;m^2^,推重比在 0.2013 以上。</p><h3 id="4-总体布局设计"><a href="#4-总体布局设计" class="headerlink" title="4.总体布局设计"></a>4.总体布局设计</h3><p>由于平直机翼有低速性能良好而且升阻比较高的优点,故采用常规的平直梯形机翼。</p><p>机翼的气动特性受到机翼平面几何参数包括翼面积 S、展弦比$\lambda $ 、根梢比η 等的影响。其中，展弦比的变化将影响机翼的气动导数，如诱导阻力系数$  C_{X_{i} }  $ 、零升阻力系数$ C_{X_{0} }  $ 和升力线斜率$C_{y}^{α} $等，增大展弦比将在减小机翼诱导阻力的同时增大升阻比；而减小展弦比可以减小机翼根部的弯矩、减轻结构重量，从而有利于承力构件的布置和内部容积的利用，与此同时也可以防止大迎角时的翼尖失速。综合考虑各方面因素选取展弦比$\lambda $&#x3D;8。由初始设定和前文计算可知：预估翼载荷$W_{T}$ &#x2F;S 为17.194kg&#x2F;m^2^ ，飞行器的最大起飞重量为 1.5kg，则暂定的梯形机翼面积为S&#x3D;0.0872m^2^ 。</p><p>接下来，我们需要用展弦比（$\lambda $）和机翼面积（S）来计算翼展（b）。展弦比的公式为：<br>$$<br>\lambda  &#x3D; b² &#x2F; S<br>$$<br>翼展b ≈ 0.835 m</p><p>接着确定机翼的根梢比η  ，由于设计无人机巡航速度为 16.67m&#x2F;s，需要考虑机翼诱导阻力的影响，机翼的诱导阻力可以表示成<br>$$<br>C_{xi} ＝K\frac{ C_{L}^{2}}{π λ }<br>$$<br>当展弦比为定值时，系数 k 是关于根梢比的函数，由 k 与根梢比η 的关系曲线,即查找资料得到在η &#x3D;1.25 时 k 的值较为理想，且机翼上的气动载荷分布也最接近椭圆形，其余部件尺寸也较为合理。</p><p><img src="../images/wing/wing3.png"></p><p>根据机翼的梯形面积公式和转换后的根梢比的公式：<br>$$<br>S &#x3D; (c_{root} + c_{tip}) * b &#x2F; 2<br>$$</p><p>$$<br>c_{tip} &#x3D; c_{root} &#x2F; η<br>$$</p><p>所以，翼根处弦长约为0.175 m，翼梢处弦长约为0.140 m，机翼整体平均气动弦长约为0.104 m。</p><p><img src="../images/wing/wing4.png"></p><h4 id="翼型选择"><a href="#翼型选择" class="headerlink" title="翼型选择"></a>翼型选择</h4><p>一般情况下，翼型的选择需满足下列条件：</p><p>（1）最大升力系数尽可能大；</p><p>（2）在设计升力系数点的阻力系数应尽量小；</p><p>（3）在设计升力系数附近，应具有一段尽量平直的低阻区，防止飞机速度变化时阻力产生</p><p>较大的波动；</p><p>（4）可用迎角范围尽量大以防止失速，且巡航状态下的迎角应尽量远离失速迎角；</p><p>（5）相对厚度不能太小，以免机翼付出结构重量上的代价；</p><p>（6）翼型的零升力矩系数不能太大，以免引起太大的配平力矩。</p><p>雷诺数计算公式：<br>$$<br>R_{e} ＝\frac{\rho vD}{u}<br>$$<br>式中，$\rho$ 为空气密度，<em>u</em> 为空气粘度，$\rho$ &#x3D;1.226*kg &#x2F;m^3^ ，*u &#x3D;$1.79\times 10^{-5} N\cdot s&#x2F;m^{} $均为常数；</p><p><em>v</em> 为空气流速，根据巡航速度，取 16.67 m&#x2F;s； <em>D</em> 为特征尺寸，这里取平均气动弦长，即0.104m。带入数据，算得雷诺数$R_{e}$约为 118743。</p><p>五种翼型的升力系数、阻力系数、升阻比系数和俯仰力矩系数曲线图。</p><p>NACA4412(翼型的相对弯度为4%，最大弯度位置在弦长的0.4，相对厚度为12%)；</p><p>CLARK Y( 翼型的相对弯度为3.43%，最大弯度位置在弦长的0.42，相对厚度为11.71%);</p><p>NACA2415(翼型的相对弯度为2%，最大弯度位置在弦长的0.4，相对厚度为15%)；</p><p>USA-35B(翼型的相对弯度为3.19%，最大弯度位置在弦长的0.3，相对厚度为11.61%)；</p><p>NACA2412(翼型的相对弯度为2%，最大弯度位置在弦长的0.4，相对厚度为12%)；</p><p><img src="../images/wing/wing5.png"></p><p><img src="../images/wing/wing6.png"></p><p><img src="../images/wing/wing7.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> UAV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/hello-world/"/>
      <url>/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
